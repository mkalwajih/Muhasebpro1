// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class InventoryConfig extends Table
    with TableInfo<InventoryConfig, InventoryConfigData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  InventoryConfig(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _defaultCostingMethodMeta =
      const VerificationMeta('defaultCostingMethod');
  late final GeneratedColumn<String> defaultCostingMethod = GeneratedColumn<
          String>('default_costing_method', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL CHECK (default_costing_method IN (\'Weighted Average\', \'FIFO\', \'LIFO\'))');
  static const VerificationMeta _allowItemLevelOverrideMeta =
      const VerificationMeta('allowItemLevelOverride');
  late final GeneratedColumn<bool> allowItemLevelOverride =
      GeneratedColumn<bool>('allow_item_level_override', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          $customConstraints: 'NOT NULL DEFAULT TRUE',
          defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _enableMultipleWarehousesMeta =
      const VerificationMeta('enableMultipleWarehouses');
  late final GeneratedColumn<bool> enableMultipleWarehouses =
      GeneratedColumn<bool>('enable_multiple_warehouses', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          $customConstraints: 'NOT NULL DEFAULT TRUE',
          defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _transfersIntermediaryAccountIdMeta =
      const VerificationMeta('transfersIntermediaryAccountId');
  late final GeneratedColumn<String> transfersIntermediaryAccountId =
      GeneratedColumn<String>(
          'transfers_intermediary_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _enableExpiryDateTrackingMeta =
      const VerificationMeta('enableExpiryDateTracking');
  late final GeneratedColumn<bool> enableExpiryDateTracking =
      GeneratedColumn<bool>('enable_expiry_date_tracking', aliasedName, false,
          type: DriftSqlType.bool,
          requiredDuringInsert: false,
          $customConstraints: 'NOT NULL DEFAULT FALSE',
          defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _enableBatchTrackingMeta =
      const VerificationMeta('enableBatchTracking');
  late final GeneratedColumn<bool> enableBatchTracking = GeneratedColumn<bool>(
      'enable_batch_tracking', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _openingBalanceEquityAccountIdMeta =
      const VerificationMeta('openingBalanceEquityAccountId');
  late final GeneratedColumn<String> openingBalanceEquityAccountId =
      GeneratedColumn<String>(
          'opening_balance_equity_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _stockReceivedClearingAccountIdMeta =
      const VerificationMeta('stockReceivedClearingAccountId');
  late final GeneratedColumn<String> stockReceivedClearingAccountId =
      GeneratedColumn<String>(
          'stock_received_clearing_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _inventoryShortageExpenseAccountIdMeta =
      const VerificationMeta('inventoryShortageExpenseAccountId');
  late final GeneratedColumn<String> inventoryShortageExpenseAccountId =
      GeneratedColumn<String>(
          'inventory_shortage_expense_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _inventorySurplusRevenueAccountIdMeta =
      const VerificationMeta('inventorySurplusRevenueAccountId');
  late final GeneratedColumn<String> inventorySurplusRevenueAccountId =
      GeneratedColumn<String>(
          'inventory_surplus_revenue_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        defaultCostingMethod,
        allowItemLevelOverride,
        enableMultipleWarehouses,
        transfersIntermediaryAccountId,
        enableExpiryDateTracking,
        enableBatchTracking,
        openingBalanceEquityAccountId,
        stockReceivedClearingAccountId,
        inventoryShortageExpenseAccountId,
        inventorySurplusRevenueAccountId,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'inventory_config';
  @override
  VerificationContext validateIntegrity(
      Insertable<InventoryConfigData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('default_costing_method')) {
      context.handle(
          _defaultCostingMethodMeta,
          defaultCostingMethod.isAcceptableOrUnknown(
              data['default_costing_method']!, _defaultCostingMethodMeta));
    } else if (isInserting) {
      context.missing(_defaultCostingMethodMeta);
    }
    if (data.containsKey('allow_item_level_override')) {
      context.handle(
          _allowItemLevelOverrideMeta,
          allowItemLevelOverride.isAcceptableOrUnknown(
              data['allow_item_level_override']!, _allowItemLevelOverrideMeta));
    }
    if (data.containsKey('enable_multiple_warehouses')) {
      context.handle(
          _enableMultipleWarehousesMeta,
          enableMultipleWarehouses.isAcceptableOrUnknown(
              data['enable_multiple_warehouses']!,
              _enableMultipleWarehousesMeta));
    }
    if (data.containsKey('transfers_intermediary_account_id')) {
      context.handle(
          _transfersIntermediaryAccountIdMeta,
          transfersIntermediaryAccountId.isAcceptableOrUnknown(
              data['transfers_intermediary_account_id']!,
              _transfersIntermediaryAccountIdMeta));
    }
    if (data.containsKey('enable_expiry_date_tracking')) {
      context.handle(
          _enableExpiryDateTrackingMeta,
          enableExpiryDateTracking.isAcceptableOrUnknown(
              data['enable_expiry_date_tracking']!,
              _enableExpiryDateTrackingMeta));
    }
    if (data.containsKey('enable_batch_tracking')) {
      context.handle(
          _enableBatchTrackingMeta,
          enableBatchTracking.isAcceptableOrUnknown(
              data['enable_batch_tracking']!, _enableBatchTrackingMeta));
    }
    if (data.containsKey('opening_balance_equity_account_id')) {
      context.handle(
          _openingBalanceEquityAccountIdMeta,
          openingBalanceEquityAccountId.isAcceptableOrUnknown(
              data['opening_balance_equity_account_id']!,
              _openingBalanceEquityAccountIdMeta));
    }
    if (data.containsKey('stock_received_clearing_account_id')) {
      context.handle(
          _stockReceivedClearingAccountIdMeta,
          stockReceivedClearingAccountId.isAcceptableOrUnknown(
              data['stock_received_clearing_account_id']!,
              _stockReceivedClearingAccountIdMeta));
    }
    if (data.containsKey('inventory_shortage_expense_account_id')) {
      context.handle(
          _inventoryShortageExpenseAccountIdMeta,
          inventoryShortageExpenseAccountId.isAcceptableOrUnknown(
              data['inventory_shortage_expense_account_id']!,
              _inventoryShortageExpenseAccountIdMeta));
    }
    if (data.containsKey('inventory_surplus_revenue_account_id')) {
      context.handle(
          _inventorySurplusRevenueAccountIdMeta,
          inventorySurplusRevenueAccountId.isAcceptableOrUnknown(
              data['inventory_surplus_revenue_account_id']!,
              _inventorySurplusRevenueAccountIdMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InventoryConfigData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InventoryConfigData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      defaultCostingMethod: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}default_costing_method'])!,
      allowItemLevelOverride: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}allow_item_level_override'])!,
      enableMultipleWarehouses: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}enable_multiple_warehouses'])!,
      transfersIntermediaryAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}transfers_intermediary_account_id']),
      enableExpiryDateTracking: attachedDatabase.typeMapping.read(
          DriftSqlType.bool,
          data['${effectivePrefix}enable_expiry_date_tracking'])!,
      enableBatchTracking: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}enable_batch_tracking'])!,
      openingBalanceEquityAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}opening_balance_equity_account_id']),
      stockReceivedClearingAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}stock_received_clearing_account_id']),
      inventoryShortageExpenseAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}inventory_shortage_expense_account_id']),
      inventorySurplusRevenueAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}inventory_surplus_revenue_account_id']),
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  InventoryConfig createAlias(String alias) {
    return InventoryConfig(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class InventoryConfigData extends DataClass
    implements Insertable<InventoryConfigData> {
  final int id;
  final String defaultCostingMethod;
  final bool allowItemLevelOverride;
  final bool enableMultipleWarehouses;
  final String? transfersIntermediaryAccountId;
  final bool enableExpiryDateTracking;
  final bool enableBatchTracking;
  final String? openingBalanceEquityAccountId;
  final String? stockReceivedClearingAccountId;
  final String? inventoryShortageExpenseAccountId;
  final String? inventorySurplusRevenueAccountId;
  final int updatedAt;
  const InventoryConfigData(
      {required this.id,
      required this.defaultCostingMethod,
      required this.allowItemLevelOverride,
      required this.enableMultipleWarehouses,
      this.transfersIntermediaryAccountId,
      required this.enableExpiryDateTracking,
      required this.enableBatchTracking,
      this.openingBalanceEquityAccountId,
      this.stockReceivedClearingAccountId,
      this.inventoryShortageExpenseAccountId,
      this.inventorySurplusRevenueAccountId,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['default_costing_method'] = Variable<String>(defaultCostingMethod);
    map['allow_item_level_override'] = Variable<bool>(allowItemLevelOverride);
    map['enable_multiple_warehouses'] =
        Variable<bool>(enableMultipleWarehouses);
    if (!nullToAbsent || transfersIntermediaryAccountId != null) {
      map['transfers_intermediary_account_id'] =
          Variable<String>(transfersIntermediaryAccountId);
    }
    map['enable_expiry_date_tracking'] =
        Variable<bool>(enableExpiryDateTracking);
    map['enable_batch_tracking'] = Variable<bool>(enableBatchTracking);
    if (!nullToAbsent || openingBalanceEquityAccountId != null) {
      map['opening_balance_equity_account_id'] =
          Variable<String>(openingBalanceEquityAccountId);
    }
    if (!nullToAbsent || stockReceivedClearingAccountId != null) {
      map['stock_received_clearing_account_id'] =
          Variable<String>(stockReceivedClearingAccountId);
    }
    if (!nullToAbsent || inventoryShortageExpenseAccountId != null) {
      map['inventory_shortage_expense_account_id'] =
          Variable<String>(inventoryShortageExpenseAccountId);
    }
    if (!nullToAbsent || inventorySurplusRevenueAccountId != null) {
      map['inventory_surplus_revenue_account_id'] =
          Variable<String>(inventorySurplusRevenueAccountId);
    }
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  InventoryConfigCompanion toCompanion(bool nullToAbsent) {
    return InventoryConfigCompanion(
      id: Value(id),
      defaultCostingMethod: Value(defaultCostingMethod),
      allowItemLevelOverride: Value(allowItemLevelOverride),
      enableMultipleWarehouses: Value(enableMultipleWarehouses),
      transfersIntermediaryAccountId:
          transfersIntermediaryAccountId == null && nullToAbsent
              ? const Value.absent()
              : Value(transfersIntermediaryAccountId),
      enableExpiryDateTracking: Value(enableExpiryDateTracking),
      enableBatchTracking: Value(enableBatchTracking),
      openingBalanceEquityAccountId:
          openingBalanceEquityAccountId == null && nullToAbsent
              ? const Value.absent()
              : Value(openingBalanceEquityAccountId),
      stockReceivedClearingAccountId:
          stockReceivedClearingAccountId == null && nullToAbsent
              ? const Value.absent()
              : Value(stockReceivedClearingAccountId),
      inventoryShortageExpenseAccountId:
          inventoryShortageExpenseAccountId == null && nullToAbsent
              ? const Value.absent()
              : Value(inventoryShortageExpenseAccountId),
      inventorySurplusRevenueAccountId:
          inventorySurplusRevenueAccountId == null && nullToAbsent
              ? const Value.absent()
              : Value(inventorySurplusRevenueAccountId),
      updatedAt: Value(updatedAt),
    );
  }

  factory InventoryConfigData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InventoryConfigData(
      id: serializer.fromJson<int>(json['id']),
      defaultCostingMethod:
          serializer.fromJson<String>(json['default_costing_method']),
      allowItemLevelOverride:
          serializer.fromJson<bool>(json['allow_item_level_override']),
      enableMultipleWarehouses:
          serializer.fromJson<bool>(json['enable_multiple_warehouses']),
      transfersIntermediaryAccountId: serializer
          .fromJson<String?>(json['transfers_intermediary_account_id']),
      enableExpiryDateTracking:
          serializer.fromJson<bool>(json['enable_expiry_date_tracking']),
      enableBatchTracking:
          serializer.fromJson<bool>(json['enable_batch_tracking']),
      openingBalanceEquityAccountId: serializer
          .fromJson<String?>(json['opening_balance_equity_account_id']),
      stockReceivedClearingAccountId: serializer
          .fromJson<String?>(json['stock_received_clearing_account_id']),
      inventoryShortageExpenseAccountId: serializer
          .fromJson<String?>(json['inventory_shortage_expense_account_id']),
      inventorySurplusRevenueAccountId: serializer
          .fromJson<String?>(json['inventory_surplus_revenue_account_id']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'default_costing_method': serializer.toJson<String>(defaultCostingMethod),
      'allow_item_level_override':
          serializer.toJson<bool>(allowItemLevelOverride),
      'enable_multiple_warehouses':
          serializer.toJson<bool>(enableMultipleWarehouses),
      'transfers_intermediary_account_id':
          serializer.toJson<String?>(transfersIntermediaryAccountId),
      'enable_expiry_date_tracking':
          serializer.toJson<bool>(enableExpiryDateTracking),
      'enable_batch_tracking': serializer.toJson<bool>(enableBatchTracking),
      'opening_balance_equity_account_id':
          serializer.toJson<String?>(openingBalanceEquityAccountId),
      'stock_received_clearing_account_id':
          serializer.toJson<String?>(stockReceivedClearingAccountId),
      'inventory_shortage_expense_account_id':
          serializer.toJson<String?>(inventoryShortageExpenseAccountId),
      'inventory_surplus_revenue_account_id':
          serializer.toJson<String?>(inventorySurplusRevenueAccountId),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  InventoryConfigData copyWith(
          {int? id,
          String? defaultCostingMethod,
          bool? allowItemLevelOverride,
          bool? enableMultipleWarehouses,
          Value<String?> transfersIntermediaryAccountId = const Value.absent(),
          bool? enableExpiryDateTracking,
          bool? enableBatchTracking,
          Value<String?> openingBalanceEquityAccountId = const Value.absent(),
          Value<String?> stockReceivedClearingAccountId = const Value.absent(),
          Value<String?> inventoryShortageExpenseAccountId =
              const Value.absent(),
          Value<String?> inventorySurplusRevenueAccountId =
              const Value.absent(),
          int? updatedAt}) =>
      InventoryConfigData(
        id: id ?? this.id,
        defaultCostingMethod: defaultCostingMethod ?? this.defaultCostingMethod,
        allowItemLevelOverride:
            allowItemLevelOverride ?? this.allowItemLevelOverride,
        enableMultipleWarehouses:
            enableMultipleWarehouses ?? this.enableMultipleWarehouses,
        transfersIntermediaryAccountId: transfersIntermediaryAccountId.present
            ? transfersIntermediaryAccountId.value
            : this.transfersIntermediaryAccountId,
        enableExpiryDateTracking:
            enableExpiryDateTracking ?? this.enableExpiryDateTracking,
        enableBatchTracking: enableBatchTracking ?? this.enableBatchTracking,
        openingBalanceEquityAccountId: openingBalanceEquityAccountId.present
            ? openingBalanceEquityAccountId.value
            : this.openingBalanceEquityAccountId,
        stockReceivedClearingAccountId: stockReceivedClearingAccountId.present
            ? stockReceivedClearingAccountId.value
            : this.stockReceivedClearingAccountId,
        inventoryShortageExpenseAccountId:
            inventoryShortageExpenseAccountId.present
                ? inventoryShortageExpenseAccountId.value
                : this.inventoryShortageExpenseAccountId,
        inventorySurplusRevenueAccountId:
            inventorySurplusRevenueAccountId.present
                ? inventorySurplusRevenueAccountId.value
                : this.inventorySurplusRevenueAccountId,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  InventoryConfigData copyWithCompanion(InventoryConfigCompanion data) {
    return InventoryConfigData(
      id: data.id.present ? data.id.value : this.id,
      defaultCostingMethod: data.defaultCostingMethod.present
          ? data.defaultCostingMethod.value
          : this.defaultCostingMethod,
      allowItemLevelOverride: data.allowItemLevelOverride.present
          ? data.allowItemLevelOverride.value
          : this.allowItemLevelOverride,
      enableMultipleWarehouses: data.enableMultipleWarehouses.present
          ? data.enableMultipleWarehouses.value
          : this.enableMultipleWarehouses,
      transfersIntermediaryAccountId:
          data.transfersIntermediaryAccountId.present
              ? data.transfersIntermediaryAccountId.value
              : this.transfersIntermediaryAccountId,
      enableExpiryDateTracking: data.enableExpiryDateTracking.present
          ? data.enableExpiryDateTracking.value
          : this.enableExpiryDateTracking,
      enableBatchTracking: data.enableBatchTracking.present
          ? data.enableBatchTracking.value
          : this.enableBatchTracking,
      openingBalanceEquityAccountId: data.openingBalanceEquityAccountId.present
          ? data.openingBalanceEquityAccountId.value
          : this.openingBalanceEquityAccountId,
      stockReceivedClearingAccountId:
          data.stockReceivedClearingAccountId.present
              ? data.stockReceivedClearingAccountId.value
              : this.stockReceivedClearingAccountId,
      inventoryShortageExpenseAccountId:
          data.inventoryShortageExpenseAccountId.present
              ? data.inventoryShortageExpenseAccountId.value
              : this.inventoryShortageExpenseAccountId,
      inventorySurplusRevenueAccountId:
          data.inventorySurplusRevenueAccountId.present
              ? data.inventorySurplusRevenueAccountId.value
              : this.inventorySurplusRevenueAccountId,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InventoryConfigData(')
          ..write('id: $id, ')
          ..write('defaultCostingMethod: $defaultCostingMethod, ')
          ..write('allowItemLevelOverride: $allowItemLevelOverride, ')
          ..write('enableMultipleWarehouses: $enableMultipleWarehouses, ')
          ..write(
              'transfersIntermediaryAccountId: $transfersIntermediaryAccountId, ')
          ..write('enableExpiryDateTracking: $enableExpiryDateTracking, ')
          ..write('enableBatchTracking: $enableBatchTracking, ')
          ..write(
              'openingBalanceEquityAccountId: $openingBalanceEquityAccountId, ')
          ..write(
              'stockReceivedClearingAccountId: $stockReceivedClearingAccountId, ')
          ..write(
              'inventoryShortageExpenseAccountId: $inventoryShortageExpenseAccountId, ')
          ..write(
              'inventorySurplusRevenueAccountId: $inventorySurplusRevenueAccountId, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      defaultCostingMethod,
      allowItemLevelOverride,
      enableMultipleWarehouses,
      transfersIntermediaryAccountId,
      enableExpiryDateTracking,
      enableBatchTracking,
      openingBalanceEquityAccountId,
      stockReceivedClearingAccountId,
      inventoryShortageExpenseAccountId,
      inventorySurplusRevenueAccountId,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InventoryConfigData &&
          other.id == this.id &&
          other.defaultCostingMethod == this.defaultCostingMethod &&
          other.allowItemLevelOverride == this.allowItemLevelOverride &&
          other.enableMultipleWarehouses == this.enableMultipleWarehouses &&
          other.transfersIntermediaryAccountId ==
              this.transfersIntermediaryAccountId &&
          other.enableExpiryDateTracking == this.enableExpiryDateTracking &&
          other.enableBatchTracking == this.enableBatchTracking &&
          other.openingBalanceEquityAccountId ==
              this.openingBalanceEquityAccountId &&
          other.stockReceivedClearingAccountId ==
              this.stockReceivedClearingAccountId &&
          other.inventoryShortageExpenseAccountId ==
              this.inventoryShortageExpenseAccountId &&
          other.inventorySurplusRevenueAccountId ==
              this.inventorySurplusRevenueAccountId &&
          other.updatedAt == this.updatedAt);
}

class InventoryConfigCompanion extends UpdateCompanion<InventoryConfigData> {
  final Value<int> id;
  final Value<String> defaultCostingMethod;
  final Value<bool> allowItemLevelOverride;
  final Value<bool> enableMultipleWarehouses;
  final Value<String?> transfersIntermediaryAccountId;
  final Value<bool> enableExpiryDateTracking;
  final Value<bool> enableBatchTracking;
  final Value<String?> openingBalanceEquityAccountId;
  final Value<String?> stockReceivedClearingAccountId;
  final Value<String?> inventoryShortageExpenseAccountId;
  final Value<String?> inventorySurplusRevenueAccountId;
  final Value<int> updatedAt;
  const InventoryConfigCompanion({
    this.id = const Value.absent(),
    this.defaultCostingMethod = const Value.absent(),
    this.allowItemLevelOverride = const Value.absent(),
    this.enableMultipleWarehouses = const Value.absent(),
    this.transfersIntermediaryAccountId = const Value.absent(),
    this.enableExpiryDateTracking = const Value.absent(),
    this.enableBatchTracking = const Value.absent(),
    this.openingBalanceEquityAccountId = const Value.absent(),
    this.stockReceivedClearingAccountId = const Value.absent(),
    this.inventoryShortageExpenseAccountId = const Value.absent(),
    this.inventorySurplusRevenueAccountId = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  InventoryConfigCompanion.insert({
    this.id = const Value.absent(),
    required String defaultCostingMethod,
    this.allowItemLevelOverride = const Value.absent(),
    this.enableMultipleWarehouses = const Value.absent(),
    this.transfersIntermediaryAccountId = const Value.absent(),
    this.enableExpiryDateTracking = const Value.absent(),
    this.enableBatchTracking = const Value.absent(),
    this.openingBalanceEquityAccountId = const Value.absent(),
    this.stockReceivedClearingAccountId = const Value.absent(),
    this.inventoryShortageExpenseAccountId = const Value.absent(),
    this.inventorySurplusRevenueAccountId = const Value.absent(),
    required int updatedAt,
  })  : defaultCostingMethod = Value(defaultCostingMethod),
        updatedAt = Value(updatedAt);
  static Insertable<InventoryConfigData> custom({
    Expression<int>? id,
    Expression<String>? defaultCostingMethod,
    Expression<bool>? allowItemLevelOverride,
    Expression<bool>? enableMultipleWarehouses,
    Expression<String>? transfersIntermediaryAccountId,
    Expression<bool>? enableExpiryDateTracking,
    Expression<bool>? enableBatchTracking,
    Expression<String>? openingBalanceEquityAccountId,
    Expression<String>? stockReceivedClearingAccountId,
    Expression<String>? inventoryShortageExpenseAccountId,
    Expression<String>? inventorySurplusRevenueAccountId,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (defaultCostingMethod != null)
        'default_costing_method': defaultCostingMethod,
      if (allowItemLevelOverride != null)
        'allow_item_level_override': allowItemLevelOverride,
      if (enableMultipleWarehouses != null)
        'enable_multiple_warehouses': enableMultipleWarehouses,
      if (transfersIntermediaryAccountId != null)
        'transfers_intermediary_account_id': transfersIntermediaryAccountId,
      if (enableExpiryDateTracking != null)
        'enable_expiry_date_tracking': enableExpiryDateTracking,
      if (enableBatchTracking != null)
        'enable_batch_tracking': enableBatchTracking,
      if (openingBalanceEquityAccountId != null)
        'opening_balance_equity_account_id': openingBalanceEquityAccountId,
      if (stockReceivedClearingAccountId != null)
        'stock_received_clearing_account_id': stockReceivedClearingAccountId,
      if (inventoryShortageExpenseAccountId != null)
        'inventory_shortage_expense_account_id':
            inventoryShortageExpenseAccountId,
      if (inventorySurplusRevenueAccountId != null)
        'inventory_surplus_revenue_account_id':
            inventorySurplusRevenueAccountId,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  InventoryConfigCompanion copyWith(
      {Value<int>? id,
      Value<String>? defaultCostingMethod,
      Value<bool>? allowItemLevelOverride,
      Value<bool>? enableMultipleWarehouses,
      Value<String?>? transfersIntermediaryAccountId,
      Value<bool>? enableExpiryDateTracking,
      Value<bool>? enableBatchTracking,
      Value<String?>? openingBalanceEquityAccountId,
      Value<String?>? stockReceivedClearingAccountId,
      Value<String?>? inventoryShortageExpenseAccountId,
      Value<String?>? inventorySurplusRevenueAccountId,
      Value<int>? updatedAt}) {
    return InventoryConfigCompanion(
      id: id ?? this.id,
      defaultCostingMethod: defaultCostingMethod ?? this.defaultCostingMethod,
      allowItemLevelOverride:
          allowItemLevelOverride ?? this.allowItemLevelOverride,
      enableMultipleWarehouses:
          enableMultipleWarehouses ?? this.enableMultipleWarehouses,
      transfersIntermediaryAccountId:
          transfersIntermediaryAccountId ?? this.transfersIntermediaryAccountId,
      enableExpiryDateTracking:
          enableExpiryDateTracking ?? this.enableExpiryDateTracking,
      enableBatchTracking: enableBatchTracking ?? this.enableBatchTracking,
      openingBalanceEquityAccountId:
          openingBalanceEquityAccountId ?? this.openingBalanceEquityAccountId,
      stockReceivedClearingAccountId:
          stockReceivedClearingAccountId ?? this.stockReceivedClearingAccountId,
      inventoryShortageExpenseAccountId: inventoryShortageExpenseAccountId ??
          this.inventoryShortageExpenseAccountId,
      inventorySurplusRevenueAccountId: inventorySurplusRevenueAccountId ??
          this.inventorySurplusRevenueAccountId,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (defaultCostingMethod.present) {
      map['default_costing_method'] =
          Variable<String>(defaultCostingMethod.value);
    }
    if (allowItemLevelOverride.present) {
      map['allow_item_level_override'] =
          Variable<bool>(allowItemLevelOverride.value);
    }
    if (enableMultipleWarehouses.present) {
      map['enable_multiple_warehouses'] =
          Variable<bool>(enableMultipleWarehouses.value);
    }
    if (transfersIntermediaryAccountId.present) {
      map['transfers_intermediary_account_id'] =
          Variable<String>(transfersIntermediaryAccountId.value);
    }
    if (enableExpiryDateTracking.present) {
      map['enable_expiry_date_tracking'] =
          Variable<bool>(enableExpiryDateTracking.value);
    }
    if (enableBatchTracking.present) {
      map['enable_batch_tracking'] = Variable<bool>(enableBatchTracking.value);
    }
    if (openingBalanceEquityAccountId.present) {
      map['opening_balance_equity_account_id'] =
          Variable<String>(openingBalanceEquityAccountId.value);
    }
    if (stockReceivedClearingAccountId.present) {
      map['stock_received_clearing_account_id'] =
          Variable<String>(stockReceivedClearingAccountId.value);
    }
    if (inventoryShortageExpenseAccountId.present) {
      map['inventory_shortage_expense_account_id'] =
          Variable<String>(inventoryShortageExpenseAccountId.value);
    }
    if (inventorySurplusRevenueAccountId.present) {
      map['inventory_surplus_revenue_account_id'] =
          Variable<String>(inventorySurplusRevenueAccountId.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InventoryConfigCompanion(')
          ..write('id: $id, ')
          ..write('defaultCostingMethod: $defaultCostingMethod, ')
          ..write('allowItemLevelOverride: $allowItemLevelOverride, ')
          ..write('enableMultipleWarehouses: $enableMultipleWarehouses, ')
          ..write(
              'transfersIntermediaryAccountId: $transfersIntermediaryAccountId, ')
          ..write('enableExpiryDateTracking: $enableExpiryDateTracking, ')
          ..write('enableBatchTracking: $enableBatchTracking, ')
          ..write(
              'openingBalanceEquityAccountId: $openingBalanceEquityAccountId, ')
          ..write(
              'stockReceivedClearingAccountId: $stockReceivedClearingAccountId, ')
          ..write(
              'inventoryShortageExpenseAccountId: $inventoryShortageExpenseAccountId, ')
          ..write(
              'inventorySurplusRevenueAccountId: $inventorySurplusRevenueAccountId, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class CompanyInfo extends Table with TableInfo<CompanyInfo, CompanyInfoData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  CompanyInfo(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _companyCodeMeta =
      const VerificationMeta('companyCode');
  late final GeneratedColumn<String> companyCode = GeneratedColumn<String>(
      'company_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _countryIdMeta =
      const VerificationMeta('countryId');
  late final GeneratedColumn<String> countryId = GeneratedColumn<String>(
      'country_id', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _taxNumberMeta =
      const VerificationMeta('taxNumber');
  late final GeneratedColumn<String> taxNumber = GeneratedColumn<String>(
      'tax_number', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _commercialRegNoMeta =
      const VerificationMeta('commercialRegNo');
  late final GeneratedColumn<String> commercialRegNo = GeneratedColumn<String>(
      'commercial_reg_no', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _addressMeta =
      const VerificationMeta('address');
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
      'address', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
      'email', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _logoMeta = const VerificationMeta('logo');
  late final GeneratedColumn<Uint8List> logo = GeneratedColumn<Uint8List>(
      'logo', aliasedName, true,
      type: DriftSqlType.blob,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _isMainCompanyMeta =
      const VerificationMeta('isMainCompany');
  late final GeneratedColumn<bool> isMainCompany = GeneratedColumn<bool>(
      'is_main_company', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _remarksMeta =
      const VerificationMeta('remarks');
  late final GeneratedColumn<String> remarks = GeneratedColumn<String>(
      'remarks', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        companyCode,
        nameAr,
        nameEn,
        countryId,
        taxNumber,
        commercialRegNo,
        address,
        phone,
        email,
        logo,
        isMainCompany,
        remarks
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'company_info';
  @override
  VerificationContext validateIntegrity(Insertable<CompanyInfoData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('company_code')) {
      context.handle(
          _companyCodeMeta,
          companyCode.isAcceptableOrUnknown(
              data['company_code']!, _companyCodeMeta));
    } else if (isInserting) {
      context.missing(_companyCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('country_id')) {
      context.handle(_countryIdMeta,
          countryId.isAcceptableOrUnknown(data['country_id']!, _countryIdMeta));
    }
    if (data.containsKey('tax_number')) {
      context.handle(_taxNumberMeta,
          taxNumber.isAcceptableOrUnknown(data['tax_number']!, _taxNumberMeta));
    }
    if (data.containsKey('commercial_reg_no')) {
      context.handle(
          _commercialRegNoMeta,
          commercialRegNo.isAcceptableOrUnknown(
              data['commercial_reg_no']!, _commercialRegNoMeta));
    }
    if (data.containsKey('address')) {
      context.handle(_addressMeta,
          address.isAcceptableOrUnknown(data['address']!, _addressMeta));
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('email')) {
      context.handle(
          _emailMeta, email.isAcceptableOrUnknown(data['email']!, _emailMeta));
    }
    if (data.containsKey('logo')) {
      context.handle(
          _logoMeta, logo.isAcceptableOrUnknown(data['logo']!, _logoMeta));
    }
    if (data.containsKey('is_main_company')) {
      context.handle(
          _isMainCompanyMeta,
          isMainCompany.isAcceptableOrUnknown(
              data['is_main_company']!, _isMainCompanyMeta));
    } else if (isInserting) {
      context.missing(_isMainCompanyMeta);
    }
    if (data.containsKey('remarks')) {
      context.handle(_remarksMeta,
          remarks.isAcceptableOrUnknown(data['remarks']!, _remarksMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CompanyInfoData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CompanyInfoData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      companyCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}company_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      countryId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}country_id']),
      taxNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}tax_number']),
      commercialRegNo: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}commercial_reg_no']),
      address: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address']),
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      email: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}email']),
      logo: attachedDatabase.typeMapping
          .read(DriftSqlType.blob, data['${effectivePrefix}logo']),
      isMainCompany: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_main_company'])!,
      remarks: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remarks']),
    );
  }

  @override
  CompanyInfo createAlias(String alias) {
    return CompanyInfo(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class CompanyInfoData extends DataClass implements Insertable<CompanyInfoData> {
  final int id;
  final String companyCode;
  final String nameAr;
  final String nameEn;
  final String? countryId;
  final String? taxNumber;
  final String? commercialRegNo;
  final String? address;
  final String? phone;
  final String? email;
  final Uint8List? logo;
  final bool isMainCompany;
  final String? remarks;
  const CompanyInfoData(
      {required this.id,
      required this.companyCode,
      required this.nameAr,
      required this.nameEn,
      this.countryId,
      this.taxNumber,
      this.commercialRegNo,
      this.address,
      this.phone,
      this.email,
      this.logo,
      required this.isMainCompany,
      this.remarks});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['company_code'] = Variable<String>(companyCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    if (!nullToAbsent || countryId != null) {
      map['country_id'] = Variable<String>(countryId);
    }
    if (!nullToAbsent || taxNumber != null) {
      map['tax_number'] = Variable<String>(taxNumber);
    }
    if (!nullToAbsent || commercialRegNo != null) {
      map['commercial_reg_no'] = Variable<String>(commercialRegNo);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || logo != null) {
      map['logo'] = Variable<Uint8List>(logo);
    }
    map['is_main_company'] = Variable<bool>(isMainCompany);
    if (!nullToAbsent || remarks != null) {
      map['remarks'] = Variable<String>(remarks);
    }
    return map;
  }

  CompanyInfoCompanion toCompanion(bool nullToAbsent) {
    return CompanyInfoCompanion(
      id: Value(id),
      companyCode: Value(companyCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      countryId: countryId == null && nullToAbsent
          ? const Value.absent()
          : Value(countryId),
      taxNumber: taxNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(taxNumber),
      commercialRegNo: commercialRegNo == null && nullToAbsent
          ? const Value.absent()
          : Value(commercialRegNo),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      email:
          email == null && nullToAbsent ? const Value.absent() : Value(email),
      logo: logo == null && nullToAbsent ? const Value.absent() : Value(logo),
      isMainCompany: Value(isMainCompany),
      remarks: remarks == null && nullToAbsent
          ? const Value.absent()
          : Value(remarks),
    );
  }

  factory CompanyInfoData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CompanyInfoData(
      id: serializer.fromJson<int>(json['id']),
      companyCode: serializer.fromJson<String>(json['company_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      countryId: serializer.fromJson<String?>(json['country_id']),
      taxNumber: serializer.fromJson<String?>(json['tax_number']),
      commercialRegNo: serializer.fromJson<String?>(json['commercial_reg_no']),
      address: serializer.fromJson<String?>(json['address']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      logo: serializer.fromJson<Uint8List?>(json['logo']),
      isMainCompany: serializer.fromJson<bool>(json['is_main_company']),
      remarks: serializer.fromJson<String?>(json['remarks']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'company_code': serializer.toJson<String>(companyCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'country_id': serializer.toJson<String?>(countryId),
      'tax_number': serializer.toJson<String?>(taxNumber),
      'commercial_reg_no': serializer.toJson<String?>(commercialRegNo),
      'address': serializer.toJson<String?>(address),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'logo': serializer.toJson<Uint8List?>(logo),
      'is_main_company': serializer.toJson<bool>(isMainCompany),
      'remarks': serializer.toJson<String?>(remarks),
    };
  }

  CompanyInfoData copyWith(
          {int? id,
          String? companyCode,
          String? nameAr,
          String? nameEn,
          Value<String?> countryId = const Value.absent(),
          Value<String?> taxNumber = const Value.absent(),
          Value<String?> commercialRegNo = const Value.absent(),
          Value<String?> address = const Value.absent(),
          Value<String?> phone = const Value.absent(),
          Value<String?> email = const Value.absent(),
          Value<Uint8List?> logo = const Value.absent(),
          bool? isMainCompany,
          Value<String?> remarks = const Value.absent()}) =>
      CompanyInfoData(
        id: id ?? this.id,
        companyCode: companyCode ?? this.companyCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        countryId: countryId.present ? countryId.value : this.countryId,
        taxNumber: taxNumber.present ? taxNumber.value : this.taxNumber,
        commercialRegNo: commercialRegNo.present
            ? commercialRegNo.value
            : this.commercialRegNo,
        address: address.present ? address.value : this.address,
        phone: phone.present ? phone.value : this.phone,
        email: email.present ? email.value : this.email,
        logo: logo.present ? logo.value : this.logo,
        isMainCompany: isMainCompany ?? this.isMainCompany,
        remarks: remarks.present ? remarks.value : this.remarks,
      );
  CompanyInfoData copyWithCompanion(CompanyInfoCompanion data) {
    return CompanyInfoData(
      id: data.id.present ? data.id.value : this.id,
      companyCode:
          data.companyCode.present ? data.companyCode.value : this.companyCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      countryId: data.countryId.present ? data.countryId.value : this.countryId,
      taxNumber: data.taxNumber.present ? data.taxNumber.value : this.taxNumber,
      commercialRegNo: data.commercialRegNo.present
          ? data.commercialRegNo.value
          : this.commercialRegNo,
      address: data.address.present ? data.address.value : this.address,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      logo: data.logo.present ? data.logo.value : this.logo,
      isMainCompany: data.isMainCompany.present
          ? data.isMainCompany.value
          : this.isMainCompany,
      remarks: data.remarks.present ? data.remarks.value : this.remarks,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CompanyInfoData(')
          ..write('id: $id, ')
          ..write('companyCode: $companyCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('countryId: $countryId, ')
          ..write('taxNumber: $taxNumber, ')
          ..write('commercialRegNo: $commercialRegNo, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('logo: $logo, ')
          ..write('isMainCompany: $isMainCompany, ')
          ..write('remarks: $remarks')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      companyCode,
      nameAr,
      nameEn,
      countryId,
      taxNumber,
      commercialRegNo,
      address,
      phone,
      email,
      $driftBlobEquality.hash(logo),
      isMainCompany,
      remarks);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CompanyInfoData &&
          other.id == this.id &&
          other.companyCode == this.companyCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.countryId == this.countryId &&
          other.taxNumber == this.taxNumber &&
          other.commercialRegNo == this.commercialRegNo &&
          other.address == this.address &&
          other.phone == this.phone &&
          other.email == this.email &&
          $driftBlobEquality.equals(other.logo, this.logo) &&
          other.isMainCompany == this.isMainCompany &&
          other.remarks == this.remarks);
}

class CompanyInfoCompanion extends UpdateCompanion<CompanyInfoData> {
  final Value<int> id;
  final Value<String> companyCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String?> countryId;
  final Value<String?> taxNumber;
  final Value<String?> commercialRegNo;
  final Value<String?> address;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<Uint8List?> logo;
  final Value<bool> isMainCompany;
  final Value<String?> remarks;
  const CompanyInfoCompanion({
    this.id = const Value.absent(),
    this.companyCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.countryId = const Value.absent(),
    this.taxNumber = const Value.absent(),
    this.commercialRegNo = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.logo = const Value.absent(),
    this.isMainCompany = const Value.absent(),
    this.remarks = const Value.absent(),
  });
  CompanyInfoCompanion.insert({
    this.id = const Value.absent(),
    required String companyCode,
    required String nameAr,
    required String nameEn,
    this.countryId = const Value.absent(),
    this.taxNumber = const Value.absent(),
    this.commercialRegNo = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.logo = const Value.absent(),
    required bool isMainCompany,
    this.remarks = const Value.absent(),
  })  : companyCode = Value(companyCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        isMainCompany = Value(isMainCompany);
  static Insertable<CompanyInfoData> custom({
    Expression<int>? id,
    Expression<String>? companyCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? countryId,
    Expression<String>? taxNumber,
    Expression<String>? commercialRegNo,
    Expression<String>? address,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<Uint8List>? logo,
    Expression<bool>? isMainCompany,
    Expression<String>? remarks,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (companyCode != null) 'company_code': companyCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (countryId != null) 'country_id': countryId,
      if (taxNumber != null) 'tax_number': taxNumber,
      if (commercialRegNo != null) 'commercial_reg_no': commercialRegNo,
      if (address != null) 'address': address,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (logo != null) 'logo': logo,
      if (isMainCompany != null) 'is_main_company': isMainCompany,
      if (remarks != null) 'remarks': remarks,
    });
  }

  CompanyInfoCompanion copyWith(
      {Value<int>? id,
      Value<String>? companyCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String?>? countryId,
      Value<String?>? taxNumber,
      Value<String?>? commercialRegNo,
      Value<String?>? address,
      Value<String?>? phone,
      Value<String?>? email,
      Value<Uint8List?>? logo,
      Value<bool>? isMainCompany,
      Value<String?>? remarks}) {
    return CompanyInfoCompanion(
      id: id ?? this.id,
      companyCode: companyCode ?? this.companyCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      countryId: countryId ?? this.countryId,
      taxNumber: taxNumber ?? this.taxNumber,
      commercialRegNo: commercialRegNo ?? this.commercialRegNo,
      address: address ?? this.address,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      logo: logo ?? this.logo,
      isMainCompany: isMainCompany ?? this.isMainCompany,
      remarks: remarks ?? this.remarks,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (companyCode.present) {
      map['company_code'] = Variable<String>(companyCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (countryId.present) {
      map['country_id'] = Variable<String>(countryId.value);
    }
    if (taxNumber.present) {
      map['tax_number'] = Variable<String>(taxNumber.value);
    }
    if (commercialRegNo.present) {
      map['commercial_reg_no'] = Variable<String>(commercialRegNo.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (logo.present) {
      map['logo'] = Variable<Uint8List>(logo.value);
    }
    if (isMainCompany.present) {
      map['is_main_company'] = Variable<bool>(isMainCompany.value);
    }
    if (remarks.present) {
      map['remarks'] = Variable<String>(remarks.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CompanyInfoCompanion(')
          ..write('id: $id, ')
          ..write('companyCode: $companyCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('countryId: $countryId, ')
          ..write('taxNumber: $taxNumber, ')
          ..write('commercialRegNo: $commercialRegNo, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('logo: $logo, ')
          ..write('isMainCompany: $isMainCompany, ')
          ..write('remarks: $remarks')
          ..write(')'))
        .toString();
  }
}

class BranchGroups extends Table with TableInfo<BranchGroups, BranchGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  BranchGroups(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  @override
  List<GeneratedColumn> get $columns => [id, nameAr, nameEn, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'branch_groups';
  @override
  VerificationContext validateIntegrity(Insertable<BranchGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BranchGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BranchGroup(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  BranchGroups createAlias(String alias) {
    return BranchGroups(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class BranchGroup extends DataClass implements Insertable<BranchGroup> {
  final int id;
  final String nameAr;
  final String nameEn;
  final bool isActive;
  const BranchGroup(
      {required this.id,
      required this.nameAr,
      required this.nameEn,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  BranchGroupsCompanion toCompanion(bool nullToAbsent) {
    return BranchGroupsCompanion(
      id: Value(id),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      isActive: Value(isActive),
    );
  }

  factory BranchGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BranchGroup(
      id: serializer.fromJson<int>(json['id']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  BranchGroup copyWith(
          {int? id, String? nameAr, String? nameEn, bool? isActive}) =>
      BranchGroup(
        id: id ?? this.id,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        isActive: isActive ?? this.isActive,
      );
  BranchGroup copyWithCompanion(BranchGroupsCompanion data) {
    return BranchGroup(
      id: data.id.present ? data.id.value : this.id,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BranchGroup(')
          ..write('id: $id, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, nameAr, nameEn, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BranchGroup &&
          other.id == this.id &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.isActive == this.isActive);
}

class BranchGroupsCompanion extends UpdateCompanion<BranchGroup> {
  final Value<int> id;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<bool> isActive;
  const BranchGroupsCompanion({
    this.id = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  BranchGroupsCompanion.insert({
    this.id = const Value.absent(),
    required String nameAr,
    required String nameEn,
    this.isActive = const Value.absent(),
  })  : nameAr = Value(nameAr),
        nameEn = Value(nameEn);
  static Insertable<BranchGroup> custom({
    Expression<int>? id,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (isActive != null) 'is_active': isActive,
    });
  }

  BranchGroupsCompanion copyWith(
      {Value<int>? id,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<bool>? isActive}) {
    return BranchGroupsCompanion(
      id: id ?? this.id,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BranchGroupsCompanion(')
          ..write('id: $id, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class Branches extends Table with TableInfo<Branches, Branche> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Branches(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _branchCodeMeta =
      const VerificationMeta('branchCode');
  late final GeneratedColumn<String> branchCode = GeneratedColumn<String>(
      'branch_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _companyIdMeta =
      const VerificationMeta('companyId');
  late final GeneratedColumn<int> companyId = GeneratedColumn<int>(
      'company_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES company_info(id)');
  static const VerificationMeta _branchGroupIdMeta =
      const VerificationMeta('branchGroupId');
  late final GeneratedColumn<int> branchGroupId = GeneratedColumn<int>(
      'branch_group_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'REFERENCES branch_groups(id)');
  static const VerificationMeta _addressMeta =
      const VerificationMeta('address');
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
      'address', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
      'phone', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _defaultWarehouseIdMeta =
      const VerificationMeta('defaultWarehouseId');
  late final GeneratedColumn<String> defaultWarehouseId =
      GeneratedColumn<String>('default_warehouse_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: '');
  static const VerificationMeta _isMainBranchMeta =
      const VerificationMeta('isMainBranch');
  late final GeneratedColumn<bool> isMainBranch = GeneratedColumn<bool>(
      'is_main_branch', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _branchStatusMeta =
      const VerificationMeta('branchStatus');
  late final GeneratedColumn<bool> branchStatus = GeneratedColumn<bool>(
      'branch_status', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _logoMeta = const VerificationMeta('logo');
  late final GeneratedColumn<Uint8List> logo = GeneratedColumn<Uint8List>(
      'logo', aliasedName, true,
      type: DriftSqlType.blob,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _remarksMeta =
      const VerificationMeta('remarks');
  late final GeneratedColumn<String> remarks = GeneratedColumn<String>(
      'remarks', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        branchCode,
        nameAr,
        nameEn,
        companyId,
        branchGroupId,
        address,
        phone,
        defaultWarehouseId,
        isMainBranch,
        branchStatus,
        logo,
        remarks
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'branches';
  @override
  VerificationContext validateIntegrity(Insertable<Branche> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('branch_code')) {
      context.handle(
          _branchCodeMeta,
          branchCode.isAcceptableOrUnknown(
              data['branch_code']!, _branchCodeMeta));
    } else if (isInserting) {
      context.missing(_branchCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('company_id')) {
      context.handle(_companyIdMeta,
          companyId.isAcceptableOrUnknown(data['company_id']!, _companyIdMeta));
    } else if (isInserting) {
      context.missing(_companyIdMeta);
    }
    if (data.containsKey('branch_group_id')) {
      context.handle(
          _branchGroupIdMeta,
          branchGroupId.isAcceptableOrUnknown(
              data['branch_group_id']!, _branchGroupIdMeta));
    }
    if (data.containsKey('address')) {
      context.handle(_addressMeta,
          address.isAcceptableOrUnknown(data['address']!, _addressMeta));
    }
    if (data.containsKey('phone')) {
      context.handle(
          _phoneMeta, phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta));
    }
    if (data.containsKey('default_warehouse_id')) {
      context.handle(
          _defaultWarehouseIdMeta,
          defaultWarehouseId.isAcceptableOrUnknown(
              data['default_warehouse_id']!, _defaultWarehouseIdMeta));
    }
    if (data.containsKey('is_main_branch')) {
      context.handle(
          _isMainBranchMeta,
          isMainBranch.isAcceptableOrUnknown(
              data['is_main_branch']!, _isMainBranchMeta));
    }
    if (data.containsKey('branch_status')) {
      context.handle(
          _branchStatusMeta,
          branchStatus.isAcceptableOrUnknown(
              data['branch_status']!, _branchStatusMeta));
    }
    if (data.containsKey('logo')) {
      context.handle(
          _logoMeta, logo.isAcceptableOrUnknown(data['logo']!, _logoMeta));
    }
    if (data.containsKey('remarks')) {
      context.handle(_remarksMeta,
          remarks.isAcceptableOrUnknown(data['remarks']!, _remarksMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Branche map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Branche(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      branchCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}branch_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      companyId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}company_id'])!,
      branchGroupId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}branch_group_id']),
      address: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}address']),
      phone: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}phone']),
      defaultWarehouseId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}default_warehouse_id']),
      isMainBranch: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_main_branch'])!,
      branchStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}branch_status'])!,
      logo: attachedDatabase.typeMapping
          .read(DriftSqlType.blob, data['${effectivePrefix}logo']),
      remarks: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remarks']),
    );
  }

  @override
  Branches createAlias(String alias) {
    return Branches(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Branche extends DataClass implements Insertable<Branche> {
  final int id;
  final String branchCode;
  final String nameAr;
  final String nameEn;
  final int companyId;
  final int? branchGroupId;
  final String? address;
  final String? phone;
  final String? defaultWarehouseId;
  final bool isMainBranch;
  final bool branchStatus;
  final Uint8List? logo;
  final String? remarks;
  const Branche(
      {required this.id,
      required this.branchCode,
      required this.nameAr,
      required this.nameEn,
      required this.companyId,
      this.branchGroupId,
      this.address,
      this.phone,
      this.defaultWarehouseId,
      required this.isMainBranch,
      required this.branchStatus,
      this.logo,
      this.remarks});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['branch_code'] = Variable<String>(branchCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['company_id'] = Variable<int>(companyId);
    if (!nullToAbsent || branchGroupId != null) {
      map['branch_group_id'] = Variable<int>(branchGroupId);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || defaultWarehouseId != null) {
      map['default_warehouse_id'] = Variable<String>(defaultWarehouseId);
    }
    map['is_main_branch'] = Variable<bool>(isMainBranch);
    map['branch_status'] = Variable<bool>(branchStatus);
    if (!nullToAbsent || logo != null) {
      map['logo'] = Variable<Uint8List>(logo);
    }
    if (!nullToAbsent || remarks != null) {
      map['remarks'] = Variable<String>(remarks);
    }
    return map;
  }

  BranchesCompanion toCompanion(bool nullToAbsent) {
    return BranchesCompanion(
      id: Value(id),
      branchCode: Value(branchCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      companyId: Value(companyId),
      branchGroupId: branchGroupId == null && nullToAbsent
          ? const Value.absent()
          : Value(branchGroupId),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      phone:
          phone == null && nullToAbsent ? const Value.absent() : Value(phone),
      defaultWarehouseId: defaultWarehouseId == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultWarehouseId),
      isMainBranch: Value(isMainBranch),
      branchStatus: Value(branchStatus),
      logo: logo == null && nullToAbsent ? const Value.absent() : Value(logo),
      remarks: remarks == null && nullToAbsent
          ? const Value.absent()
          : Value(remarks),
    );
  }

  factory Branche.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Branche(
      id: serializer.fromJson<int>(json['id']),
      branchCode: serializer.fromJson<String>(json['branch_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      companyId: serializer.fromJson<int>(json['company_id']),
      branchGroupId: serializer.fromJson<int?>(json['branch_group_id']),
      address: serializer.fromJson<String?>(json['address']),
      phone: serializer.fromJson<String?>(json['phone']),
      defaultWarehouseId:
          serializer.fromJson<String?>(json['default_warehouse_id']),
      isMainBranch: serializer.fromJson<bool>(json['is_main_branch']),
      branchStatus: serializer.fromJson<bool>(json['branch_status']),
      logo: serializer.fromJson<Uint8List?>(json['logo']),
      remarks: serializer.fromJson<String?>(json['remarks']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'branch_code': serializer.toJson<String>(branchCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'company_id': serializer.toJson<int>(companyId),
      'branch_group_id': serializer.toJson<int?>(branchGroupId),
      'address': serializer.toJson<String?>(address),
      'phone': serializer.toJson<String?>(phone),
      'default_warehouse_id': serializer.toJson<String?>(defaultWarehouseId),
      'is_main_branch': serializer.toJson<bool>(isMainBranch),
      'branch_status': serializer.toJson<bool>(branchStatus),
      'logo': serializer.toJson<Uint8List?>(logo),
      'remarks': serializer.toJson<String?>(remarks),
    };
  }

  Branche copyWith(
          {int? id,
          String? branchCode,
          String? nameAr,
          String? nameEn,
          int? companyId,
          Value<int?> branchGroupId = const Value.absent(),
          Value<String?> address = const Value.absent(),
          Value<String?> phone = const Value.absent(),
          Value<String?> defaultWarehouseId = const Value.absent(),
          bool? isMainBranch,
          bool? branchStatus,
          Value<Uint8List?> logo = const Value.absent(),
          Value<String?> remarks = const Value.absent()}) =>
      Branche(
        id: id ?? this.id,
        branchCode: branchCode ?? this.branchCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        companyId: companyId ?? this.companyId,
        branchGroupId:
            branchGroupId.present ? branchGroupId.value : this.branchGroupId,
        address: address.present ? address.value : this.address,
        phone: phone.present ? phone.value : this.phone,
        defaultWarehouseId: defaultWarehouseId.present
            ? defaultWarehouseId.value
            : this.defaultWarehouseId,
        isMainBranch: isMainBranch ?? this.isMainBranch,
        branchStatus: branchStatus ?? this.branchStatus,
        logo: logo.present ? logo.value : this.logo,
        remarks: remarks.present ? remarks.value : this.remarks,
      );
  Branche copyWithCompanion(BranchesCompanion data) {
    return Branche(
      id: data.id.present ? data.id.value : this.id,
      branchCode:
          data.branchCode.present ? data.branchCode.value : this.branchCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      companyId: data.companyId.present ? data.companyId.value : this.companyId,
      branchGroupId: data.branchGroupId.present
          ? data.branchGroupId.value
          : this.branchGroupId,
      address: data.address.present ? data.address.value : this.address,
      phone: data.phone.present ? data.phone.value : this.phone,
      defaultWarehouseId: data.defaultWarehouseId.present
          ? data.defaultWarehouseId.value
          : this.defaultWarehouseId,
      isMainBranch: data.isMainBranch.present
          ? data.isMainBranch.value
          : this.isMainBranch,
      branchStatus: data.branchStatus.present
          ? data.branchStatus.value
          : this.branchStatus,
      logo: data.logo.present ? data.logo.value : this.logo,
      remarks: data.remarks.present ? data.remarks.value : this.remarks,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Branche(')
          ..write('id: $id, ')
          ..write('branchCode: $branchCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('companyId: $companyId, ')
          ..write('branchGroupId: $branchGroupId, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('defaultWarehouseId: $defaultWarehouseId, ')
          ..write('isMainBranch: $isMainBranch, ')
          ..write('branchStatus: $branchStatus, ')
          ..write('logo: $logo, ')
          ..write('remarks: $remarks')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      branchCode,
      nameAr,
      nameEn,
      companyId,
      branchGroupId,
      address,
      phone,
      defaultWarehouseId,
      isMainBranch,
      branchStatus,
      $driftBlobEquality.hash(logo),
      remarks);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Branche &&
          other.id == this.id &&
          other.branchCode == this.branchCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.companyId == this.companyId &&
          other.branchGroupId == this.branchGroupId &&
          other.address == this.address &&
          other.phone == this.phone &&
          other.defaultWarehouseId == this.defaultWarehouseId &&
          other.isMainBranch == this.isMainBranch &&
          other.branchStatus == this.branchStatus &&
          $driftBlobEquality.equals(other.logo, this.logo) &&
          other.remarks == this.remarks);
}

class BranchesCompanion extends UpdateCompanion<Branche> {
  final Value<int> id;
  final Value<String> branchCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<int> companyId;
  final Value<int?> branchGroupId;
  final Value<String?> address;
  final Value<String?> phone;
  final Value<String?> defaultWarehouseId;
  final Value<bool> isMainBranch;
  final Value<bool> branchStatus;
  final Value<Uint8List?> logo;
  final Value<String?> remarks;
  const BranchesCompanion({
    this.id = const Value.absent(),
    this.branchCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.companyId = const Value.absent(),
    this.branchGroupId = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.defaultWarehouseId = const Value.absent(),
    this.isMainBranch = const Value.absent(),
    this.branchStatus = const Value.absent(),
    this.logo = const Value.absent(),
    this.remarks = const Value.absent(),
  });
  BranchesCompanion.insert({
    this.id = const Value.absent(),
    required String branchCode,
    required String nameAr,
    required String nameEn,
    required int companyId,
    this.branchGroupId = const Value.absent(),
    this.address = const Value.absent(),
    this.phone = const Value.absent(),
    this.defaultWarehouseId = const Value.absent(),
    this.isMainBranch = const Value.absent(),
    this.branchStatus = const Value.absent(),
    this.logo = const Value.absent(),
    this.remarks = const Value.absent(),
  })  : branchCode = Value(branchCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        companyId = Value(companyId);
  static Insertable<Branche> custom({
    Expression<int>? id,
    Expression<String>? branchCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<int>? companyId,
    Expression<int>? branchGroupId,
    Expression<String>? address,
    Expression<String>? phone,
    Expression<String>? defaultWarehouseId,
    Expression<bool>? isMainBranch,
    Expression<bool>? branchStatus,
    Expression<Uint8List>? logo,
    Expression<String>? remarks,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (branchCode != null) 'branch_code': branchCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (companyId != null) 'company_id': companyId,
      if (branchGroupId != null) 'branch_group_id': branchGroupId,
      if (address != null) 'address': address,
      if (phone != null) 'phone': phone,
      if (defaultWarehouseId != null)
        'default_warehouse_id': defaultWarehouseId,
      if (isMainBranch != null) 'is_main_branch': isMainBranch,
      if (branchStatus != null) 'branch_status': branchStatus,
      if (logo != null) 'logo': logo,
      if (remarks != null) 'remarks': remarks,
    });
  }

  BranchesCompanion copyWith(
      {Value<int>? id,
      Value<String>? branchCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<int>? companyId,
      Value<int?>? branchGroupId,
      Value<String?>? address,
      Value<String?>? phone,
      Value<String?>? defaultWarehouseId,
      Value<bool>? isMainBranch,
      Value<bool>? branchStatus,
      Value<Uint8List?>? logo,
      Value<String?>? remarks}) {
    return BranchesCompanion(
      id: id ?? this.id,
      branchCode: branchCode ?? this.branchCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      companyId: companyId ?? this.companyId,
      branchGroupId: branchGroupId ?? this.branchGroupId,
      address: address ?? this.address,
      phone: phone ?? this.phone,
      defaultWarehouseId: defaultWarehouseId ?? this.defaultWarehouseId,
      isMainBranch: isMainBranch ?? this.isMainBranch,
      branchStatus: branchStatus ?? this.branchStatus,
      logo: logo ?? this.logo,
      remarks: remarks ?? this.remarks,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (branchCode.present) {
      map['branch_code'] = Variable<String>(branchCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (companyId.present) {
      map['company_id'] = Variable<int>(companyId.value);
    }
    if (branchGroupId.present) {
      map['branch_group_id'] = Variable<int>(branchGroupId.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (defaultWarehouseId.present) {
      map['default_warehouse_id'] = Variable<String>(defaultWarehouseId.value);
    }
    if (isMainBranch.present) {
      map['is_main_branch'] = Variable<bool>(isMainBranch.value);
    }
    if (branchStatus.present) {
      map['branch_status'] = Variable<bool>(branchStatus.value);
    }
    if (logo.present) {
      map['logo'] = Variable<Uint8List>(logo.value);
    }
    if (remarks.present) {
      map['remarks'] = Variable<String>(remarks.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BranchesCompanion(')
          ..write('id: $id, ')
          ..write('branchCode: $branchCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('companyId: $companyId, ')
          ..write('branchGroupId: $branchGroupId, ')
          ..write('address: $address, ')
          ..write('phone: $phone, ')
          ..write('defaultWarehouseId: $defaultWarehouseId, ')
          ..write('isMainBranch: $isMainBranch, ')
          ..write('branchStatus: $branchStatus, ')
          ..write('logo: $logo, ')
          ..write('remarks: $remarks')
          ..write(')'))
        .toString();
  }
}

class Warehouses extends Table with TableInfo<Warehouses, Warehouse> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Warehouses(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _warehouseCodeMeta =
      const VerificationMeta('warehouseCode');
  late final GeneratedColumn<String> warehouseCode = GeneratedColumn<String>(
      'warehouse_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _branchIdMeta =
      const VerificationMeta('branchId');
  late final GeneratedColumn<int> branchId = GeneratedColumn<int>(
      'branch_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES branches(id)');
  static const VerificationMeta _inventoryAccountIdMeta =
      const VerificationMeta('inventoryAccountId');
  late final GeneratedColumn<String> inventoryAccountId =
      GeneratedColumn<String>('inventory_account_id', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints:
              'NOT NULL REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        warehouseCode,
        nameAr,
        nameEn,
        branchId,
        inventoryAccountId,
        isActive,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'warehouses';
  @override
  VerificationContext validateIntegrity(Insertable<Warehouse> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('warehouse_code')) {
      context.handle(
          _warehouseCodeMeta,
          warehouseCode.isAcceptableOrUnknown(
              data['warehouse_code']!, _warehouseCodeMeta));
    } else if (isInserting) {
      context.missing(_warehouseCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('branch_id')) {
      context.handle(_branchIdMeta,
          branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta));
    } else if (isInserting) {
      context.missing(_branchIdMeta);
    }
    if (data.containsKey('inventory_account_id')) {
      context.handle(
          _inventoryAccountIdMeta,
          inventoryAccountId.isAcceptableOrUnknown(
              data['inventory_account_id']!, _inventoryAccountIdMeta));
    } else if (isInserting) {
      context.missing(_inventoryAccountIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Warehouse map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Warehouse(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      warehouseCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}warehouse_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      branchId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}branch_id'])!,
      inventoryAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}inventory_account_id'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  Warehouses createAlias(String alias) {
    return Warehouses(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Warehouse extends DataClass implements Insertable<Warehouse> {
  final int id;
  final String warehouseCode;
  final String nameAr;
  final String nameEn;
  final int branchId;
  final String inventoryAccountId;
  final bool isActive;
  final int createdAt;
  final int updatedAt;
  const Warehouse(
      {required this.id,
      required this.warehouseCode,
      required this.nameAr,
      required this.nameEn,
      required this.branchId,
      required this.inventoryAccountId,
      required this.isActive,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['warehouse_code'] = Variable<String>(warehouseCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['branch_id'] = Variable<int>(branchId);
    map['inventory_account_id'] = Variable<String>(inventoryAccountId);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  WarehousesCompanion toCompanion(bool nullToAbsent) {
    return WarehousesCompanion(
      id: Value(id),
      warehouseCode: Value(warehouseCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      branchId: Value(branchId),
      inventoryAccountId: Value(inventoryAccountId),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Warehouse.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Warehouse(
      id: serializer.fromJson<int>(json['id']),
      warehouseCode: serializer.fromJson<String>(json['warehouse_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      branchId: serializer.fromJson<int>(json['branch_id']),
      inventoryAccountId:
          serializer.fromJson<String>(json['inventory_account_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'warehouse_code': serializer.toJson<String>(warehouseCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'branch_id': serializer.toJson<int>(branchId),
      'inventory_account_id': serializer.toJson<String>(inventoryAccountId),
      'is_active': serializer.toJson<bool>(isActive),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  Warehouse copyWith(
          {int? id,
          String? warehouseCode,
          String? nameAr,
          String? nameEn,
          int? branchId,
          String? inventoryAccountId,
          bool? isActive,
          int? createdAt,
          int? updatedAt}) =>
      Warehouse(
        id: id ?? this.id,
        warehouseCode: warehouseCode ?? this.warehouseCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        branchId: branchId ?? this.branchId,
        inventoryAccountId: inventoryAccountId ?? this.inventoryAccountId,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  Warehouse copyWithCompanion(WarehousesCompanion data) {
    return Warehouse(
      id: data.id.present ? data.id.value : this.id,
      warehouseCode: data.warehouseCode.present
          ? data.warehouseCode.value
          : this.warehouseCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      inventoryAccountId: data.inventoryAccountId.present
          ? data.inventoryAccountId.value
          : this.inventoryAccountId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Warehouse(')
          ..write('id: $id, ')
          ..write('warehouseCode: $warehouseCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('branchId: $branchId, ')
          ..write('inventoryAccountId: $inventoryAccountId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, warehouseCode, nameAr, nameEn, branchId,
      inventoryAccountId, isActive, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Warehouse &&
          other.id == this.id &&
          other.warehouseCode == this.warehouseCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.branchId == this.branchId &&
          other.inventoryAccountId == this.inventoryAccountId &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class WarehousesCompanion extends UpdateCompanion<Warehouse> {
  final Value<int> id;
  final Value<String> warehouseCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<int> branchId;
  final Value<String> inventoryAccountId;
  final Value<bool> isActive;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const WarehousesCompanion({
    this.id = const Value.absent(),
    this.warehouseCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.branchId = const Value.absent(),
    this.inventoryAccountId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  WarehousesCompanion.insert({
    this.id = const Value.absent(),
    required String warehouseCode,
    required String nameAr,
    required String nameEn,
    required int branchId,
    required String inventoryAccountId,
    this.isActive = const Value.absent(),
    required int createdAt,
    required int updatedAt,
  })  : warehouseCode = Value(warehouseCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        branchId = Value(branchId),
        inventoryAccountId = Value(inventoryAccountId),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<Warehouse> custom({
    Expression<int>? id,
    Expression<String>? warehouseCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<int>? branchId,
    Expression<String>? inventoryAccountId,
    Expression<bool>? isActive,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (warehouseCode != null) 'warehouse_code': warehouseCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (branchId != null) 'branch_id': branchId,
      if (inventoryAccountId != null)
        'inventory_account_id': inventoryAccountId,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  WarehousesCompanion copyWith(
      {Value<int>? id,
      Value<String>? warehouseCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<int>? branchId,
      Value<String>? inventoryAccountId,
      Value<bool>? isActive,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return WarehousesCompanion(
      id: id ?? this.id,
      warehouseCode: warehouseCode ?? this.warehouseCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      branchId: branchId ?? this.branchId,
      inventoryAccountId: inventoryAccountId ?? this.inventoryAccountId,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (warehouseCode.present) {
      map['warehouse_code'] = Variable<String>(warehouseCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<int>(branchId.value);
    }
    if (inventoryAccountId.present) {
      map['inventory_account_id'] = Variable<String>(inventoryAccountId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WarehousesCompanion(')
          ..write('id: $id, ')
          ..write('warehouseCode: $warehouseCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('branchId: $branchId, ')
          ..write('inventoryAccountId: $inventoryAccountId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class ItemGroups extends Table with TableInfo<ItemGroups, ItemGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ItemGroups(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _groupCodeMeta =
      const VerificationMeta('groupCode');
  late final GeneratedColumn<String> groupCode = GeneratedColumn<String>(
      'group_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _parentGroupIdMeta =
      const VerificationMeta('parentGroupId');
  late final GeneratedColumn<int> parentGroupId = GeneratedColumn<int>(
      'parent_group_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'REFERENCES item_groups(id)');
  static const VerificationMeta _inventoryAccountIdMeta =
      const VerificationMeta('inventoryAccountId');
  late final GeneratedColumn<String> inventoryAccountId =
      GeneratedColumn<String>('inventory_account_id', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints:
              'NOT NULL REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _salesRevenueAccountIdMeta =
      const VerificationMeta('salesRevenueAccountId');
  late final GeneratedColumn<String> salesRevenueAccountId =
      GeneratedColumn<String>('sales_revenue_account_id', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints:
              'NOT NULL REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _cogsAccountIdMeta =
      const VerificationMeta('cogsAccountId');
  late final GeneratedColumn<String> cogsAccountId = GeneratedColumn<String>(
      'cogs_account_id', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        groupCode,
        nameAr,
        nameEn,
        parentGroupId,
        inventoryAccountId,
        salesRevenueAccountId,
        cogsAccountId,
        isActive,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_groups';
  @override
  VerificationContext validateIntegrity(Insertable<ItemGroup> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('group_code')) {
      context.handle(_groupCodeMeta,
          groupCode.isAcceptableOrUnknown(data['group_code']!, _groupCodeMeta));
    } else if (isInserting) {
      context.missing(_groupCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('parent_group_id')) {
      context.handle(
          _parentGroupIdMeta,
          parentGroupId.isAcceptableOrUnknown(
              data['parent_group_id']!, _parentGroupIdMeta));
    }
    if (data.containsKey('inventory_account_id')) {
      context.handle(
          _inventoryAccountIdMeta,
          inventoryAccountId.isAcceptableOrUnknown(
              data['inventory_account_id']!, _inventoryAccountIdMeta));
    } else if (isInserting) {
      context.missing(_inventoryAccountIdMeta);
    }
    if (data.containsKey('sales_revenue_account_id')) {
      context.handle(
          _salesRevenueAccountIdMeta,
          salesRevenueAccountId.isAcceptableOrUnknown(
              data['sales_revenue_account_id']!, _salesRevenueAccountIdMeta));
    } else if (isInserting) {
      context.missing(_salesRevenueAccountIdMeta);
    }
    if (data.containsKey('cogs_account_id')) {
      context.handle(
          _cogsAccountIdMeta,
          cogsAccountId.isAcceptableOrUnknown(
              data['cogs_account_id']!, _cogsAccountIdMeta));
    } else if (isInserting) {
      context.missing(_cogsAccountIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemGroup(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      groupCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      parentGroupId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}parent_group_id']),
      inventoryAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}inventory_account_id'])!,
      salesRevenueAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}sales_revenue_account_id'])!,
      cogsAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}cogs_account_id'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  ItemGroups createAlias(String alias) {
    return ItemGroups(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class ItemGroup extends DataClass implements Insertable<ItemGroup> {
  final int id;
  final String groupCode;
  final String nameAr;
  final String nameEn;
  final int? parentGroupId;
  final String inventoryAccountId;
  final String salesRevenueAccountId;
  final String cogsAccountId;
  final bool isActive;
  final int createdAt;
  final int updatedAt;
  const ItemGroup(
      {required this.id,
      required this.groupCode,
      required this.nameAr,
      required this.nameEn,
      this.parentGroupId,
      required this.inventoryAccountId,
      required this.salesRevenueAccountId,
      required this.cogsAccountId,
      required this.isActive,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['group_code'] = Variable<String>(groupCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    if (!nullToAbsent || parentGroupId != null) {
      map['parent_group_id'] = Variable<int>(parentGroupId);
    }
    map['inventory_account_id'] = Variable<String>(inventoryAccountId);
    map['sales_revenue_account_id'] = Variable<String>(salesRevenueAccountId);
    map['cogs_account_id'] = Variable<String>(cogsAccountId);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ItemGroupsCompanion toCompanion(bool nullToAbsent) {
    return ItemGroupsCompanion(
      id: Value(id),
      groupCode: Value(groupCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      parentGroupId: parentGroupId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentGroupId),
      inventoryAccountId: Value(inventoryAccountId),
      salesRevenueAccountId: Value(salesRevenueAccountId),
      cogsAccountId: Value(cogsAccountId),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ItemGroup.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemGroup(
      id: serializer.fromJson<int>(json['id']),
      groupCode: serializer.fromJson<String>(json['group_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      parentGroupId: serializer.fromJson<int?>(json['parent_group_id']),
      inventoryAccountId:
          serializer.fromJson<String>(json['inventory_account_id']),
      salesRevenueAccountId:
          serializer.fromJson<String>(json['sales_revenue_account_id']),
      cogsAccountId: serializer.fromJson<String>(json['cogs_account_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'group_code': serializer.toJson<String>(groupCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'parent_group_id': serializer.toJson<int?>(parentGroupId),
      'inventory_account_id': serializer.toJson<String>(inventoryAccountId),
      'sales_revenue_account_id':
          serializer.toJson<String>(salesRevenueAccountId),
      'cogs_account_id': serializer.toJson<String>(cogsAccountId),
      'is_active': serializer.toJson<bool>(isActive),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  ItemGroup copyWith(
          {int? id,
          String? groupCode,
          String? nameAr,
          String? nameEn,
          Value<int?> parentGroupId = const Value.absent(),
          String? inventoryAccountId,
          String? salesRevenueAccountId,
          String? cogsAccountId,
          bool? isActive,
          int? createdAt,
          int? updatedAt}) =>
      ItemGroup(
        id: id ?? this.id,
        groupCode: groupCode ?? this.groupCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        parentGroupId:
            parentGroupId.present ? parentGroupId.value : this.parentGroupId,
        inventoryAccountId: inventoryAccountId ?? this.inventoryAccountId,
        salesRevenueAccountId:
            salesRevenueAccountId ?? this.salesRevenueAccountId,
        cogsAccountId: cogsAccountId ?? this.cogsAccountId,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ItemGroup copyWithCompanion(ItemGroupsCompanion data) {
    return ItemGroup(
      id: data.id.present ? data.id.value : this.id,
      groupCode: data.groupCode.present ? data.groupCode.value : this.groupCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      parentGroupId: data.parentGroupId.present
          ? data.parentGroupId.value
          : this.parentGroupId,
      inventoryAccountId: data.inventoryAccountId.present
          ? data.inventoryAccountId.value
          : this.inventoryAccountId,
      salesRevenueAccountId: data.salesRevenueAccountId.present
          ? data.salesRevenueAccountId.value
          : this.salesRevenueAccountId,
      cogsAccountId: data.cogsAccountId.present
          ? data.cogsAccountId.value
          : this.cogsAccountId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ItemGroup(')
          ..write('id: $id, ')
          ..write('groupCode: $groupCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('parentGroupId: $parentGroupId, ')
          ..write('inventoryAccountId: $inventoryAccountId, ')
          ..write('salesRevenueAccountId: $salesRevenueAccountId, ')
          ..write('cogsAccountId: $cogsAccountId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      groupCode,
      nameAr,
      nameEn,
      parentGroupId,
      inventoryAccountId,
      salesRevenueAccountId,
      cogsAccountId,
      isActive,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemGroup &&
          other.id == this.id &&
          other.groupCode == this.groupCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.parentGroupId == this.parentGroupId &&
          other.inventoryAccountId == this.inventoryAccountId &&
          other.salesRevenueAccountId == this.salesRevenueAccountId &&
          other.cogsAccountId == this.cogsAccountId &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ItemGroupsCompanion extends UpdateCompanion<ItemGroup> {
  final Value<int> id;
  final Value<String> groupCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<int?> parentGroupId;
  final Value<String> inventoryAccountId;
  final Value<String> salesRevenueAccountId;
  final Value<String> cogsAccountId;
  final Value<bool> isActive;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const ItemGroupsCompanion({
    this.id = const Value.absent(),
    this.groupCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.parentGroupId = const Value.absent(),
    this.inventoryAccountId = const Value.absent(),
    this.salesRevenueAccountId = const Value.absent(),
    this.cogsAccountId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ItemGroupsCompanion.insert({
    this.id = const Value.absent(),
    required String groupCode,
    required String nameAr,
    required String nameEn,
    this.parentGroupId = const Value.absent(),
    required String inventoryAccountId,
    required String salesRevenueAccountId,
    required String cogsAccountId,
    this.isActive = const Value.absent(),
    required int createdAt,
    required int updatedAt,
  })  : groupCode = Value(groupCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        inventoryAccountId = Value(inventoryAccountId),
        salesRevenueAccountId = Value(salesRevenueAccountId),
        cogsAccountId = Value(cogsAccountId),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<ItemGroup> custom({
    Expression<int>? id,
    Expression<String>? groupCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<int>? parentGroupId,
    Expression<String>? inventoryAccountId,
    Expression<String>? salesRevenueAccountId,
    Expression<String>? cogsAccountId,
    Expression<bool>? isActive,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (groupCode != null) 'group_code': groupCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (parentGroupId != null) 'parent_group_id': parentGroupId,
      if (inventoryAccountId != null)
        'inventory_account_id': inventoryAccountId,
      if (salesRevenueAccountId != null)
        'sales_revenue_account_id': salesRevenueAccountId,
      if (cogsAccountId != null) 'cogs_account_id': cogsAccountId,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ItemGroupsCompanion copyWith(
      {Value<int>? id,
      Value<String>? groupCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<int?>? parentGroupId,
      Value<String>? inventoryAccountId,
      Value<String>? salesRevenueAccountId,
      Value<String>? cogsAccountId,
      Value<bool>? isActive,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return ItemGroupsCompanion(
      id: id ?? this.id,
      groupCode: groupCode ?? this.groupCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      parentGroupId: parentGroupId ?? this.parentGroupId,
      inventoryAccountId: inventoryAccountId ?? this.inventoryAccountId,
      salesRevenueAccountId:
          salesRevenueAccountId ?? this.salesRevenueAccountId,
      cogsAccountId: cogsAccountId ?? this.cogsAccountId,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (groupCode.present) {
      map['group_code'] = Variable<String>(groupCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (parentGroupId.present) {
      map['parent_group_id'] = Variable<int>(parentGroupId.value);
    }
    if (inventoryAccountId.present) {
      map['inventory_account_id'] = Variable<String>(inventoryAccountId.value);
    }
    if (salesRevenueAccountId.present) {
      map['sales_revenue_account_id'] =
          Variable<String>(salesRevenueAccountId.value);
    }
    if (cogsAccountId.present) {
      map['cogs_account_id'] = Variable<String>(cogsAccountId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemGroupsCompanion(')
          ..write('id: $id, ')
          ..write('groupCode: $groupCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('parentGroupId: $parentGroupId, ')
          ..write('inventoryAccountId: $inventoryAccountId, ')
          ..write('salesRevenueAccountId: $salesRevenueAccountId, ')
          ..write('cogsAccountId: $cogsAccountId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class Items extends Table with TableInfo<Items, Item> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Items(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemCodeMeta =
      const VerificationMeta('itemCode');
  late final GeneratedColumn<String> itemCode = GeneratedColumn<String>(
      'item_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _barcodeMeta =
      const VerificationMeta('barcode');
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
      'barcode', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: 'UNIQUE');
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _itemTypeMeta =
      const VerificationMeta('itemType');
  late final GeneratedColumn<String> itemType = GeneratedColumn<String>(
      'item_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL CHECK (item_type IN (\'Stockable\', \'Service\', \'Assembled\'))');
  static const VerificationMeta _itemGroupIdMeta =
      const VerificationMeta('itemGroupId');
  late final GeneratedColumn<int> itemGroupId = GeneratedColumn<int>(
      'item_group_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES item_groups(id)');
  static const VerificationMeta _baseUnitMeta =
      const VerificationMeta('baseUnit');
  late final GeneratedColumn<String> baseUnit = GeneratedColumn<String>(
      'base_unit', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _costingMethodMeta =
      const VerificationMeta('costingMethod');
  late final GeneratedColumn<String> costingMethod = GeneratedColumn<String>(
      'costing_method', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'CHECK (costing_method IN (\'Weighted Average\', \'FIFO\', \'LIFO\'))');
  static const VerificationMeta _costPriceMeta =
      const VerificationMeta('costPrice');
  late final GeneratedColumn<double> costPrice = GeneratedColumn<double>(
      'cost_price', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT 0',
      defaultValue: const CustomExpression('0'));
  static const VerificationMeta _reorderLevelMeta =
      const VerificationMeta('reorderLevel');
  late final GeneratedColumn<double> reorderLevel = GeneratedColumn<double>(
      'reorder_level', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _maxStockLevelMeta =
      const VerificationMeta('maxStockLevel');
  late final GeneratedColumn<double> maxStockLevel = GeneratedColumn<double>(
      'max_stock_level', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _minStockLevelMeta =
      const VerificationMeta('minStockLevel');
  late final GeneratedColumn<double> minStockLevel = GeneratedColumn<double>(
      'min_stock_level', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _trackExpiryDateMeta =
      const VerificationMeta('trackExpiryDate');
  late final GeneratedColumn<bool> trackExpiryDate = GeneratedColumn<bool>(
      'track_expiry_date', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _trackBatchNumberMeta =
      const VerificationMeta('trackBatchNumber');
  late final GeneratedColumn<bool> trackBatchNumber = GeneratedColumn<bool>(
      'track_batch_number', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _inventoryAccountIdMeta =
      const VerificationMeta('inventoryAccountId');
  late final GeneratedColumn<String> inventoryAccountId =
      GeneratedColumn<String>('inventory_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _salesRevenueAccountIdMeta =
      const VerificationMeta('salesRevenueAccountId');
  late final GeneratedColumn<String> salesRevenueAccountId =
      GeneratedColumn<String>('sales_revenue_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _cogsAccountIdMeta =
      const VerificationMeta('cogsAccountId');
  late final GeneratedColumn<String> cogsAccountId = GeneratedColumn<String>(
      'cogs_account_id', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _stockDiscrepancyAccountIdMeta =
      const VerificationMeta('stockDiscrepancyAccountId');
  late final GeneratedColumn<String> stockDiscrepancyAccountId =
      GeneratedColumn<String>('stock_discrepancy_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: 'REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        itemCode,
        nameAr,
        nameEn,
        barcode,
        description,
        itemType,
        itemGroupId,
        baseUnit,
        costingMethod,
        costPrice,
        reorderLevel,
        maxStockLevel,
        minStockLevel,
        trackExpiryDate,
        trackBatchNumber,
        inventoryAccountId,
        salesRevenueAccountId,
        cogsAccountId,
        stockDiscrepancyAccountId,
        isActive,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'items';
  @override
  VerificationContext validateIntegrity(Insertable<Item> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_code')) {
      context.handle(_itemCodeMeta,
          itemCode.isAcceptableOrUnknown(data['item_code']!, _itemCodeMeta));
    } else if (isInserting) {
      context.missing(_itemCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('barcode')) {
      context.handle(_barcodeMeta,
          barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('item_type')) {
      context.handle(_itemTypeMeta,
          itemType.isAcceptableOrUnknown(data['item_type']!, _itemTypeMeta));
    } else if (isInserting) {
      context.missing(_itemTypeMeta);
    }
    if (data.containsKey('item_group_id')) {
      context.handle(
          _itemGroupIdMeta,
          itemGroupId.isAcceptableOrUnknown(
              data['item_group_id']!, _itemGroupIdMeta));
    } else if (isInserting) {
      context.missing(_itemGroupIdMeta);
    }
    if (data.containsKey('base_unit')) {
      context.handle(_baseUnitMeta,
          baseUnit.isAcceptableOrUnknown(data['base_unit']!, _baseUnitMeta));
    } else if (isInserting) {
      context.missing(_baseUnitMeta);
    }
    if (data.containsKey('costing_method')) {
      context.handle(
          _costingMethodMeta,
          costingMethod.isAcceptableOrUnknown(
              data['costing_method']!, _costingMethodMeta));
    }
    if (data.containsKey('cost_price')) {
      context.handle(_costPriceMeta,
          costPrice.isAcceptableOrUnknown(data['cost_price']!, _costPriceMeta));
    }
    if (data.containsKey('reorder_level')) {
      context.handle(
          _reorderLevelMeta,
          reorderLevel.isAcceptableOrUnknown(
              data['reorder_level']!, _reorderLevelMeta));
    }
    if (data.containsKey('max_stock_level')) {
      context.handle(
          _maxStockLevelMeta,
          maxStockLevel.isAcceptableOrUnknown(
              data['max_stock_level']!, _maxStockLevelMeta));
    }
    if (data.containsKey('min_stock_level')) {
      context.handle(
          _minStockLevelMeta,
          minStockLevel.isAcceptableOrUnknown(
              data['min_stock_level']!, _minStockLevelMeta));
    }
    if (data.containsKey('track_expiry_date')) {
      context.handle(
          _trackExpiryDateMeta,
          trackExpiryDate.isAcceptableOrUnknown(
              data['track_expiry_date']!, _trackExpiryDateMeta));
    }
    if (data.containsKey('track_batch_number')) {
      context.handle(
          _trackBatchNumberMeta,
          trackBatchNumber.isAcceptableOrUnknown(
              data['track_batch_number']!, _trackBatchNumberMeta));
    }
    if (data.containsKey('inventory_account_id')) {
      context.handle(
          _inventoryAccountIdMeta,
          inventoryAccountId.isAcceptableOrUnknown(
              data['inventory_account_id']!, _inventoryAccountIdMeta));
    }
    if (data.containsKey('sales_revenue_account_id')) {
      context.handle(
          _salesRevenueAccountIdMeta,
          salesRevenueAccountId.isAcceptableOrUnknown(
              data['sales_revenue_account_id']!, _salesRevenueAccountIdMeta));
    }
    if (data.containsKey('cogs_account_id')) {
      context.handle(
          _cogsAccountIdMeta,
          cogsAccountId.isAcceptableOrUnknown(
              data['cogs_account_id']!, _cogsAccountIdMeta));
    }
    if (data.containsKey('stock_discrepancy_account_id')) {
      context.handle(
          _stockDiscrepancyAccountIdMeta,
          stockDiscrepancyAccountId.isAcceptableOrUnknown(
              data['stock_discrepancy_account_id']!,
              _stockDiscrepancyAccountIdMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Item map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Item(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      barcode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}barcode']),
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      itemType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}item_type'])!,
      itemGroupId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_group_id'])!,
      baseUnit: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}base_unit'])!,
      costingMethod: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}costing_method']),
      costPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}cost_price'])!,
      reorderLevel: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}reorder_level']),
      maxStockLevel: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}max_stock_level']),
      minStockLevel: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}min_stock_level']),
      trackExpiryDate: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}track_expiry_date'])!,
      trackBatchNumber: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}track_batch_number'])!,
      inventoryAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}inventory_account_id']),
      salesRevenueAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}sales_revenue_account_id']),
      cogsAccountId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cogs_account_id']),
      stockDiscrepancyAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}stock_discrepancy_account_id']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  Items createAlias(String alias) {
    return Items(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Item extends DataClass implements Insertable<Item> {
  final int id;
  final String itemCode;
  final String nameAr;
  final String nameEn;
  final String? barcode;
  final String? description;
  final String itemType;
  final int itemGroupId;
  final String baseUnit;
  final String? costingMethod;
  final double costPrice;
  final double? reorderLevel;
  final double? maxStockLevel;
  final double? minStockLevel;
  final bool trackExpiryDate;
  final bool trackBatchNumber;
  final String? inventoryAccountId;
  final String? salesRevenueAccountId;
  final String? cogsAccountId;
  final String? stockDiscrepancyAccountId;
  final bool isActive;
  final int createdAt;
  final int updatedAt;
  const Item(
      {required this.id,
      required this.itemCode,
      required this.nameAr,
      required this.nameEn,
      this.barcode,
      this.description,
      required this.itemType,
      required this.itemGroupId,
      required this.baseUnit,
      this.costingMethod,
      required this.costPrice,
      this.reorderLevel,
      this.maxStockLevel,
      this.minStockLevel,
      required this.trackExpiryDate,
      required this.trackBatchNumber,
      this.inventoryAccountId,
      this.salesRevenueAccountId,
      this.cogsAccountId,
      this.stockDiscrepancyAccountId,
      required this.isActive,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_code'] = Variable<String>(itemCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['item_type'] = Variable<String>(itemType);
    map['item_group_id'] = Variable<int>(itemGroupId);
    map['base_unit'] = Variable<String>(baseUnit);
    if (!nullToAbsent || costingMethod != null) {
      map['costing_method'] = Variable<String>(costingMethod);
    }
    map['cost_price'] = Variable<double>(costPrice);
    if (!nullToAbsent || reorderLevel != null) {
      map['reorder_level'] = Variable<double>(reorderLevel);
    }
    if (!nullToAbsent || maxStockLevel != null) {
      map['max_stock_level'] = Variable<double>(maxStockLevel);
    }
    if (!nullToAbsent || minStockLevel != null) {
      map['min_stock_level'] = Variable<double>(minStockLevel);
    }
    map['track_expiry_date'] = Variable<bool>(trackExpiryDate);
    map['track_batch_number'] = Variable<bool>(trackBatchNumber);
    if (!nullToAbsent || inventoryAccountId != null) {
      map['inventory_account_id'] = Variable<String>(inventoryAccountId);
    }
    if (!nullToAbsent || salesRevenueAccountId != null) {
      map['sales_revenue_account_id'] = Variable<String>(salesRevenueAccountId);
    }
    if (!nullToAbsent || cogsAccountId != null) {
      map['cogs_account_id'] = Variable<String>(cogsAccountId);
    }
    if (!nullToAbsent || stockDiscrepancyAccountId != null) {
      map['stock_discrepancy_account_id'] =
          Variable<String>(stockDiscrepancyAccountId);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ItemsCompanion toCompanion(bool nullToAbsent) {
    return ItemsCompanion(
      id: Value(id),
      itemCode: Value(itemCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      itemType: Value(itemType),
      itemGroupId: Value(itemGroupId),
      baseUnit: Value(baseUnit),
      costingMethod: costingMethod == null && nullToAbsent
          ? const Value.absent()
          : Value(costingMethod),
      costPrice: Value(costPrice),
      reorderLevel: reorderLevel == null && nullToAbsent
          ? const Value.absent()
          : Value(reorderLevel),
      maxStockLevel: maxStockLevel == null && nullToAbsent
          ? const Value.absent()
          : Value(maxStockLevel),
      minStockLevel: minStockLevel == null && nullToAbsent
          ? const Value.absent()
          : Value(minStockLevel),
      trackExpiryDate: Value(trackExpiryDate),
      trackBatchNumber: Value(trackBatchNumber),
      inventoryAccountId: inventoryAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(inventoryAccountId),
      salesRevenueAccountId: salesRevenueAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(salesRevenueAccountId),
      cogsAccountId: cogsAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(cogsAccountId),
      stockDiscrepancyAccountId:
          stockDiscrepancyAccountId == null && nullToAbsent
              ? const Value.absent()
              : Value(stockDiscrepancyAccountId),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Item.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Item(
      id: serializer.fromJson<int>(json['id']),
      itemCode: serializer.fromJson<String>(json['item_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      description: serializer.fromJson<String?>(json['description']),
      itemType: serializer.fromJson<String>(json['item_type']),
      itemGroupId: serializer.fromJson<int>(json['item_group_id']),
      baseUnit: serializer.fromJson<String>(json['base_unit']),
      costingMethod: serializer.fromJson<String?>(json['costing_method']),
      costPrice: serializer.fromJson<double>(json['cost_price']),
      reorderLevel: serializer.fromJson<double?>(json['reorder_level']),
      maxStockLevel: serializer.fromJson<double?>(json['max_stock_level']),
      minStockLevel: serializer.fromJson<double?>(json['min_stock_level']),
      trackExpiryDate: serializer.fromJson<bool>(json['track_expiry_date']),
      trackBatchNumber: serializer.fromJson<bool>(json['track_batch_number']),
      inventoryAccountId:
          serializer.fromJson<String?>(json['inventory_account_id']),
      salesRevenueAccountId:
          serializer.fromJson<String?>(json['sales_revenue_account_id']),
      cogsAccountId: serializer.fromJson<String?>(json['cogs_account_id']),
      stockDiscrepancyAccountId:
          serializer.fromJson<String?>(json['stock_discrepancy_account_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_code': serializer.toJson<String>(itemCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'barcode': serializer.toJson<String?>(barcode),
      'description': serializer.toJson<String?>(description),
      'item_type': serializer.toJson<String>(itemType),
      'item_group_id': serializer.toJson<int>(itemGroupId),
      'base_unit': serializer.toJson<String>(baseUnit),
      'costing_method': serializer.toJson<String?>(costingMethod),
      'cost_price': serializer.toJson<double>(costPrice),
      'reorder_level': serializer.toJson<double?>(reorderLevel),
      'max_stock_level': serializer.toJson<double?>(maxStockLevel),
      'min_stock_level': serializer.toJson<double?>(minStockLevel),
      'track_expiry_date': serializer.toJson<bool>(trackExpiryDate),
      'track_batch_number': serializer.toJson<bool>(trackBatchNumber),
      'inventory_account_id': serializer.toJson<String?>(inventoryAccountId),
      'sales_revenue_account_id':
          serializer.toJson<String?>(salesRevenueAccountId),
      'cogs_account_id': serializer.toJson<String?>(cogsAccountId),
      'stock_discrepancy_account_id':
          serializer.toJson<String?>(stockDiscrepancyAccountId),
      'is_active': serializer.toJson<bool>(isActive),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  Item copyWith(
          {int? id,
          String? itemCode,
          String? nameAr,
          String? nameEn,
          Value<String?> barcode = const Value.absent(),
          Value<String?> description = const Value.absent(),
          String? itemType,
          int? itemGroupId,
          String? baseUnit,
          Value<String?> costingMethod = const Value.absent(),
          double? costPrice,
          Value<double?> reorderLevel = const Value.absent(),
          Value<double?> maxStockLevel = const Value.absent(),
          Value<double?> minStockLevel = const Value.absent(),
          bool? trackExpiryDate,
          bool? trackBatchNumber,
          Value<String?> inventoryAccountId = const Value.absent(),
          Value<String?> salesRevenueAccountId = const Value.absent(),
          Value<String?> cogsAccountId = const Value.absent(),
          Value<String?> stockDiscrepancyAccountId = const Value.absent(),
          bool? isActive,
          int? createdAt,
          int? updatedAt}) =>
      Item(
        id: id ?? this.id,
        itemCode: itemCode ?? this.itemCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        barcode: barcode.present ? barcode.value : this.barcode,
        description: description.present ? description.value : this.description,
        itemType: itemType ?? this.itemType,
        itemGroupId: itemGroupId ?? this.itemGroupId,
        baseUnit: baseUnit ?? this.baseUnit,
        costingMethod:
            costingMethod.present ? costingMethod.value : this.costingMethod,
        costPrice: costPrice ?? this.costPrice,
        reorderLevel:
            reorderLevel.present ? reorderLevel.value : this.reorderLevel,
        maxStockLevel:
            maxStockLevel.present ? maxStockLevel.value : this.maxStockLevel,
        minStockLevel:
            minStockLevel.present ? minStockLevel.value : this.minStockLevel,
        trackExpiryDate: trackExpiryDate ?? this.trackExpiryDate,
        trackBatchNumber: trackBatchNumber ?? this.trackBatchNumber,
        inventoryAccountId: inventoryAccountId.present
            ? inventoryAccountId.value
            : this.inventoryAccountId,
        salesRevenueAccountId: salesRevenueAccountId.present
            ? salesRevenueAccountId.value
            : this.salesRevenueAccountId,
        cogsAccountId:
            cogsAccountId.present ? cogsAccountId.value : this.cogsAccountId,
        stockDiscrepancyAccountId: stockDiscrepancyAccountId.present
            ? stockDiscrepancyAccountId.value
            : this.stockDiscrepancyAccountId,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  Item copyWithCompanion(ItemsCompanion data) {
    return Item(
      id: data.id.present ? data.id.value : this.id,
      itemCode: data.itemCode.present ? data.itemCode.value : this.itemCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      description:
          data.description.present ? data.description.value : this.description,
      itemType: data.itemType.present ? data.itemType.value : this.itemType,
      itemGroupId:
          data.itemGroupId.present ? data.itemGroupId.value : this.itemGroupId,
      baseUnit: data.baseUnit.present ? data.baseUnit.value : this.baseUnit,
      costingMethod: data.costingMethod.present
          ? data.costingMethod.value
          : this.costingMethod,
      costPrice: data.costPrice.present ? data.costPrice.value : this.costPrice,
      reorderLevel: data.reorderLevel.present
          ? data.reorderLevel.value
          : this.reorderLevel,
      maxStockLevel: data.maxStockLevel.present
          ? data.maxStockLevel.value
          : this.maxStockLevel,
      minStockLevel: data.minStockLevel.present
          ? data.minStockLevel.value
          : this.minStockLevel,
      trackExpiryDate: data.trackExpiryDate.present
          ? data.trackExpiryDate.value
          : this.trackExpiryDate,
      trackBatchNumber: data.trackBatchNumber.present
          ? data.trackBatchNumber.value
          : this.trackBatchNumber,
      inventoryAccountId: data.inventoryAccountId.present
          ? data.inventoryAccountId.value
          : this.inventoryAccountId,
      salesRevenueAccountId: data.salesRevenueAccountId.present
          ? data.salesRevenueAccountId.value
          : this.salesRevenueAccountId,
      cogsAccountId: data.cogsAccountId.present
          ? data.cogsAccountId.value
          : this.cogsAccountId,
      stockDiscrepancyAccountId: data.stockDiscrepancyAccountId.present
          ? data.stockDiscrepancyAccountId.value
          : this.stockDiscrepancyAccountId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Item(')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('barcode: $barcode, ')
          ..write('description: $description, ')
          ..write('itemType: $itemType, ')
          ..write('itemGroupId: $itemGroupId, ')
          ..write('baseUnit: $baseUnit, ')
          ..write('costingMethod: $costingMethod, ')
          ..write('costPrice: $costPrice, ')
          ..write('reorderLevel: $reorderLevel, ')
          ..write('maxStockLevel: $maxStockLevel, ')
          ..write('minStockLevel: $minStockLevel, ')
          ..write('trackExpiryDate: $trackExpiryDate, ')
          ..write('trackBatchNumber: $trackBatchNumber, ')
          ..write('inventoryAccountId: $inventoryAccountId, ')
          ..write('salesRevenueAccountId: $salesRevenueAccountId, ')
          ..write('cogsAccountId: $cogsAccountId, ')
          ..write('stockDiscrepancyAccountId: $stockDiscrepancyAccountId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        itemCode,
        nameAr,
        nameEn,
        barcode,
        description,
        itemType,
        itemGroupId,
        baseUnit,
        costingMethod,
        costPrice,
        reorderLevel,
        maxStockLevel,
        minStockLevel,
        trackExpiryDate,
        trackBatchNumber,
        inventoryAccountId,
        salesRevenueAccountId,
        cogsAccountId,
        stockDiscrepancyAccountId,
        isActive,
        createdAt,
        updatedAt
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Item &&
          other.id == this.id &&
          other.itemCode == this.itemCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.barcode == this.barcode &&
          other.description == this.description &&
          other.itemType == this.itemType &&
          other.itemGroupId == this.itemGroupId &&
          other.baseUnit == this.baseUnit &&
          other.costingMethod == this.costingMethod &&
          other.costPrice == this.costPrice &&
          other.reorderLevel == this.reorderLevel &&
          other.maxStockLevel == this.maxStockLevel &&
          other.minStockLevel == this.minStockLevel &&
          other.trackExpiryDate == this.trackExpiryDate &&
          other.trackBatchNumber == this.trackBatchNumber &&
          other.inventoryAccountId == this.inventoryAccountId &&
          other.salesRevenueAccountId == this.salesRevenueAccountId &&
          other.cogsAccountId == this.cogsAccountId &&
          other.stockDiscrepancyAccountId == this.stockDiscrepancyAccountId &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ItemsCompanion extends UpdateCompanion<Item> {
  final Value<int> id;
  final Value<String> itemCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String?> barcode;
  final Value<String?> description;
  final Value<String> itemType;
  final Value<int> itemGroupId;
  final Value<String> baseUnit;
  final Value<String?> costingMethod;
  final Value<double> costPrice;
  final Value<double?> reorderLevel;
  final Value<double?> maxStockLevel;
  final Value<double?> minStockLevel;
  final Value<bool> trackExpiryDate;
  final Value<bool> trackBatchNumber;
  final Value<String?> inventoryAccountId;
  final Value<String?> salesRevenueAccountId;
  final Value<String?> cogsAccountId;
  final Value<String?> stockDiscrepancyAccountId;
  final Value<bool> isActive;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const ItemsCompanion({
    this.id = const Value.absent(),
    this.itemCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.barcode = const Value.absent(),
    this.description = const Value.absent(),
    this.itemType = const Value.absent(),
    this.itemGroupId = const Value.absent(),
    this.baseUnit = const Value.absent(),
    this.costingMethod = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.reorderLevel = const Value.absent(),
    this.maxStockLevel = const Value.absent(),
    this.minStockLevel = const Value.absent(),
    this.trackExpiryDate = const Value.absent(),
    this.trackBatchNumber = const Value.absent(),
    this.inventoryAccountId = const Value.absent(),
    this.salesRevenueAccountId = const Value.absent(),
    this.cogsAccountId = const Value.absent(),
    this.stockDiscrepancyAccountId = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ItemsCompanion.insert({
    this.id = const Value.absent(),
    required String itemCode,
    required String nameAr,
    required String nameEn,
    this.barcode = const Value.absent(),
    this.description = const Value.absent(),
    required String itemType,
    required int itemGroupId,
    required String baseUnit,
    this.costingMethod = const Value.absent(),
    this.costPrice = const Value.absent(),
    this.reorderLevel = const Value.absent(),
    this.maxStockLevel = const Value.absent(),
    this.minStockLevel = const Value.absent(),
    this.trackExpiryDate = const Value.absent(),
    this.trackBatchNumber = const Value.absent(),
    this.inventoryAccountId = const Value.absent(),
    this.salesRevenueAccountId = const Value.absent(),
    this.cogsAccountId = const Value.absent(),
    this.stockDiscrepancyAccountId = const Value.absent(),
    this.isActive = const Value.absent(),
    required int createdAt,
    required int updatedAt,
  })  : itemCode = Value(itemCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        itemType = Value(itemType),
        itemGroupId = Value(itemGroupId),
        baseUnit = Value(baseUnit),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<Item> custom({
    Expression<int>? id,
    Expression<String>? itemCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? barcode,
    Expression<String>? description,
    Expression<String>? itemType,
    Expression<int>? itemGroupId,
    Expression<String>? baseUnit,
    Expression<String>? costingMethod,
    Expression<double>? costPrice,
    Expression<double>? reorderLevel,
    Expression<double>? maxStockLevel,
    Expression<double>? minStockLevel,
    Expression<bool>? trackExpiryDate,
    Expression<bool>? trackBatchNumber,
    Expression<String>? inventoryAccountId,
    Expression<String>? salesRevenueAccountId,
    Expression<String>? cogsAccountId,
    Expression<String>? stockDiscrepancyAccountId,
    Expression<bool>? isActive,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemCode != null) 'item_code': itemCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (barcode != null) 'barcode': barcode,
      if (description != null) 'description': description,
      if (itemType != null) 'item_type': itemType,
      if (itemGroupId != null) 'item_group_id': itemGroupId,
      if (baseUnit != null) 'base_unit': baseUnit,
      if (costingMethod != null) 'costing_method': costingMethod,
      if (costPrice != null) 'cost_price': costPrice,
      if (reorderLevel != null) 'reorder_level': reorderLevel,
      if (maxStockLevel != null) 'max_stock_level': maxStockLevel,
      if (minStockLevel != null) 'min_stock_level': minStockLevel,
      if (trackExpiryDate != null) 'track_expiry_date': trackExpiryDate,
      if (trackBatchNumber != null) 'track_batch_number': trackBatchNumber,
      if (inventoryAccountId != null)
        'inventory_account_id': inventoryAccountId,
      if (salesRevenueAccountId != null)
        'sales_revenue_account_id': salesRevenueAccountId,
      if (cogsAccountId != null) 'cogs_account_id': cogsAccountId,
      if (stockDiscrepancyAccountId != null)
        'stock_discrepancy_account_id': stockDiscrepancyAccountId,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? itemCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String?>? barcode,
      Value<String?>? description,
      Value<String>? itemType,
      Value<int>? itemGroupId,
      Value<String>? baseUnit,
      Value<String?>? costingMethod,
      Value<double>? costPrice,
      Value<double?>? reorderLevel,
      Value<double?>? maxStockLevel,
      Value<double?>? minStockLevel,
      Value<bool>? trackExpiryDate,
      Value<bool>? trackBatchNumber,
      Value<String?>? inventoryAccountId,
      Value<String?>? salesRevenueAccountId,
      Value<String?>? cogsAccountId,
      Value<String?>? stockDiscrepancyAccountId,
      Value<bool>? isActive,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return ItemsCompanion(
      id: id ?? this.id,
      itemCode: itemCode ?? this.itemCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      barcode: barcode ?? this.barcode,
      description: description ?? this.description,
      itemType: itemType ?? this.itemType,
      itemGroupId: itemGroupId ?? this.itemGroupId,
      baseUnit: baseUnit ?? this.baseUnit,
      costingMethod: costingMethod ?? this.costingMethod,
      costPrice: costPrice ?? this.costPrice,
      reorderLevel: reorderLevel ?? this.reorderLevel,
      maxStockLevel: maxStockLevel ?? this.maxStockLevel,
      minStockLevel: minStockLevel ?? this.minStockLevel,
      trackExpiryDate: trackExpiryDate ?? this.trackExpiryDate,
      trackBatchNumber: trackBatchNumber ?? this.trackBatchNumber,
      inventoryAccountId: inventoryAccountId ?? this.inventoryAccountId,
      salesRevenueAccountId:
          salesRevenueAccountId ?? this.salesRevenueAccountId,
      cogsAccountId: cogsAccountId ?? this.cogsAccountId,
      stockDiscrepancyAccountId:
          stockDiscrepancyAccountId ?? this.stockDiscrepancyAccountId,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemCode.present) {
      map['item_code'] = Variable<String>(itemCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (itemType.present) {
      map['item_type'] = Variable<String>(itemType.value);
    }
    if (itemGroupId.present) {
      map['item_group_id'] = Variable<int>(itemGroupId.value);
    }
    if (baseUnit.present) {
      map['base_unit'] = Variable<String>(baseUnit.value);
    }
    if (costingMethod.present) {
      map['costing_method'] = Variable<String>(costingMethod.value);
    }
    if (costPrice.present) {
      map['cost_price'] = Variable<double>(costPrice.value);
    }
    if (reorderLevel.present) {
      map['reorder_level'] = Variable<double>(reorderLevel.value);
    }
    if (maxStockLevel.present) {
      map['max_stock_level'] = Variable<double>(maxStockLevel.value);
    }
    if (minStockLevel.present) {
      map['min_stock_level'] = Variable<double>(minStockLevel.value);
    }
    if (trackExpiryDate.present) {
      map['track_expiry_date'] = Variable<bool>(trackExpiryDate.value);
    }
    if (trackBatchNumber.present) {
      map['track_batch_number'] = Variable<bool>(trackBatchNumber.value);
    }
    if (inventoryAccountId.present) {
      map['inventory_account_id'] = Variable<String>(inventoryAccountId.value);
    }
    if (salesRevenueAccountId.present) {
      map['sales_revenue_account_id'] =
          Variable<String>(salesRevenueAccountId.value);
    }
    if (cogsAccountId.present) {
      map['cogs_account_id'] = Variable<String>(cogsAccountId.value);
    }
    if (stockDiscrepancyAccountId.present) {
      map['stock_discrepancy_account_id'] =
          Variable<String>(stockDiscrepancyAccountId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemsCompanion(')
          ..write('id: $id, ')
          ..write('itemCode: $itemCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('barcode: $barcode, ')
          ..write('description: $description, ')
          ..write('itemType: $itemType, ')
          ..write('itemGroupId: $itemGroupId, ')
          ..write('baseUnit: $baseUnit, ')
          ..write('costingMethod: $costingMethod, ')
          ..write('costPrice: $costPrice, ')
          ..write('reorderLevel: $reorderLevel, ')
          ..write('maxStockLevel: $maxStockLevel, ')
          ..write('minStockLevel: $minStockLevel, ')
          ..write('trackExpiryDate: $trackExpiryDate, ')
          ..write('trackBatchNumber: $trackBatchNumber, ')
          ..write('inventoryAccountId: $inventoryAccountId, ')
          ..write('salesRevenueAccountId: $salesRevenueAccountId, ')
          ..write('cogsAccountId: $cogsAccountId, ')
          ..write('stockDiscrepancyAccountId: $stockDiscrepancyAccountId, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class ItemSubUnits extends Table with TableInfo<ItemSubUnits, ItemSubUnit> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ItemSubUnits(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)ON DELETE CASCADE');
  static const VerificationMeta _unitNameMeta =
      const VerificationMeta('unitName');
  late final GeneratedColumn<String> unitName = GeneratedColumn<String>(
      'unit_name', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _conversionFactorMeta =
      const VerificationMeta('conversionFactor');
  late final GeneratedColumn<double> conversionFactor = GeneratedColumn<double>(
      'conversion_factor', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, itemId, unitName, conversionFactor, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_sub_units';
  @override
  VerificationContext validateIntegrity(Insertable<ItemSubUnit> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('unit_name')) {
      context.handle(_unitNameMeta,
          unitName.isAcceptableOrUnknown(data['unit_name']!, _unitNameMeta));
    } else if (isInserting) {
      context.missing(_unitNameMeta);
    }
    if (data.containsKey('conversion_factor')) {
      context.handle(
          _conversionFactorMeta,
          conversionFactor.isAcceptableOrUnknown(
              data['conversion_factor']!, _conversionFactorMeta));
    } else if (isInserting) {
      context.missing(_conversionFactorMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemSubUnit map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemSubUnit(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      unitName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}unit_name'])!,
      conversionFactor: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}conversion_factor'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  ItemSubUnits createAlias(String alias) {
    return ItemSubUnits(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class ItemSubUnit extends DataClass implements Insertable<ItemSubUnit> {
  final int id;
  final int itemId;
  final String unitName;
  final double conversionFactor;
  final int createdAt;
  const ItemSubUnit(
      {required this.id,
      required this.itemId,
      required this.unitName,
      required this.conversionFactor,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<int>(itemId);
    map['unit_name'] = Variable<String>(unitName);
    map['conversion_factor'] = Variable<double>(conversionFactor);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  ItemSubUnitsCompanion toCompanion(bool nullToAbsent) {
    return ItemSubUnitsCompanion(
      id: Value(id),
      itemId: Value(itemId),
      unitName: Value(unitName),
      conversionFactor: Value(conversionFactor),
      createdAt: Value(createdAt),
    );
  }

  factory ItemSubUnit.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemSubUnit(
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      unitName: serializer.fromJson<String>(json['unit_name']),
      conversionFactor: serializer.fromJson<double>(json['conversion_factor']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_id': serializer.toJson<int>(itemId),
      'unit_name': serializer.toJson<String>(unitName),
      'conversion_factor': serializer.toJson<double>(conversionFactor),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  ItemSubUnit copyWith(
          {int? id,
          int? itemId,
          String? unitName,
          double? conversionFactor,
          int? createdAt}) =>
      ItemSubUnit(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        unitName: unitName ?? this.unitName,
        conversionFactor: conversionFactor ?? this.conversionFactor,
        createdAt: createdAt ?? this.createdAt,
      );
  ItemSubUnit copyWithCompanion(ItemSubUnitsCompanion data) {
    return ItemSubUnit(
      id: data.id.present ? data.id.value : this.id,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      unitName: data.unitName.present ? data.unitName.value : this.unitName,
      conversionFactor: data.conversionFactor.present
          ? data.conversionFactor.value
          : this.conversionFactor,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ItemSubUnit(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('unitName: $unitName, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, itemId, unitName, conversionFactor, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemSubUnit &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.unitName == this.unitName &&
          other.conversionFactor == this.conversionFactor &&
          other.createdAt == this.createdAt);
}

class ItemSubUnitsCompanion extends UpdateCompanion<ItemSubUnit> {
  final Value<int> id;
  final Value<int> itemId;
  final Value<String> unitName;
  final Value<double> conversionFactor;
  final Value<int> createdAt;
  const ItemSubUnitsCompanion({
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.unitName = const Value.absent(),
    this.conversionFactor = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  ItemSubUnitsCompanion.insert({
    this.id = const Value.absent(),
    required int itemId,
    required String unitName,
    required double conversionFactor,
    required int createdAt,
  })  : itemId = Value(itemId),
        unitName = Value(unitName),
        conversionFactor = Value(conversionFactor),
        createdAt = Value(createdAt);
  static Insertable<ItemSubUnit> custom({
    Expression<int>? id,
    Expression<int>? itemId,
    Expression<String>? unitName,
    Expression<double>? conversionFactor,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (unitName != null) 'unit_name': unitName,
      if (conversionFactor != null) 'conversion_factor': conversionFactor,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  ItemSubUnitsCompanion copyWith(
      {Value<int>? id,
      Value<int>? itemId,
      Value<String>? unitName,
      Value<double>? conversionFactor,
      Value<int>? createdAt}) {
    return ItemSubUnitsCompanion(
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      unitName: unitName ?? this.unitName,
      conversionFactor: conversionFactor ?? this.conversionFactor,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (unitName.present) {
      map['unit_name'] = Variable<String>(unitName.value);
    }
    if (conversionFactor.present) {
      map['conversion_factor'] = Variable<double>(conversionFactor.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemSubUnitsCompanion(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('unitName: $unitName, ')
          ..write('conversionFactor: $conversionFactor, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class ItemSellingPrices extends Table
    with TableInfo<ItemSellingPrices, ItemSellingPrice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ItemSellingPrices(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)ON DELETE CASCADE');
  static const VerificationMeta _priceLevelNameMeta =
      const VerificationMeta('priceLevelName');
  late final GeneratedColumn<String> priceLevelName = GeneratedColumn<String>(
      'price_level_name', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
      'price', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, itemId, priceLevelName, price, createdAt, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_selling_prices';
  @override
  VerificationContext validateIntegrity(Insertable<ItemSellingPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('price_level_name')) {
      context.handle(
          _priceLevelNameMeta,
          priceLevelName.isAcceptableOrUnknown(
              data['price_level_name']!, _priceLevelNameMeta));
    } else if (isInserting) {
      context.missing(_priceLevelNameMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
          _priceMeta, price.isAcceptableOrUnknown(data['price']!, _priceMeta));
    } else if (isInserting) {
      context.missing(_priceMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemSellingPrice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemSellingPrice(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      priceLevelName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}price_level_name'])!,
      price: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}price'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  ItemSellingPrices createAlias(String alias) {
    return ItemSellingPrices(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class ItemSellingPrice extends DataClass
    implements Insertable<ItemSellingPrice> {
  final int id;
  final int itemId;
  final String priceLevelName;
  final double price;
  final int createdAt;
  final int updatedAt;
  const ItemSellingPrice(
      {required this.id,
      required this.itemId,
      required this.priceLevelName,
      required this.price,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<int>(itemId);
    map['price_level_name'] = Variable<String>(priceLevelName);
    map['price'] = Variable<double>(price);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ItemSellingPricesCompanion toCompanion(bool nullToAbsent) {
    return ItemSellingPricesCompanion(
      id: Value(id),
      itemId: Value(itemId),
      priceLevelName: Value(priceLevelName),
      price: Value(price),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ItemSellingPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemSellingPrice(
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      priceLevelName: serializer.fromJson<String>(json['price_level_name']),
      price: serializer.fromJson<double>(json['price']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_id': serializer.toJson<int>(itemId),
      'price_level_name': serializer.toJson<String>(priceLevelName),
      'price': serializer.toJson<double>(price),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  ItemSellingPrice copyWith(
          {int? id,
          int? itemId,
          String? priceLevelName,
          double? price,
          int? createdAt,
          int? updatedAt}) =>
      ItemSellingPrice(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        priceLevelName: priceLevelName ?? this.priceLevelName,
        price: price ?? this.price,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ItemSellingPrice copyWithCompanion(ItemSellingPricesCompanion data) {
    return ItemSellingPrice(
      id: data.id.present ? data.id.value : this.id,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      priceLevelName: data.priceLevelName.present
          ? data.priceLevelName.value
          : this.priceLevelName,
      price: data.price.present ? data.price.value : this.price,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ItemSellingPrice(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('priceLevelName: $priceLevelName, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, itemId, priceLevelName, price, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemSellingPrice &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.priceLevelName == this.priceLevelName &&
          other.price == this.price &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ItemSellingPricesCompanion extends UpdateCompanion<ItemSellingPrice> {
  final Value<int> id;
  final Value<int> itemId;
  final Value<String> priceLevelName;
  final Value<double> price;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const ItemSellingPricesCompanion({
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.priceLevelName = const Value.absent(),
    this.price = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ItemSellingPricesCompanion.insert({
    this.id = const Value.absent(),
    required int itemId,
    required String priceLevelName,
    required double price,
    required int createdAt,
    required int updatedAt,
  })  : itemId = Value(itemId),
        priceLevelName = Value(priceLevelName),
        price = Value(price),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<ItemSellingPrice> custom({
    Expression<int>? id,
    Expression<int>? itemId,
    Expression<String>? priceLevelName,
    Expression<double>? price,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (priceLevelName != null) 'price_level_name': priceLevelName,
      if (price != null) 'price': price,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ItemSellingPricesCompanion copyWith(
      {Value<int>? id,
      Value<int>? itemId,
      Value<String>? priceLevelName,
      Value<double>? price,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return ItemSellingPricesCompanion(
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      priceLevelName: priceLevelName ?? this.priceLevelName,
      price: price ?? this.price,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (priceLevelName.present) {
      map['price_level_name'] = Variable<String>(priceLevelName.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemSellingPricesCompanion(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('priceLevelName: $priceLevelName, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class ItemPromotionalPrices extends Table
    with TableInfo<ItemPromotionalPrices, ItemPromotionalPrice> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ItemPromotionalPrices(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemSellingPriceIdMeta =
      const VerificationMeta('itemSellingPriceId');
  late final GeneratedColumn<int> itemSellingPriceId = GeneratedColumn<int>(
      'item_selling_price_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL REFERENCES item_selling_prices(id)ON DELETE CASCADE');
  static const VerificationMeta _promoPriceMeta =
      const VerificationMeta('promoPrice');
  late final GeneratedColumn<double> promoPrice = GeneratedColumn<double>(
      'promo_price', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, itemSellingPriceId, promoPrice, startDate, endDate, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_promotional_prices';
  @override
  VerificationContext validateIntegrity(
      Insertable<ItemPromotionalPrice> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_selling_price_id')) {
      context.handle(
          _itemSellingPriceIdMeta,
          itemSellingPriceId.isAcceptableOrUnknown(
              data['item_selling_price_id']!, _itemSellingPriceIdMeta));
    } else if (isInserting) {
      context.missing(_itemSellingPriceIdMeta);
    }
    if (data.containsKey('promo_price')) {
      context.handle(
          _promoPriceMeta,
          promoPrice.isAcceptableOrUnknown(
              data['promo_price']!, _promoPriceMeta));
    } else if (isInserting) {
      context.missing(_promoPriceMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    } else if (isInserting) {
      context.missing(_startDateMeta);
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    } else if (isInserting) {
      context.missing(_endDateMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemPromotionalPrice map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemPromotionalPrice(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemSellingPriceId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}item_selling_price_id'])!,
      promoPrice: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}promo_price'])!,
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date'])!,
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  ItemPromotionalPrices createAlias(String alias) {
    return ItemPromotionalPrices(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class ItemPromotionalPrice extends DataClass
    implements Insertable<ItemPromotionalPrice> {
  final int id;
  final int itemSellingPriceId;
  final double promoPrice;
  final int startDate;
  final int endDate;
  final int createdAt;
  const ItemPromotionalPrice(
      {required this.id,
      required this.itemSellingPriceId,
      required this.promoPrice,
      required this.startDate,
      required this.endDate,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_selling_price_id'] = Variable<int>(itemSellingPriceId);
    map['promo_price'] = Variable<double>(promoPrice);
    map['start_date'] = Variable<int>(startDate);
    map['end_date'] = Variable<int>(endDate);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  ItemPromotionalPricesCompanion toCompanion(bool nullToAbsent) {
    return ItemPromotionalPricesCompanion(
      id: Value(id),
      itemSellingPriceId: Value(itemSellingPriceId),
      promoPrice: Value(promoPrice),
      startDate: Value(startDate),
      endDate: Value(endDate),
      createdAt: Value(createdAt),
    );
  }

  factory ItemPromotionalPrice.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemPromotionalPrice(
      id: serializer.fromJson<int>(json['id']),
      itemSellingPriceId:
          serializer.fromJson<int>(json['item_selling_price_id']),
      promoPrice: serializer.fromJson<double>(json['promo_price']),
      startDate: serializer.fromJson<int>(json['start_date']),
      endDate: serializer.fromJson<int>(json['end_date']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_selling_price_id': serializer.toJson<int>(itemSellingPriceId),
      'promo_price': serializer.toJson<double>(promoPrice),
      'start_date': serializer.toJson<int>(startDate),
      'end_date': serializer.toJson<int>(endDate),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  ItemPromotionalPrice copyWith(
          {int? id,
          int? itemSellingPriceId,
          double? promoPrice,
          int? startDate,
          int? endDate,
          int? createdAt}) =>
      ItemPromotionalPrice(
        id: id ?? this.id,
        itemSellingPriceId: itemSellingPriceId ?? this.itemSellingPriceId,
        promoPrice: promoPrice ?? this.promoPrice,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        createdAt: createdAt ?? this.createdAt,
      );
  ItemPromotionalPrice copyWithCompanion(ItemPromotionalPricesCompanion data) {
    return ItemPromotionalPrice(
      id: data.id.present ? data.id.value : this.id,
      itemSellingPriceId: data.itemSellingPriceId.present
          ? data.itemSellingPriceId.value
          : this.itemSellingPriceId,
      promoPrice:
          data.promoPrice.present ? data.promoPrice.value : this.promoPrice,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ItemPromotionalPrice(')
          ..write('id: $id, ')
          ..write('itemSellingPriceId: $itemSellingPriceId, ')
          ..write('promoPrice: $promoPrice, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, itemSellingPriceId, promoPrice, startDate, endDate, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemPromotionalPrice &&
          other.id == this.id &&
          other.itemSellingPriceId == this.itemSellingPriceId &&
          other.promoPrice == this.promoPrice &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.createdAt == this.createdAt);
}

class ItemPromotionalPricesCompanion
    extends UpdateCompanion<ItemPromotionalPrice> {
  final Value<int> id;
  final Value<int> itemSellingPriceId;
  final Value<double> promoPrice;
  final Value<int> startDate;
  final Value<int> endDate;
  final Value<int> createdAt;
  const ItemPromotionalPricesCompanion({
    this.id = const Value.absent(),
    this.itemSellingPriceId = const Value.absent(),
    this.promoPrice = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  ItemPromotionalPricesCompanion.insert({
    this.id = const Value.absent(),
    required int itemSellingPriceId,
    required double promoPrice,
    required int startDate,
    required int endDate,
    required int createdAt,
  })  : itemSellingPriceId = Value(itemSellingPriceId),
        promoPrice = Value(promoPrice),
        startDate = Value(startDate),
        endDate = Value(endDate),
        createdAt = Value(createdAt);
  static Insertable<ItemPromotionalPrice> custom({
    Expression<int>? id,
    Expression<int>? itemSellingPriceId,
    Expression<double>? promoPrice,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemSellingPriceId != null)
        'item_selling_price_id': itemSellingPriceId,
      if (promoPrice != null) 'promo_price': promoPrice,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  ItemPromotionalPricesCompanion copyWith(
      {Value<int>? id,
      Value<int>? itemSellingPriceId,
      Value<double>? promoPrice,
      Value<int>? startDate,
      Value<int>? endDate,
      Value<int>? createdAt}) {
    return ItemPromotionalPricesCompanion(
      id: id ?? this.id,
      itemSellingPriceId: itemSellingPriceId ?? this.itemSellingPriceId,
      promoPrice: promoPrice ?? this.promoPrice,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemSellingPriceId.present) {
      map['item_selling_price_id'] = Variable<int>(itemSellingPriceId.value);
    }
    if (promoPrice.present) {
      map['promo_price'] = Variable<double>(promoPrice.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemPromotionalPricesCompanion(')
          ..write('id: $id, ')
          ..write('itemSellingPriceId: $itemSellingPriceId, ')
          ..write('promoPrice: $promoPrice, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class ItemAttachments extends Table
    with TableInfo<ItemAttachments, ItemAttachment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ItemAttachments(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)ON DELETE CASCADE');
  static const VerificationMeta _fileNameMeta =
      const VerificationMeta('fileName');
  late final GeneratedColumn<String> fileName = GeneratedColumn<String>(
      'file_name', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _filePathMeta =
      const VerificationMeta('filePath');
  late final GeneratedColumn<String> filePath = GeneratedColumn<String>(
      'file_path', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _fileTypeMeta =
      const VerificationMeta('fileType');
  late final GeneratedColumn<String> fileType = GeneratedColumn<String>(
      'file_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, itemId, fileName, filePath, fileType, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'item_attachments';
  @override
  VerificationContext validateIntegrity(Insertable<ItemAttachment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('file_name')) {
      context.handle(_fileNameMeta,
          fileName.isAcceptableOrUnknown(data['file_name']!, _fileNameMeta));
    } else if (isInserting) {
      context.missing(_fileNameMeta);
    }
    if (data.containsKey('file_path')) {
      context.handle(_filePathMeta,
          filePath.isAcceptableOrUnknown(data['file_path']!, _filePathMeta));
    } else if (isInserting) {
      context.missing(_filePathMeta);
    }
    if (data.containsKey('file_type')) {
      context.handle(_fileTypeMeta,
          fileType.isAcceptableOrUnknown(data['file_type']!, _fileTypeMeta));
    } else if (isInserting) {
      context.missing(_fileTypeMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ItemAttachment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ItemAttachment(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      fileName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}file_name'])!,
      filePath: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}file_path'])!,
      fileType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}file_type'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  ItemAttachments createAlias(String alias) {
    return ItemAttachments(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class ItemAttachment extends DataClass implements Insertable<ItemAttachment> {
  final int id;
  final int itemId;
  final String fileName;
  final String filePath;
  final String fileType;
  final int createdAt;
  const ItemAttachment(
      {required this.id,
      required this.itemId,
      required this.fileName,
      required this.filePath,
      required this.fileType,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<int>(itemId);
    map['file_name'] = Variable<String>(fileName);
    map['file_path'] = Variable<String>(filePath);
    map['file_type'] = Variable<String>(fileType);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  ItemAttachmentsCompanion toCompanion(bool nullToAbsent) {
    return ItemAttachmentsCompanion(
      id: Value(id),
      itemId: Value(itemId),
      fileName: Value(fileName),
      filePath: Value(filePath),
      fileType: Value(fileType),
      createdAt: Value(createdAt),
    );
  }

  factory ItemAttachment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ItemAttachment(
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      fileName: serializer.fromJson<String>(json['file_name']),
      filePath: serializer.fromJson<String>(json['file_path']),
      fileType: serializer.fromJson<String>(json['file_type']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_id': serializer.toJson<int>(itemId),
      'file_name': serializer.toJson<String>(fileName),
      'file_path': serializer.toJson<String>(filePath),
      'file_type': serializer.toJson<String>(fileType),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  ItemAttachment copyWith(
          {int? id,
          int? itemId,
          String? fileName,
          String? filePath,
          String? fileType,
          int? createdAt}) =>
      ItemAttachment(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        fileName: fileName ?? this.fileName,
        filePath: filePath ?? this.filePath,
        fileType: fileType ?? this.fileType,
        createdAt: createdAt ?? this.createdAt,
      );
  ItemAttachment copyWithCompanion(ItemAttachmentsCompanion data) {
    return ItemAttachment(
      id: data.id.present ? data.id.value : this.id,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      fileName: data.fileName.present ? data.fileName.value : this.fileName,
      filePath: data.filePath.present ? data.filePath.value : this.filePath,
      fileType: data.fileType.present ? data.fileType.value : this.fileType,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ItemAttachment(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('fileName: $fileName, ')
          ..write('filePath: $filePath, ')
          ..write('fileType: $fileType, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, itemId, fileName, filePath, fileType, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ItemAttachment &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.fileName == this.fileName &&
          other.filePath == this.filePath &&
          other.fileType == this.fileType &&
          other.createdAt == this.createdAt);
}

class ItemAttachmentsCompanion extends UpdateCompanion<ItemAttachment> {
  final Value<int> id;
  final Value<int> itemId;
  final Value<String> fileName;
  final Value<String> filePath;
  final Value<String> fileType;
  final Value<int> createdAt;
  const ItemAttachmentsCompanion({
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.fileName = const Value.absent(),
    this.filePath = const Value.absent(),
    this.fileType = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  ItemAttachmentsCompanion.insert({
    this.id = const Value.absent(),
    required int itemId,
    required String fileName,
    required String filePath,
    required String fileType,
    required int createdAt,
  })  : itemId = Value(itemId),
        fileName = Value(fileName),
        filePath = Value(filePath),
        fileType = Value(fileType),
        createdAt = Value(createdAt);
  static Insertable<ItemAttachment> custom({
    Expression<int>? id,
    Expression<int>? itemId,
    Expression<String>? fileName,
    Expression<String>? filePath,
    Expression<String>? fileType,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (fileName != null) 'file_name': fileName,
      if (filePath != null) 'file_path': filePath,
      if (fileType != null) 'file_type': fileType,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  ItemAttachmentsCompanion copyWith(
      {Value<int>? id,
      Value<int>? itemId,
      Value<String>? fileName,
      Value<String>? filePath,
      Value<String>? fileType,
      Value<int>? createdAt}) {
    return ItemAttachmentsCompanion(
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      fileName: fileName ?? this.fileName,
      filePath: filePath ?? this.filePath,
      fileType: fileType ?? this.fileType,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (fileName.present) {
      map['file_name'] = Variable<String>(fileName.value);
    }
    if (filePath.present) {
      map['file_path'] = Variable<String>(filePath.value);
    }
    if (fileType.present) {
      map['file_type'] = Variable<String>(fileType.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ItemAttachmentsCompanion(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('fileName: $fileName, ')
          ..write('filePath: $filePath, ')
          ..write('fileType: $fileType, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class StockBalances extends Table with TableInfo<StockBalances, StockBalance> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  StockBalances(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _warehouseIdMeta =
      const VerificationMeta('warehouseId');
  late final GeneratedColumn<int> warehouseId = GeneratedColumn<int>(
      'warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT 0',
      defaultValue: const CustomExpression('0'));
  static const VerificationMeta _reservedQuantityMeta =
      const VerificationMeta('reservedQuantity');
  late final GeneratedColumn<double> reservedQuantity = GeneratedColumn<double>(
      'reserved_quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT 0',
      defaultValue: const CustomExpression('0'));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, itemId, warehouseId, quantity, reservedQuantity, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_balances';
  @override
  VerificationContext validateIntegrity(Insertable<StockBalance> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
          _warehouseIdMeta,
          warehouseId.isAcceptableOrUnknown(
              data['warehouse_id']!, _warehouseIdMeta));
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    }
    if (data.containsKey('reserved_quantity')) {
      context.handle(
          _reservedQuantityMeta,
          reservedQuantity.isAcceptableOrUnknown(
              data['reserved_quantity']!, _reservedQuantityMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {itemId, warehouseId},
      ];
  @override
  StockBalance map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockBalance(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      warehouseId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}warehouse_id'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      reservedQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}reserved_quantity'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  StockBalances createAlias(String alias) {
    return StockBalances(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['UNIQUE(item_id, warehouse_id)'];
  @override
  bool get dontWriteConstraints => true;
}

class StockBalance extends DataClass implements Insertable<StockBalance> {
  final int id;
  final int itemId;
  final int warehouseId;
  final double quantity;
  final double reservedQuantity;
  final int updatedAt;
  const StockBalance(
      {required this.id,
      required this.itemId,
      required this.warehouseId,
      required this.quantity,
      required this.reservedQuantity,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<int>(itemId);
    map['warehouse_id'] = Variable<int>(warehouseId);
    map['quantity'] = Variable<double>(quantity);
    map['reserved_quantity'] = Variable<double>(reservedQuantity);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  StockBalancesCompanion toCompanion(bool nullToAbsent) {
    return StockBalancesCompanion(
      id: Value(id),
      itemId: Value(itemId),
      warehouseId: Value(warehouseId),
      quantity: Value(quantity),
      reservedQuantity: Value(reservedQuantity),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockBalance.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockBalance(
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      warehouseId: serializer.fromJson<int>(json['warehouse_id']),
      quantity: serializer.fromJson<double>(json['quantity']),
      reservedQuantity: serializer.fromJson<double>(json['reserved_quantity']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_id': serializer.toJson<int>(itemId),
      'warehouse_id': serializer.toJson<int>(warehouseId),
      'quantity': serializer.toJson<double>(quantity),
      'reserved_quantity': serializer.toJson<double>(reservedQuantity),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  StockBalance copyWith(
          {int? id,
          int? itemId,
          int? warehouseId,
          double? quantity,
          double? reservedQuantity,
          int? updatedAt}) =>
      StockBalance(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        warehouseId: warehouseId ?? this.warehouseId,
        quantity: quantity ?? this.quantity,
        reservedQuantity: reservedQuantity ?? this.reservedQuantity,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockBalance copyWithCompanion(StockBalancesCompanion data) {
    return StockBalance(
      id: data.id.present ? data.id.value : this.id,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      warehouseId:
          data.warehouseId.present ? data.warehouseId.value : this.warehouseId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      reservedQuantity: data.reservedQuantity.present
          ? data.reservedQuantity.value
          : this.reservedQuantity,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockBalance(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('quantity: $quantity, ')
          ..write('reservedQuantity: $reservedQuantity, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, itemId, warehouseId, quantity, reservedQuantity, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockBalance &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.warehouseId == this.warehouseId &&
          other.quantity == this.quantity &&
          other.reservedQuantity == this.reservedQuantity &&
          other.updatedAt == this.updatedAt);
}

class StockBalancesCompanion extends UpdateCompanion<StockBalance> {
  final Value<int> id;
  final Value<int> itemId;
  final Value<int> warehouseId;
  final Value<double> quantity;
  final Value<double> reservedQuantity;
  final Value<int> updatedAt;
  const StockBalancesCompanion({
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.reservedQuantity = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockBalancesCompanion.insert({
    this.id = const Value.absent(),
    required int itemId,
    required int warehouseId,
    this.quantity = const Value.absent(),
    this.reservedQuantity = const Value.absent(),
    required int updatedAt,
  })  : itemId = Value(itemId),
        warehouseId = Value(warehouseId),
        updatedAt = Value(updatedAt);
  static Insertable<StockBalance> custom({
    Expression<int>? id,
    Expression<int>? itemId,
    Expression<int>? warehouseId,
    Expression<double>? quantity,
    Expression<double>? reservedQuantity,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (quantity != null) 'quantity': quantity,
      if (reservedQuantity != null) 'reserved_quantity': reservedQuantity,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockBalancesCompanion copyWith(
      {Value<int>? id,
      Value<int>? itemId,
      Value<int>? warehouseId,
      Value<double>? quantity,
      Value<double>? reservedQuantity,
      Value<int>? updatedAt}) {
    return StockBalancesCompanion(
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      warehouseId: warehouseId ?? this.warehouseId,
      quantity: quantity ?? this.quantity,
      reservedQuantity: reservedQuantity ?? this.reservedQuantity,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<int>(warehouseId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (reservedQuantity.present) {
      map['reserved_quantity'] = Variable<double>(reservedQuantity.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockBalancesCompanion(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('quantity: $quantity, ')
          ..write('reservedQuantity: $reservedQuantity, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class StockTransactions extends Table
    with TableInfo<StockTransactions, StockTransaction> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  StockTransactions(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _transactionTypeMeta =
      const VerificationMeta('transactionType');
  late final GeneratedColumn<String> transactionType = GeneratedColumn<String>(
      'transaction_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL CHECK (transaction_type IN (\'Opening\', \'Incoming\', \'Outgoing\', \'Transfer\', \'Adjustment\'))');
  static const VerificationMeta _docNoMeta = const VerificationMeta('docNo');
  late final GeneratedColumn<String> docNo = GeneratedColumn<String>(
      'doc_no', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _docDateMeta =
      const VerificationMeta('docDate');
  late final GeneratedColumn<int> docDate = GeneratedColumn<int>(
      'doc_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _warehouseIdMeta =
      const VerificationMeta('warehouseId');
  late final GeneratedColumn<int> warehouseId = GeneratedColumn<int>(
      'warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _totalCostMeta =
      const VerificationMeta('totalCost');
  late final GeneratedColumn<double> totalCost = GeneratedColumn<double>(
      'total_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _expiryDateMeta =
      const VerificationMeta('expiryDate');
  late final GeneratedColumn<int> expiryDate = GeneratedColumn<int>(
      'expiry_date', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _batchNumberMeta =
      const VerificationMeta('batchNumber');
  late final GeneratedColumn<String> batchNumber = GeneratedColumn<String>(
      'batch_number', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _referenceDocNoMeta =
      const VerificationMeta('referenceDocNo');
  late final GeneratedColumn<String> referenceDocNo = GeneratedColumn<String>(
      'reference_doc_no', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'NOT NULL CHECK (status IN (\'Draft\', \'Posted\')) DEFAULT \'Draft\'',
      defaultValue: const CustomExpression('\'Draft\''));
  static const VerificationMeta _postedAtMeta =
      const VerificationMeta('postedAt');
  late final GeneratedColumn<int> postedAt = GeneratedColumn<int>(
      'posted_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _postedByMeta =
      const VerificationMeta('postedBy');
  late final GeneratedColumn<String> postedBy = GeneratedColumn<String>(
      'posted_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        transactionType,
        docNo,
        docDate,
        warehouseId,
        itemId,
        quantity,
        unitCost,
        totalCost,
        expiryDate,
        batchNumber,
        referenceDocNo,
        notes,
        status,
        postedAt,
        postedBy,
        createdBy,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_transactions';
  @override
  VerificationContext validateIntegrity(Insertable<StockTransaction> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('transaction_type')) {
      context.handle(
          _transactionTypeMeta,
          transactionType.isAcceptableOrUnknown(
              data['transaction_type']!, _transactionTypeMeta));
    } else if (isInserting) {
      context.missing(_transactionTypeMeta);
    }
    if (data.containsKey('doc_no')) {
      context.handle(
          _docNoMeta, docNo.isAcceptableOrUnknown(data['doc_no']!, _docNoMeta));
    } else if (isInserting) {
      context.missing(_docNoMeta);
    }
    if (data.containsKey('doc_date')) {
      context.handle(_docDateMeta,
          docDate.isAcceptableOrUnknown(data['doc_date']!, _docDateMeta));
    } else if (isInserting) {
      context.missing(_docDateMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
          _warehouseIdMeta,
          warehouseId.isAcceptableOrUnknown(
              data['warehouse_id']!, _warehouseIdMeta));
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    if (data.containsKey('total_cost')) {
      context.handle(_totalCostMeta,
          totalCost.isAcceptableOrUnknown(data['total_cost']!, _totalCostMeta));
    } else if (isInserting) {
      context.missing(_totalCostMeta);
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
          _expiryDateMeta,
          expiryDate.isAcceptableOrUnknown(
              data['expiry_date']!, _expiryDateMeta));
    }
    if (data.containsKey('batch_number')) {
      context.handle(
          _batchNumberMeta,
          batchNumber.isAcceptableOrUnknown(
              data['batch_number']!, _batchNumberMeta));
    }
    if (data.containsKey('reference_doc_no')) {
      context.handle(
          _referenceDocNoMeta,
          referenceDocNo.isAcceptableOrUnknown(
              data['reference_doc_no']!, _referenceDocNoMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('posted_at')) {
      context.handle(_postedAtMeta,
          postedAt.isAcceptableOrUnknown(data['posted_at']!, _postedAtMeta));
    }
    if (data.containsKey('posted_by')) {
      context.handle(_postedByMeta,
          postedBy.isAcceptableOrUnknown(data['posted_by']!, _postedByMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockTransaction map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockTransaction(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      transactionType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}transaction_type'])!,
      docNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}doc_no'])!,
      docDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}doc_date'])!,
      warehouseId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}warehouse_id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
      totalCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_cost'])!,
      expiryDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}expiry_date']),
      batchNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}batch_number']),
      referenceDocNo: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reference_doc_no']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      postedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}posted_at']),
      postedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}posted_by']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  StockTransactions createAlias(String alias) {
    return StockTransactions(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class StockTransaction extends DataClass
    implements Insertable<StockTransaction> {
  final int id;
  final String transactionType;
  final String docNo;
  final int docDate;
  final int warehouseId;
  final int itemId;
  final double quantity;
  final double unitCost;
  final double totalCost;
  final int? expiryDate;
  final String? batchNumber;
  final String? referenceDocNo;
  final String? notes;
  final String status;
  final int? postedAt;
  final String? postedBy;
  final String createdBy;
  final int createdAt;
  final int updatedAt;
  const StockTransaction(
      {required this.id,
      required this.transactionType,
      required this.docNo,
      required this.docDate,
      required this.warehouseId,
      required this.itemId,
      required this.quantity,
      required this.unitCost,
      required this.totalCost,
      this.expiryDate,
      this.batchNumber,
      this.referenceDocNo,
      this.notes,
      required this.status,
      this.postedAt,
      this.postedBy,
      required this.createdBy,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['transaction_type'] = Variable<String>(transactionType);
    map['doc_no'] = Variable<String>(docNo);
    map['doc_date'] = Variable<int>(docDate);
    map['warehouse_id'] = Variable<int>(warehouseId);
    map['item_id'] = Variable<int>(itemId);
    map['quantity'] = Variable<double>(quantity);
    map['unit_cost'] = Variable<double>(unitCost);
    map['total_cost'] = Variable<double>(totalCost);
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<int>(expiryDate);
    }
    if (!nullToAbsent || batchNumber != null) {
      map['batch_number'] = Variable<String>(batchNumber);
    }
    if (!nullToAbsent || referenceDocNo != null) {
      map['reference_doc_no'] = Variable<String>(referenceDocNo);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || postedAt != null) {
      map['posted_at'] = Variable<int>(postedAt);
    }
    if (!nullToAbsent || postedBy != null) {
      map['posted_by'] = Variable<String>(postedBy);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  StockTransactionsCompanion toCompanion(bool nullToAbsent) {
    return StockTransactionsCompanion(
      id: Value(id),
      transactionType: Value(transactionType),
      docNo: Value(docNo),
      docDate: Value(docDate),
      warehouseId: Value(warehouseId),
      itemId: Value(itemId),
      quantity: Value(quantity),
      unitCost: Value(unitCost),
      totalCost: Value(totalCost),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      batchNumber: batchNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(batchNumber),
      referenceDocNo: referenceDocNo == null && nullToAbsent
          ? const Value.absent()
          : Value(referenceDocNo),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      status: Value(status),
      postedAt: postedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(postedAt),
      postedBy: postedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(postedBy),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockTransaction.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockTransaction(
      id: serializer.fromJson<int>(json['id']),
      transactionType: serializer.fromJson<String>(json['transaction_type']),
      docNo: serializer.fromJson<String>(json['doc_no']),
      docDate: serializer.fromJson<int>(json['doc_date']),
      warehouseId: serializer.fromJson<int>(json['warehouse_id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitCost: serializer.fromJson<double>(json['unit_cost']),
      totalCost: serializer.fromJson<double>(json['total_cost']),
      expiryDate: serializer.fromJson<int?>(json['expiry_date']),
      batchNumber: serializer.fromJson<String?>(json['batch_number']),
      referenceDocNo: serializer.fromJson<String?>(json['reference_doc_no']),
      notes: serializer.fromJson<String?>(json['notes']),
      status: serializer.fromJson<String>(json['status']),
      postedAt: serializer.fromJson<int?>(json['posted_at']),
      postedBy: serializer.fromJson<String?>(json['posted_by']),
      createdBy: serializer.fromJson<String>(json['created_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'transaction_type': serializer.toJson<String>(transactionType),
      'doc_no': serializer.toJson<String>(docNo),
      'doc_date': serializer.toJson<int>(docDate),
      'warehouse_id': serializer.toJson<int>(warehouseId),
      'item_id': serializer.toJson<int>(itemId),
      'quantity': serializer.toJson<double>(quantity),
      'unit_cost': serializer.toJson<double>(unitCost),
      'total_cost': serializer.toJson<double>(totalCost),
      'expiry_date': serializer.toJson<int?>(expiryDate),
      'batch_number': serializer.toJson<String?>(batchNumber),
      'reference_doc_no': serializer.toJson<String?>(referenceDocNo),
      'notes': serializer.toJson<String?>(notes),
      'status': serializer.toJson<String>(status),
      'posted_at': serializer.toJson<int?>(postedAt),
      'posted_by': serializer.toJson<String?>(postedBy),
      'created_by': serializer.toJson<String>(createdBy),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  StockTransaction copyWith(
          {int? id,
          String? transactionType,
          String? docNo,
          int? docDate,
          int? warehouseId,
          int? itemId,
          double? quantity,
          double? unitCost,
          double? totalCost,
          Value<int?> expiryDate = const Value.absent(),
          Value<String?> batchNumber = const Value.absent(),
          Value<String?> referenceDocNo = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          String? status,
          Value<int?> postedAt = const Value.absent(),
          Value<String?> postedBy = const Value.absent(),
          String? createdBy,
          int? createdAt,
          int? updatedAt}) =>
      StockTransaction(
        id: id ?? this.id,
        transactionType: transactionType ?? this.transactionType,
        docNo: docNo ?? this.docNo,
        docDate: docDate ?? this.docDate,
        warehouseId: warehouseId ?? this.warehouseId,
        itemId: itemId ?? this.itemId,
        quantity: quantity ?? this.quantity,
        unitCost: unitCost ?? this.unitCost,
        totalCost: totalCost ?? this.totalCost,
        expiryDate: expiryDate.present ? expiryDate.value : this.expiryDate,
        batchNumber: batchNumber.present ? batchNumber.value : this.batchNumber,
        referenceDocNo:
            referenceDocNo.present ? referenceDocNo.value : this.referenceDocNo,
        notes: notes.present ? notes.value : this.notes,
        status: status ?? this.status,
        postedAt: postedAt.present ? postedAt.value : this.postedAt,
        postedBy: postedBy.present ? postedBy.value : this.postedBy,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockTransaction copyWithCompanion(StockTransactionsCompanion data) {
    return StockTransaction(
      id: data.id.present ? data.id.value : this.id,
      transactionType: data.transactionType.present
          ? data.transactionType.value
          : this.transactionType,
      docNo: data.docNo.present ? data.docNo.value : this.docNo,
      docDate: data.docDate.present ? data.docDate.value : this.docDate,
      warehouseId:
          data.warehouseId.present ? data.warehouseId.value : this.warehouseId,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      totalCost: data.totalCost.present ? data.totalCost.value : this.totalCost,
      expiryDate:
          data.expiryDate.present ? data.expiryDate.value : this.expiryDate,
      batchNumber:
          data.batchNumber.present ? data.batchNumber.value : this.batchNumber,
      referenceDocNo: data.referenceDocNo.present
          ? data.referenceDocNo.value
          : this.referenceDocNo,
      notes: data.notes.present ? data.notes.value : this.notes,
      status: data.status.present ? data.status.value : this.status,
      postedAt: data.postedAt.present ? data.postedAt.value : this.postedAt,
      postedBy: data.postedBy.present ? data.postedBy.value : this.postedBy,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockTransaction(')
          ..write('id: $id, ')
          ..write('transactionType: $transactionType, ')
          ..write('docNo: $docNo, ')
          ..write('docDate: $docDate, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('batchNumber: $batchNumber, ')
          ..write('referenceDocNo: $referenceDocNo, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      transactionType,
      docNo,
      docDate,
      warehouseId,
      itemId,
      quantity,
      unitCost,
      totalCost,
      expiryDate,
      batchNumber,
      referenceDocNo,
      notes,
      status,
      postedAt,
      postedBy,
      createdBy,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockTransaction &&
          other.id == this.id &&
          other.transactionType == this.transactionType &&
          other.docNo == this.docNo &&
          other.docDate == this.docDate &&
          other.warehouseId == this.warehouseId &&
          other.itemId == this.itemId &&
          other.quantity == this.quantity &&
          other.unitCost == this.unitCost &&
          other.totalCost == this.totalCost &&
          other.expiryDate == this.expiryDate &&
          other.batchNumber == this.batchNumber &&
          other.referenceDocNo == this.referenceDocNo &&
          other.notes == this.notes &&
          other.status == this.status &&
          other.postedAt == this.postedAt &&
          other.postedBy == this.postedBy &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StockTransactionsCompanion extends UpdateCompanion<StockTransaction> {
  final Value<int> id;
  final Value<String> transactionType;
  final Value<String> docNo;
  final Value<int> docDate;
  final Value<int> warehouseId;
  final Value<int> itemId;
  final Value<double> quantity;
  final Value<double> unitCost;
  final Value<double> totalCost;
  final Value<int?> expiryDate;
  final Value<String?> batchNumber;
  final Value<String?> referenceDocNo;
  final Value<String?> notes;
  final Value<String> status;
  final Value<int?> postedAt;
  final Value<String?> postedBy;
  final Value<String> createdBy;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const StockTransactionsCompanion({
    this.id = const Value.absent(),
    this.transactionType = const Value.absent(),
    this.docNo = const Value.absent(),
    this.docDate = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.itemId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.batchNumber = const Value.absent(),
    this.referenceDocNo = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockTransactionsCompanion.insert({
    this.id = const Value.absent(),
    required String transactionType,
    required String docNo,
    required int docDate,
    required int warehouseId,
    required int itemId,
    required double quantity,
    required double unitCost,
    required double totalCost,
    this.expiryDate = const Value.absent(),
    this.batchNumber = const Value.absent(),
    this.referenceDocNo = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    required String createdBy,
    required int createdAt,
    required int updatedAt,
  })  : transactionType = Value(transactionType),
        docNo = Value(docNo),
        docDate = Value(docDate),
        warehouseId = Value(warehouseId),
        itemId = Value(itemId),
        quantity = Value(quantity),
        unitCost = Value(unitCost),
        totalCost = Value(totalCost),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<StockTransaction> custom({
    Expression<int>? id,
    Expression<String>? transactionType,
    Expression<String>? docNo,
    Expression<int>? docDate,
    Expression<int>? warehouseId,
    Expression<int>? itemId,
    Expression<double>? quantity,
    Expression<double>? unitCost,
    Expression<double>? totalCost,
    Expression<int>? expiryDate,
    Expression<String>? batchNumber,
    Expression<String>? referenceDocNo,
    Expression<String>? notes,
    Expression<String>? status,
    Expression<int>? postedAt,
    Expression<String>? postedBy,
    Expression<String>? createdBy,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (transactionType != null) 'transaction_type': transactionType,
      if (docNo != null) 'doc_no': docNo,
      if (docDate != null) 'doc_date': docDate,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (itemId != null) 'item_id': itemId,
      if (quantity != null) 'quantity': quantity,
      if (unitCost != null) 'unit_cost': unitCost,
      if (totalCost != null) 'total_cost': totalCost,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (batchNumber != null) 'batch_number': batchNumber,
      if (referenceDocNo != null) 'reference_doc_no': referenceDocNo,
      if (notes != null) 'notes': notes,
      if (status != null) 'status': status,
      if (postedAt != null) 'posted_at': postedAt,
      if (postedBy != null) 'posted_by': postedBy,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockTransactionsCompanion copyWith(
      {Value<int>? id,
      Value<String>? transactionType,
      Value<String>? docNo,
      Value<int>? docDate,
      Value<int>? warehouseId,
      Value<int>? itemId,
      Value<double>? quantity,
      Value<double>? unitCost,
      Value<double>? totalCost,
      Value<int?>? expiryDate,
      Value<String?>? batchNumber,
      Value<String?>? referenceDocNo,
      Value<String?>? notes,
      Value<String>? status,
      Value<int?>? postedAt,
      Value<String?>? postedBy,
      Value<String>? createdBy,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return StockTransactionsCompanion(
      id: id ?? this.id,
      transactionType: transactionType ?? this.transactionType,
      docNo: docNo ?? this.docNo,
      docDate: docDate ?? this.docDate,
      warehouseId: warehouseId ?? this.warehouseId,
      itemId: itemId ?? this.itemId,
      quantity: quantity ?? this.quantity,
      unitCost: unitCost ?? this.unitCost,
      totalCost: totalCost ?? this.totalCost,
      expiryDate: expiryDate ?? this.expiryDate,
      batchNumber: batchNumber ?? this.batchNumber,
      referenceDocNo: referenceDocNo ?? this.referenceDocNo,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      postedAt: postedAt ?? this.postedAt,
      postedBy: postedBy ?? this.postedBy,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transactionType.present) {
      map['transaction_type'] = Variable<String>(transactionType.value);
    }
    if (docNo.present) {
      map['doc_no'] = Variable<String>(docNo.value);
    }
    if (docDate.present) {
      map['doc_date'] = Variable<int>(docDate.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<int>(warehouseId.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (totalCost.present) {
      map['total_cost'] = Variable<double>(totalCost.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<int>(expiryDate.value);
    }
    if (batchNumber.present) {
      map['batch_number'] = Variable<String>(batchNumber.value);
    }
    if (referenceDocNo.present) {
      map['reference_doc_no'] = Variable<String>(referenceDocNo.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (postedAt.present) {
      map['posted_at'] = Variable<int>(postedAt.value);
    }
    if (postedBy.present) {
      map['posted_by'] = Variable<String>(postedBy.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockTransactionsCompanion(')
          ..write('id: $id, ')
          ..write('transactionType: $transactionType, ')
          ..write('docNo: $docNo, ')
          ..write('docDate: $docDate, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('batchNumber: $batchNumber, ')
          ..write('referenceDocNo: $referenceDocNo, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class IncomingStockOrders extends Table
    with TableInfo<IncomingStockOrders, IncomingStockOrder> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  IncomingStockOrders(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _docNoMeta = const VerificationMeta('docNo');
  late final GeneratedColumn<String> docNo = GeneratedColumn<String>(
      'doc_no', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _docDateMeta =
      const VerificationMeta('docDate');
  late final GeneratedColumn<int> docDate = GeneratedColumn<int>(
      'doc_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _warehouseIdMeta =
      const VerificationMeta('warehouseId');
  late final GeneratedColumn<int> warehouseId = GeneratedColumn<int>(
      'warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _supplierIdMeta =
      const VerificationMeta('supplierId');
  late final GeneratedColumn<String> supplierId = GeneratedColumn<String>(
      'supplier_id', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _refNoMeta = const VerificationMeta('refNo');
  late final GeneratedColumn<String> refNo = GeneratedColumn<String>(
      'ref_no', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'NOT NULL CHECK (status IN (\'Draft\', \'Posted\')) DEFAULT \'Draft\'',
      defaultValue: const CustomExpression('\'Draft\''));
  static const VerificationMeta _postedAtMeta =
      const VerificationMeta('postedAt');
  late final GeneratedColumn<int> postedAt = GeneratedColumn<int>(
      'posted_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _postedByMeta =
      const VerificationMeta('postedBy');
  late final GeneratedColumn<String> postedBy = GeneratedColumn<String>(
      'posted_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        docNo,
        docDate,
        warehouseId,
        supplierId,
        refNo,
        notes,
        status,
        postedAt,
        postedBy,
        createdBy,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'incoming_stock_orders';
  @override
  VerificationContext validateIntegrity(Insertable<IncomingStockOrder> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('doc_no')) {
      context.handle(
          _docNoMeta, docNo.isAcceptableOrUnknown(data['doc_no']!, _docNoMeta));
    } else if (isInserting) {
      context.missing(_docNoMeta);
    }
    if (data.containsKey('doc_date')) {
      context.handle(_docDateMeta,
          docDate.isAcceptableOrUnknown(data['doc_date']!, _docDateMeta));
    } else if (isInserting) {
      context.missing(_docDateMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
          _warehouseIdMeta,
          warehouseId.isAcceptableOrUnknown(
              data['warehouse_id']!, _warehouseIdMeta));
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('supplier_id')) {
      context.handle(
          _supplierIdMeta,
          supplierId.isAcceptableOrUnknown(
              data['supplier_id']!, _supplierIdMeta));
    }
    if (data.containsKey('ref_no')) {
      context.handle(
          _refNoMeta, refNo.isAcceptableOrUnknown(data['ref_no']!, _refNoMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('posted_at')) {
      context.handle(_postedAtMeta,
          postedAt.isAcceptableOrUnknown(data['posted_at']!, _postedAtMeta));
    }
    if (data.containsKey('posted_by')) {
      context.handle(_postedByMeta,
          postedBy.isAcceptableOrUnknown(data['posted_by']!, _postedByMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  IncomingStockOrder map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IncomingStockOrder(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      docNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}doc_no'])!,
      docDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}doc_date'])!,
      warehouseId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}warehouse_id'])!,
      supplierId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}supplier_id']),
      refNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref_no']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      postedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}posted_at']),
      postedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}posted_by']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  IncomingStockOrders createAlias(String alias) {
    return IncomingStockOrders(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class IncomingStockOrder extends DataClass
    implements Insertable<IncomingStockOrder> {
  final int id;
  final String docNo;
  final int docDate;
  final int warehouseId;
  final String? supplierId;
  final String? refNo;
  final String? notes;
  final String status;
  final int? postedAt;
  final String? postedBy;
  final String createdBy;
  final int createdAt;
  final int updatedAt;
  const IncomingStockOrder(
      {required this.id,
      required this.docNo,
      required this.docDate,
      required this.warehouseId,
      this.supplierId,
      this.refNo,
      this.notes,
      required this.status,
      this.postedAt,
      this.postedBy,
      required this.createdBy,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['doc_no'] = Variable<String>(docNo);
    map['doc_date'] = Variable<int>(docDate);
    map['warehouse_id'] = Variable<int>(warehouseId);
    if (!nullToAbsent || supplierId != null) {
      map['supplier_id'] = Variable<String>(supplierId);
    }
    if (!nullToAbsent || refNo != null) {
      map['ref_no'] = Variable<String>(refNo);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || postedAt != null) {
      map['posted_at'] = Variable<int>(postedAt);
    }
    if (!nullToAbsent || postedBy != null) {
      map['posted_by'] = Variable<String>(postedBy);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  IncomingStockOrdersCompanion toCompanion(bool nullToAbsent) {
    return IncomingStockOrdersCompanion(
      id: Value(id),
      docNo: Value(docNo),
      docDate: Value(docDate),
      warehouseId: Value(warehouseId),
      supplierId: supplierId == null && nullToAbsent
          ? const Value.absent()
          : Value(supplierId),
      refNo:
          refNo == null && nullToAbsent ? const Value.absent() : Value(refNo),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      status: Value(status),
      postedAt: postedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(postedAt),
      postedBy: postedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(postedBy),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory IncomingStockOrder.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IncomingStockOrder(
      id: serializer.fromJson<int>(json['id']),
      docNo: serializer.fromJson<String>(json['doc_no']),
      docDate: serializer.fromJson<int>(json['doc_date']),
      warehouseId: serializer.fromJson<int>(json['warehouse_id']),
      supplierId: serializer.fromJson<String?>(json['supplier_id']),
      refNo: serializer.fromJson<String?>(json['ref_no']),
      notes: serializer.fromJson<String?>(json['notes']),
      status: serializer.fromJson<String>(json['status']),
      postedAt: serializer.fromJson<int?>(json['posted_at']),
      postedBy: serializer.fromJson<String?>(json['posted_by']),
      createdBy: serializer.fromJson<String>(json['created_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'doc_no': serializer.toJson<String>(docNo),
      'doc_date': serializer.toJson<int>(docDate),
      'warehouse_id': serializer.toJson<int>(warehouseId),
      'supplier_id': serializer.toJson<String?>(supplierId),
      'ref_no': serializer.toJson<String?>(refNo),
      'notes': serializer.toJson<String?>(notes),
      'status': serializer.toJson<String>(status),
      'posted_at': serializer.toJson<int?>(postedAt),
      'posted_by': serializer.toJson<String?>(postedBy),
      'created_by': serializer.toJson<String>(createdBy),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  IncomingStockOrder copyWith(
          {int? id,
          String? docNo,
          int? docDate,
          int? warehouseId,
          Value<String?> supplierId = const Value.absent(),
          Value<String?> refNo = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          String? status,
          Value<int?> postedAt = const Value.absent(),
          Value<String?> postedBy = const Value.absent(),
          String? createdBy,
          int? createdAt,
          int? updatedAt}) =>
      IncomingStockOrder(
        id: id ?? this.id,
        docNo: docNo ?? this.docNo,
        docDate: docDate ?? this.docDate,
        warehouseId: warehouseId ?? this.warehouseId,
        supplierId: supplierId.present ? supplierId.value : this.supplierId,
        refNo: refNo.present ? refNo.value : this.refNo,
        notes: notes.present ? notes.value : this.notes,
        status: status ?? this.status,
        postedAt: postedAt.present ? postedAt.value : this.postedAt,
        postedBy: postedBy.present ? postedBy.value : this.postedBy,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  IncomingStockOrder copyWithCompanion(IncomingStockOrdersCompanion data) {
    return IncomingStockOrder(
      id: data.id.present ? data.id.value : this.id,
      docNo: data.docNo.present ? data.docNo.value : this.docNo,
      docDate: data.docDate.present ? data.docDate.value : this.docDate,
      warehouseId:
          data.warehouseId.present ? data.warehouseId.value : this.warehouseId,
      supplierId:
          data.supplierId.present ? data.supplierId.value : this.supplierId,
      refNo: data.refNo.present ? data.refNo.value : this.refNo,
      notes: data.notes.present ? data.notes.value : this.notes,
      status: data.status.present ? data.status.value : this.status,
      postedAt: data.postedAt.present ? data.postedAt.value : this.postedAt,
      postedBy: data.postedBy.present ? data.postedBy.value : this.postedBy,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('IncomingStockOrder(')
          ..write('id: $id, ')
          ..write('docNo: $docNo, ')
          ..write('docDate: $docDate, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('supplierId: $supplierId, ')
          ..write('refNo: $refNo, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      docNo,
      docDate,
      warehouseId,
      supplierId,
      refNo,
      notes,
      status,
      postedAt,
      postedBy,
      createdBy,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IncomingStockOrder &&
          other.id == this.id &&
          other.docNo == this.docNo &&
          other.docDate == this.docDate &&
          other.warehouseId == this.warehouseId &&
          other.supplierId == this.supplierId &&
          other.refNo == this.refNo &&
          other.notes == this.notes &&
          other.status == this.status &&
          other.postedAt == this.postedAt &&
          other.postedBy == this.postedBy &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class IncomingStockOrdersCompanion extends UpdateCompanion<IncomingStockOrder> {
  final Value<int> id;
  final Value<String> docNo;
  final Value<int> docDate;
  final Value<int> warehouseId;
  final Value<String?> supplierId;
  final Value<String?> refNo;
  final Value<String?> notes;
  final Value<String> status;
  final Value<int?> postedAt;
  final Value<String?> postedBy;
  final Value<String> createdBy;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const IncomingStockOrdersCompanion({
    this.id = const Value.absent(),
    this.docNo = const Value.absent(),
    this.docDate = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.supplierId = const Value.absent(),
    this.refNo = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  IncomingStockOrdersCompanion.insert({
    this.id = const Value.absent(),
    required String docNo,
    required int docDate,
    required int warehouseId,
    this.supplierId = const Value.absent(),
    this.refNo = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    required String createdBy,
    required int createdAt,
    required int updatedAt,
  })  : docNo = Value(docNo),
        docDate = Value(docDate),
        warehouseId = Value(warehouseId),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<IncomingStockOrder> custom({
    Expression<int>? id,
    Expression<String>? docNo,
    Expression<int>? docDate,
    Expression<int>? warehouseId,
    Expression<String>? supplierId,
    Expression<String>? refNo,
    Expression<String>? notes,
    Expression<String>? status,
    Expression<int>? postedAt,
    Expression<String>? postedBy,
    Expression<String>? createdBy,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (docNo != null) 'doc_no': docNo,
      if (docDate != null) 'doc_date': docDate,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (supplierId != null) 'supplier_id': supplierId,
      if (refNo != null) 'ref_no': refNo,
      if (notes != null) 'notes': notes,
      if (status != null) 'status': status,
      if (postedAt != null) 'posted_at': postedAt,
      if (postedBy != null) 'posted_by': postedBy,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  IncomingStockOrdersCompanion copyWith(
      {Value<int>? id,
      Value<String>? docNo,
      Value<int>? docDate,
      Value<int>? warehouseId,
      Value<String?>? supplierId,
      Value<String?>? refNo,
      Value<String?>? notes,
      Value<String>? status,
      Value<int?>? postedAt,
      Value<String?>? postedBy,
      Value<String>? createdBy,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return IncomingStockOrdersCompanion(
      id: id ?? this.id,
      docNo: docNo ?? this.docNo,
      docDate: docDate ?? this.docDate,
      warehouseId: warehouseId ?? this.warehouseId,
      supplierId: supplierId ?? this.supplierId,
      refNo: refNo ?? this.refNo,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      postedAt: postedAt ?? this.postedAt,
      postedBy: postedBy ?? this.postedBy,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (docNo.present) {
      map['doc_no'] = Variable<String>(docNo.value);
    }
    if (docDate.present) {
      map['doc_date'] = Variable<int>(docDate.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<int>(warehouseId.value);
    }
    if (supplierId.present) {
      map['supplier_id'] = Variable<String>(supplierId.value);
    }
    if (refNo.present) {
      map['ref_no'] = Variable<String>(refNo.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (postedAt.present) {
      map['posted_at'] = Variable<int>(postedAt.value);
    }
    if (postedBy.present) {
      map['posted_by'] = Variable<String>(postedBy.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IncomingStockOrdersCompanion(')
          ..write('id: $id, ')
          ..write('docNo: $docNo, ')
          ..write('docDate: $docDate, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('supplierId: $supplierId, ')
          ..write('refNo: $refNo, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class IncomingStockOrderLines extends Table
    with TableInfo<IncomingStockOrderLines, IncomingStockOrderLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  IncomingStockOrderLines(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _orderIdMeta =
      const VerificationMeta('orderId');
  late final GeneratedColumn<int> orderId = GeneratedColumn<int>(
      'order_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL REFERENCES incoming_stock_orders(id)ON DELETE CASCADE');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _totalCostMeta =
      const VerificationMeta('totalCost');
  late final GeneratedColumn<double> totalCost = GeneratedColumn<double>(
      'total_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _expiryDateMeta =
      const VerificationMeta('expiryDate');
  late final GeneratedColumn<int> expiryDate = GeneratedColumn<int>(
      'expiry_date', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _batchNumberMeta =
      const VerificationMeta('batchNumber');
  late final GeneratedColumn<String> batchNumber = GeneratedColumn<String>(
      'batch_number', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        orderId,
        itemId,
        quantity,
        unitCost,
        totalCost,
        expiryDate,
        batchNumber,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'incoming_stock_order_lines';
  @override
  VerificationContext validateIntegrity(
      Insertable<IncomingStockOrderLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('order_id')) {
      context.handle(_orderIdMeta,
          orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta));
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    if (data.containsKey('total_cost')) {
      context.handle(_totalCostMeta,
          totalCost.isAcceptableOrUnknown(data['total_cost']!, _totalCostMeta));
    } else if (isInserting) {
      context.missing(_totalCostMeta);
    }
    if (data.containsKey('expiry_date')) {
      context.handle(
          _expiryDateMeta,
          expiryDate.isAcceptableOrUnknown(
              data['expiry_date']!, _expiryDateMeta));
    }
    if (data.containsKey('batch_number')) {
      context.handle(
          _batchNumberMeta,
          batchNumber.isAcceptableOrUnknown(
              data['batch_number']!, _batchNumberMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  IncomingStockOrderLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return IncomingStockOrderLine(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      orderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order_id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
      totalCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_cost'])!,
      expiryDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}expiry_date']),
      batchNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}batch_number']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  IncomingStockOrderLines createAlias(String alias) {
    return IncomingStockOrderLines(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class IncomingStockOrderLine extends DataClass
    implements Insertable<IncomingStockOrderLine> {
  final int id;
  final int orderId;
  final int itemId;
  final double quantity;
  final double unitCost;
  final double totalCost;
  final int? expiryDate;
  final String? batchNumber;
  final int createdAt;
  const IncomingStockOrderLine(
      {required this.id,
      required this.orderId,
      required this.itemId,
      required this.quantity,
      required this.unitCost,
      required this.totalCost,
      this.expiryDate,
      this.batchNumber,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['order_id'] = Variable<int>(orderId);
    map['item_id'] = Variable<int>(itemId);
    map['quantity'] = Variable<double>(quantity);
    map['unit_cost'] = Variable<double>(unitCost);
    map['total_cost'] = Variable<double>(totalCost);
    if (!nullToAbsent || expiryDate != null) {
      map['expiry_date'] = Variable<int>(expiryDate);
    }
    if (!nullToAbsent || batchNumber != null) {
      map['batch_number'] = Variable<String>(batchNumber);
    }
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  IncomingStockOrderLinesCompanion toCompanion(bool nullToAbsent) {
    return IncomingStockOrderLinesCompanion(
      id: Value(id),
      orderId: Value(orderId),
      itemId: Value(itemId),
      quantity: Value(quantity),
      unitCost: Value(unitCost),
      totalCost: Value(totalCost),
      expiryDate: expiryDate == null && nullToAbsent
          ? const Value.absent()
          : Value(expiryDate),
      batchNumber: batchNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(batchNumber),
      createdAt: Value(createdAt),
    );
  }

  factory IncomingStockOrderLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return IncomingStockOrderLine(
      id: serializer.fromJson<int>(json['id']),
      orderId: serializer.fromJson<int>(json['order_id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitCost: serializer.fromJson<double>(json['unit_cost']),
      totalCost: serializer.fromJson<double>(json['total_cost']),
      expiryDate: serializer.fromJson<int?>(json['expiry_date']),
      batchNumber: serializer.fromJson<String?>(json['batch_number']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'order_id': serializer.toJson<int>(orderId),
      'item_id': serializer.toJson<int>(itemId),
      'quantity': serializer.toJson<double>(quantity),
      'unit_cost': serializer.toJson<double>(unitCost),
      'total_cost': serializer.toJson<double>(totalCost),
      'expiry_date': serializer.toJson<int?>(expiryDate),
      'batch_number': serializer.toJson<String?>(batchNumber),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  IncomingStockOrderLine copyWith(
          {int? id,
          int? orderId,
          int? itemId,
          double? quantity,
          double? unitCost,
          double? totalCost,
          Value<int?> expiryDate = const Value.absent(),
          Value<String?> batchNumber = const Value.absent(),
          int? createdAt}) =>
      IncomingStockOrderLine(
        id: id ?? this.id,
        orderId: orderId ?? this.orderId,
        itemId: itemId ?? this.itemId,
        quantity: quantity ?? this.quantity,
        unitCost: unitCost ?? this.unitCost,
        totalCost: totalCost ?? this.totalCost,
        expiryDate: expiryDate.present ? expiryDate.value : this.expiryDate,
        batchNumber: batchNumber.present ? batchNumber.value : this.batchNumber,
        createdAt: createdAt ?? this.createdAt,
      );
  IncomingStockOrderLine copyWithCompanion(
      IncomingStockOrderLinesCompanion data) {
    return IncomingStockOrderLine(
      id: data.id.present ? data.id.value : this.id,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      totalCost: data.totalCost.present ? data.totalCost.value : this.totalCost,
      expiryDate:
          data.expiryDate.present ? data.expiryDate.value : this.expiryDate,
      batchNumber:
          data.batchNumber.present ? data.batchNumber.value : this.batchNumber,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('IncomingStockOrderLine(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('batchNumber: $batchNumber, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, orderId, itemId, quantity, unitCost,
      totalCost, expiryDate, batchNumber, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is IncomingStockOrderLine &&
          other.id == this.id &&
          other.orderId == this.orderId &&
          other.itemId == this.itemId &&
          other.quantity == this.quantity &&
          other.unitCost == this.unitCost &&
          other.totalCost == this.totalCost &&
          other.expiryDate == this.expiryDate &&
          other.batchNumber == this.batchNumber &&
          other.createdAt == this.createdAt);
}

class IncomingStockOrderLinesCompanion
    extends UpdateCompanion<IncomingStockOrderLine> {
  final Value<int> id;
  final Value<int> orderId;
  final Value<int> itemId;
  final Value<double> quantity;
  final Value<double> unitCost;
  final Value<double> totalCost;
  final Value<int?> expiryDate;
  final Value<String?> batchNumber;
  final Value<int> createdAt;
  const IncomingStockOrderLinesCompanion({
    this.id = const Value.absent(),
    this.orderId = const Value.absent(),
    this.itemId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.expiryDate = const Value.absent(),
    this.batchNumber = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  IncomingStockOrderLinesCompanion.insert({
    this.id = const Value.absent(),
    required int orderId,
    required int itemId,
    required double quantity,
    required double unitCost,
    required double totalCost,
    this.expiryDate = const Value.absent(),
    this.batchNumber = const Value.absent(),
    required int createdAt,
  })  : orderId = Value(orderId),
        itemId = Value(itemId),
        quantity = Value(quantity),
        unitCost = Value(unitCost),
        totalCost = Value(totalCost),
        createdAt = Value(createdAt);
  static Insertable<IncomingStockOrderLine> custom({
    Expression<int>? id,
    Expression<int>? orderId,
    Expression<int>? itemId,
    Expression<double>? quantity,
    Expression<double>? unitCost,
    Expression<double>? totalCost,
    Expression<int>? expiryDate,
    Expression<String>? batchNumber,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderId != null) 'order_id': orderId,
      if (itemId != null) 'item_id': itemId,
      if (quantity != null) 'quantity': quantity,
      if (unitCost != null) 'unit_cost': unitCost,
      if (totalCost != null) 'total_cost': totalCost,
      if (expiryDate != null) 'expiry_date': expiryDate,
      if (batchNumber != null) 'batch_number': batchNumber,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  IncomingStockOrderLinesCompanion copyWith(
      {Value<int>? id,
      Value<int>? orderId,
      Value<int>? itemId,
      Value<double>? quantity,
      Value<double>? unitCost,
      Value<double>? totalCost,
      Value<int?>? expiryDate,
      Value<String?>? batchNumber,
      Value<int>? createdAt}) {
    return IncomingStockOrderLinesCompanion(
      id: id ?? this.id,
      orderId: orderId ?? this.orderId,
      itemId: itemId ?? this.itemId,
      quantity: quantity ?? this.quantity,
      unitCost: unitCost ?? this.unitCost,
      totalCost: totalCost ?? this.totalCost,
      expiryDate: expiryDate ?? this.expiryDate,
      batchNumber: batchNumber ?? this.batchNumber,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<int>(orderId.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (totalCost.present) {
      map['total_cost'] = Variable<double>(totalCost.value);
    }
    if (expiryDate.present) {
      map['expiry_date'] = Variable<int>(expiryDate.value);
    }
    if (batchNumber.present) {
      map['batch_number'] = Variable<String>(batchNumber.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('IncomingStockOrderLinesCompanion(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('expiryDate: $expiryDate, ')
          ..write('batchNumber: $batchNumber, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class OutgoingStockOrders extends Table
    with TableInfo<OutgoingStockOrders, OutgoingStockOrder> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  OutgoingStockOrders(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _docNoMeta = const VerificationMeta('docNo');
  late final GeneratedColumn<String> docNo = GeneratedColumn<String>(
      'doc_no', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _docDateMeta =
      const VerificationMeta('docDate');
  late final GeneratedColumn<int> docDate = GeneratedColumn<int>(
      'doc_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _warehouseIdMeta =
      const VerificationMeta('warehouseId');
  late final GeneratedColumn<int> warehouseId = GeneratedColumn<int>(
      'warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _beneficiaryAccountIdMeta =
      const VerificationMeta('beneficiaryAccountId');
  late final GeneratedColumn<String> beneficiaryAccountId =
      GeneratedColumn<String>(
          'beneficiary_account_id', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints:
              'NOT NULL REFERENCES chart_of_accounts(account_code)');
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'NOT NULL CHECK (status IN (\'Draft\', \'Posted\')) DEFAULT \'Draft\'',
      defaultValue: const CustomExpression('\'Draft\''));
  static const VerificationMeta _postedAtMeta =
      const VerificationMeta('postedAt');
  late final GeneratedColumn<int> postedAt = GeneratedColumn<int>(
      'posted_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _postedByMeta =
      const VerificationMeta('postedBy');
  late final GeneratedColumn<String> postedBy = GeneratedColumn<String>(
      'posted_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        docNo,
        docDate,
        warehouseId,
        reason,
        beneficiaryAccountId,
        notes,
        status,
        postedAt,
        postedBy,
        createdBy,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'outgoing_stock_orders';
  @override
  VerificationContext validateIntegrity(Insertable<OutgoingStockOrder> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('doc_no')) {
      context.handle(
          _docNoMeta, docNo.isAcceptableOrUnknown(data['doc_no']!, _docNoMeta));
    } else if (isInserting) {
      context.missing(_docNoMeta);
    }
    if (data.containsKey('doc_date')) {
      context.handle(_docDateMeta,
          docDate.isAcceptableOrUnknown(data['doc_date']!, _docDateMeta));
    } else if (isInserting) {
      context.missing(_docDateMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
          _warehouseIdMeta,
          warehouseId.isAcceptableOrUnknown(
              data['warehouse_id']!, _warehouseIdMeta));
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('beneficiary_account_id')) {
      context.handle(
          _beneficiaryAccountIdMeta,
          beneficiaryAccountId.isAcceptableOrUnknown(
              data['beneficiary_account_id']!, _beneficiaryAccountIdMeta));
    } else if (isInserting) {
      context.missing(_beneficiaryAccountIdMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('posted_at')) {
      context.handle(_postedAtMeta,
          postedAt.isAcceptableOrUnknown(data['posted_at']!, _postedAtMeta));
    }
    if (data.containsKey('posted_by')) {
      context.handle(_postedByMeta,
          postedBy.isAcceptableOrUnknown(data['posted_by']!, _postedByMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OutgoingStockOrder map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OutgoingStockOrder(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      docNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}doc_no'])!,
      docDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}doc_date'])!,
      warehouseId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}warehouse_id'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason'])!,
      beneficiaryAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}beneficiary_account_id'])!,
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      postedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}posted_at']),
      postedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}posted_by']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  OutgoingStockOrders createAlias(String alias) {
    return OutgoingStockOrders(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class OutgoingStockOrder extends DataClass
    implements Insertable<OutgoingStockOrder> {
  final int id;
  final String docNo;
  final int docDate;
  final int warehouseId;
  final String reason;
  final String beneficiaryAccountId;
  final String? notes;
  final String status;
  final int? postedAt;
  final String? postedBy;
  final String createdBy;
  final int createdAt;
  final int updatedAt;
  const OutgoingStockOrder(
      {required this.id,
      required this.docNo,
      required this.docDate,
      required this.warehouseId,
      required this.reason,
      required this.beneficiaryAccountId,
      this.notes,
      required this.status,
      this.postedAt,
      this.postedBy,
      required this.createdBy,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['doc_no'] = Variable<String>(docNo);
    map['doc_date'] = Variable<int>(docDate);
    map['warehouse_id'] = Variable<int>(warehouseId);
    map['reason'] = Variable<String>(reason);
    map['beneficiary_account_id'] = Variable<String>(beneficiaryAccountId);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || postedAt != null) {
      map['posted_at'] = Variable<int>(postedAt);
    }
    if (!nullToAbsent || postedBy != null) {
      map['posted_by'] = Variable<String>(postedBy);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  OutgoingStockOrdersCompanion toCompanion(bool nullToAbsent) {
    return OutgoingStockOrdersCompanion(
      id: Value(id),
      docNo: Value(docNo),
      docDate: Value(docDate),
      warehouseId: Value(warehouseId),
      reason: Value(reason),
      beneficiaryAccountId: Value(beneficiaryAccountId),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      status: Value(status),
      postedAt: postedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(postedAt),
      postedBy: postedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(postedBy),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory OutgoingStockOrder.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OutgoingStockOrder(
      id: serializer.fromJson<int>(json['id']),
      docNo: serializer.fromJson<String>(json['doc_no']),
      docDate: serializer.fromJson<int>(json['doc_date']),
      warehouseId: serializer.fromJson<int>(json['warehouse_id']),
      reason: serializer.fromJson<String>(json['reason']),
      beneficiaryAccountId:
          serializer.fromJson<String>(json['beneficiary_account_id']),
      notes: serializer.fromJson<String?>(json['notes']),
      status: serializer.fromJson<String>(json['status']),
      postedAt: serializer.fromJson<int?>(json['posted_at']),
      postedBy: serializer.fromJson<String?>(json['posted_by']),
      createdBy: serializer.fromJson<String>(json['created_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'doc_no': serializer.toJson<String>(docNo),
      'doc_date': serializer.toJson<int>(docDate),
      'warehouse_id': serializer.toJson<int>(warehouseId),
      'reason': serializer.toJson<String>(reason),
      'beneficiary_account_id': serializer.toJson<String>(beneficiaryAccountId),
      'notes': serializer.toJson<String?>(notes),
      'status': serializer.toJson<String>(status),
      'posted_at': serializer.toJson<int?>(postedAt),
      'posted_by': serializer.toJson<String?>(postedBy),
      'created_by': serializer.toJson<String>(createdBy),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  OutgoingStockOrder copyWith(
          {int? id,
          String? docNo,
          int? docDate,
          int? warehouseId,
          String? reason,
          String? beneficiaryAccountId,
          Value<String?> notes = const Value.absent(),
          String? status,
          Value<int?> postedAt = const Value.absent(),
          Value<String?> postedBy = const Value.absent(),
          String? createdBy,
          int? createdAt,
          int? updatedAt}) =>
      OutgoingStockOrder(
        id: id ?? this.id,
        docNo: docNo ?? this.docNo,
        docDate: docDate ?? this.docDate,
        warehouseId: warehouseId ?? this.warehouseId,
        reason: reason ?? this.reason,
        beneficiaryAccountId: beneficiaryAccountId ?? this.beneficiaryAccountId,
        notes: notes.present ? notes.value : this.notes,
        status: status ?? this.status,
        postedAt: postedAt.present ? postedAt.value : this.postedAt,
        postedBy: postedBy.present ? postedBy.value : this.postedBy,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  OutgoingStockOrder copyWithCompanion(OutgoingStockOrdersCompanion data) {
    return OutgoingStockOrder(
      id: data.id.present ? data.id.value : this.id,
      docNo: data.docNo.present ? data.docNo.value : this.docNo,
      docDate: data.docDate.present ? data.docDate.value : this.docDate,
      warehouseId:
          data.warehouseId.present ? data.warehouseId.value : this.warehouseId,
      reason: data.reason.present ? data.reason.value : this.reason,
      beneficiaryAccountId: data.beneficiaryAccountId.present
          ? data.beneficiaryAccountId.value
          : this.beneficiaryAccountId,
      notes: data.notes.present ? data.notes.value : this.notes,
      status: data.status.present ? data.status.value : this.status,
      postedAt: data.postedAt.present ? data.postedAt.value : this.postedAt,
      postedBy: data.postedBy.present ? data.postedBy.value : this.postedBy,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OutgoingStockOrder(')
          ..write('id: $id, ')
          ..write('docNo: $docNo, ')
          ..write('docDate: $docDate, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('reason: $reason, ')
          ..write('beneficiaryAccountId: $beneficiaryAccountId, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      docNo,
      docDate,
      warehouseId,
      reason,
      beneficiaryAccountId,
      notes,
      status,
      postedAt,
      postedBy,
      createdBy,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OutgoingStockOrder &&
          other.id == this.id &&
          other.docNo == this.docNo &&
          other.docDate == this.docDate &&
          other.warehouseId == this.warehouseId &&
          other.reason == this.reason &&
          other.beneficiaryAccountId == this.beneficiaryAccountId &&
          other.notes == this.notes &&
          other.status == this.status &&
          other.postedAt == this.postedAt &&
          other.postedBy == this.postedBy &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class OutgoingStockOrdersCompanion extends UpdateCompanion<OutgoingStockOrder> {
  final Value<int> id;
  final Value<String> docNo;
  final Value<int> docDate;
  final Value<int> warehouseId;
  final Value<String> reason;
  final Value<String> beneficiaryAccountId;
  final Value<String?> notes;
  final Value<String> status;
  final Value<int?> postedAt;
  final Value<String?> postedBy;
  final Value<String> createdBy;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const OutgoingStockOrdersCompanion({
    this.id = const Value.absent(),
    this.docNo = const Value.absent(),
    this.docDate = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.reason = const Value.absent(),
    this.beneficiaryAccountId = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  OutgoingStockOrdersCompanion.insert({
    this.id = const Value.absent(),
    required String docNo,
    required int docDate,
    required int warehouseId,
    required String reason,
    required String beneficiaryAccountId,
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    required String createdBy,
    required int createdAt,
    required int updatedAt,
  })  : docNo = Value(docNo),
        docDate = Value(docDate),
        warehouseId = Value(warehouseId),
        reason = Value(reason),
        beneficiaryAccountId = Value(beneficiaryAccountId),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<OutgoingStockOrder> custom({
    Expression<int>? id,
    Expression<String>? docNo,
    Expression<int>? docDate,
    Expression<int>? warehouseId,
    Expression<String>? reason,
    Expression<String>? beneficiaryAccountId,
    Expression<String>? notes,
    Expression<String>? status,
    Expression<int>? postedAt,
    Expression<String>? postedBy,
    Expression<String>? createdBy,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (docNo != null) 'doc_no': docNo,
      if (docDate != null) 'doc_date': docDate,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (reason != null) 'reason': reason,
      if (beneficiaryAccountId != null)
        'beneficiary_account_id': beneficiaryAccountId,
      if (notes != null) 'notes': notes,
      if (status != null) 'status': status,
      if (postedAt != null) 'posted_at': postedAt,
      if (postedBy != null) 'posted_by': postedBy,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  OutgoingStockOrdersCompanion copyWith(
      {Value<int>? id,
      Value<String>? docNo,
      Value<int>? docDate,
      Value<int>? warehouseId,
      Value<String>? reason,
      Value<String>? beneficiaryAccountId,
      Value<String?>? notes,
      Value<String>? status,
      Value<int?>? postedAt,
      Value<String?>? postedBy,
      Value<String>? createdBy,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return OutgoingStockOrdersCompanion(
      id: id ?? this.id,
      docNo: docNo ?? this.docNo,
      docDate: docDate ?? this.docDate,
      warehouseId: warehouseId ?? this.warehouseId,
      reason: reason ?? this.reason,
      beneficiaryAccountId: beneficiaryAccountId ?? this.beneficiaryAccountId,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      postedAt: postedAt ?? this.postedAt,
      postedBy: postedBy ?? this.postedBy,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (docNo.present) {
      map['doc_no'] = Variable<String>(docNo.value);
    }
    if (docDate.present) {
      map['doc_date'] = Variable<int>(docDate.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<int>(warehouseId.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (beneficiaryAccountId.present) {
      map['beneficiary_account_id'] =
          Variable<String>(beneficiaryAccountId.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (postedAt.present) {
      map['posted_at'] = Variable<int>(postedAt.value);
    }
    if (postedBy.present) {
      map['posted_by'] = Variable<String>(postedBy.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OutgoingStockOrdersCompanion(')
          ..write('id: $id, ')
          ..write('docNo: $docNo, ')
          ..write('docDate: $docDate, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('reason: $reason, ')
          ..write('beneficiaryAccountId: $beneficiaryAccountId, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class OutgoingStockOrderLines extends Table
    with TableInfo<OutgoingStockOrderLines, OutgoingStockOrderLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  OutgoingStockOrderLines(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _orderIdMeta =
      const VerificationMeta('orderId');
  late final GeneratedColumn<int> orderId = GeneratedColumn<int>(
      'order_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL REFERENCES outgoing_stock_orders(id)ON DELETE CASCADE');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _totalCostMeta =
      const VerificationMeta('totalCost');
  late final GeneratedColumn<double> totalCost = GeneratedColumn<double>(
      'total_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, orderId, itemId, quantity, unitCost, totalCost, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'outgoing_stock_order_lines';
  @override
  VerificationContext validateIntegrity(
      Insertable<OutgoingStockOrderLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('order_id')) {
      context.handle(_orderIdMeta,
          orderId.isAcceptableOrUnknown(data['order_id']!, _orderIdMeta));
    } else if (isInserting) {
      context.missing(_orderIdMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    if (data.containsKey('total_cost')) {
      context.handle(_totalCostMeta,
          totalCost.isAcceptableOrUnknown(data['total_cost']!, _totalCostMeta));
    } else if (isInserting) {
      context.missing(_totalCostMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OutgoingStockOrderLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OutgoingStockOrderLine(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      orderId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order_id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
      totalCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_cost'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  OutgoingStockOrderLines createAlias(String alias) {
    return OutgoingStockOrderLines(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class OutgoingStockOrderLine extends DataClass
    implements Insertable<OutgoingStockOrderLine> {
  final int id;
  final int orderId;
  final int itemId;
  final double quantity;
  final double unitCost;
  final double totalCost;
  final int createdAt;
  const OutgoingStockOrderLine(
      {required this.id,
      required this.orderId,
      required this.itemId,
      required this.quantity,
      required this.unitCost,
      required this.totalCost,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['order_id'] = Variable<int>(orderId);
    map['item_id'] = Variable<int>(itemId);
    map['quantity'] = Variable<double>(quantity);
    map['unit_cost'] = Variable<double>(unitCost);
    map['total_cost'] = Variable<double>(totalCost);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  OutgoingStockOrderLinesCompanion toCompanion(bool nullToAbsent) {
    return OutgoingStockOrderLinesCompanion(
      id: Value(id),
      orderId: Value(orderId),
      itemId: Value(itemId),
      quantity: Value(quantity),
      unitCost: Value(unitCost),
      totalCost: Value(totalCost),
      createdAt: Value(createdAt),
    );
  }

  factory OutgoingStockOrderLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OutgoingStockOrderLine(
      id: serializer.fromJson<int>(json['id']),
      orderId: serializer.fromJson<int>(json['order_id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitCost: serializer.fromJson<double>(json['unit_cost']),
      totalCost: serializer.fromJson<double>(json['total_cost']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'order_id': serializer.toJson<int>(orderId),
      'item_id': serializer.toJson<int>(itemId),
      'quantity': serializer.toJson<double>(quantity),
      'unit_cost': serializer.toJson<double>(unitCost),
      'total_cost': serializer.toJson<double>(totalCost),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  OutgoingStockOrderLine copyWith(
          {int? id,
          int? orderId,
          int? itemId,
          double? quantity,
          double? unitCost,
          double? totalCost,
          int? createdAt}) =>
      OutgoingStockOrderLine(
        id: id ?? this.id,
        orderId: orderId ?? this.orderId,
        itemId: itemId ?? this.itemId,
        quantity: quantity ?? this.quantity,
        unitCost: unitCost ?? this.unitCost,
        totalCost: totalCost ?? this.totalCost,
        createdAt: createdAt ?? this.createdAt,
      );
  OutgoingStockOrderLine copyWithCompanion(
      OutgoingStockOrderLinesCompanion data) {
    return OutgoingStockOrderLine(
      id: data.id.present ? data.id.value : this.id,
      orderId: data.orderId.present ? data.orderId.value : this.orderId,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      totalCost: data.totalCost.present ? data.totalCost.value : this.totalCost,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OutgoingStockOrderLine(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, orderId, itemId, quantity, unitCost, totalCost, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OutgoingStockOrderLine &&
          other.id == this.id &&
          other.orderId == this.orderId &&
          other.itemId == this.itemId &&
          other.quantity == this.quantity &&
          other.unitCost == this.unitCost &&
          other.totalCost == this.totalCost &&
          other.createdAt == this.createdAt);
}

class OutgoingStockOrderLinesCompanion
    extends UpdateCompanion<OutgoingStockOrderLine> {
  final Value<int> id;
  final Value<int> orderId;
  final Value<int> itemId;
  final Value<double> quantity;
  final Value<double> unitCost;
  final Value<double> totalCost;
  final Value<int> createdAt;
  const OutgoingStockOrderLinesCompanion({
    this.id = const Value.absent(),
    this.orderId = const Value.absent(),
    this.itemId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  OutgoingStockOrderLinesCompanion.insert({
    this.id = const Value.absent(),
    required int orderId,
    required int itemId,
    required double quantity,
    required double unitCost,
    required double totalCost,
    required int createdAt,
  })  : orderId = Value(orderId),
        itemId = Value(itemId),
        quantity = Value(quantity),
        unitCost = Value(unitCost),
        totalCost = Value(totalCost),
        createdAt = Value(createdAt);
  static Insertable<OutgoingStockOrderLine> custom({
    Expression<int>? id,
    Expression<int>? orderId,
    Expression<int>? itemId,
    Expression<double>? quantity,
    Expression<double>? unitCost,
    Expression<double>? totalCost,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (orderId != null) 'order_id': orderId,
      if (itemId != null) 'item_id': itemId,
      if (quantity != null) 'quantity': quantity,
      if (unitCost != null) 'unit_cost': unitCost,
      if (totalCost != null) 'total_cost': totalCost,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  OutgoingStockOrderLinesCompanion copyWith(
      {Value<int>? id,
      Value<int>? orderId,
      Value<int>? itemId,
      Value<double>? quantity,
      Value<double>? unitCost,
      Value<double>? totalCost,
      Value<int>? createdAt}) {
    return OutgoingStockOrderLinesCompanion(
      id: id ?? this.id,
      orderId: orderId ?? this.orderId,
      itemId: itemId ?? this.itemId,
      quantity: quantity ?? this.quantity,
      unitCost: unitCost ?? this.unitCost,
      totalCost: totalCost ?? this.totalCost,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (orderId.present) {
      map['order_id'] = Variable<int>(orderId.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (totalCost.present) {
      map['total_cost'] = Variable<double>(totalCost.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OutgoingStockOrderLinesCompanion(')
          ..write('id: $id, ')
          ..write('orderId: $orderId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class WarehouseTransfers extends Table
    with TableInfo<WarehouseTransfers, WarehouseTransfer> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  WarehouseTransfers(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _docNoMeta = const VerificationMeta('docNo');
  late final GeneratedColumn<String> docNo = GeneratedColumn<String>(
      'doc_no', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _transferDateMeta =
      const VerificationMeta('transferDate');
  late final GeneratedColumn<int> transferDate = GeneratedColumn<int>(
      'transfer_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _sourceWarehouseIdMeta =
      const VerificationMeta('sourceWarehouseId');
  late final GeneratedColumn<int> sourceWarehouseId = GeneratedColumn<int>(
      'source_warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _destinationWarehouseIdMeta =
      const VerificationMeta('destinationWarehouseId');
  late final GeneratedColumn<int> destinationWarehouseId = GeneratedColumn<int>(
      'destination_warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _refNoMeta = const VerificationMeta('refNo');
  late final GeneratedColumn<String> refNo = GeneratedColumn<String>(
      'ref_no', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'NOT NULL CHECK (status IN (\'Draft\', \'Dispatched\', \'Received\')) DEFAULT \'Draft\'',
      defaultValue: const CustomExpression('\'Draft\''));
  static const VerificationMeta _dispatchedAtMeta =
      const VerificationMeta('dispatchedAt');
  late final GeneratedColumn<int> dispatchedAt = GeneratedColumn<int>(
      'dispatched_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _dispatchedByMeta =
      const VerificationMeta('dispatchedBy');
  late final GeneratedColumn<String> dispatchedBy = GeneratedColumn<String>(
      'dispatched_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _receivedAtMeta =
      const VerificationMeta('receivedAt');
  late final GeneratedColumn<int> receivedAt = GeneratedColumn<int>(
      'received_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _receivedByMeta =
      const VerificationMeta('receivedBy');
  late final GeneratedColumn<String> receivedBy = GeneratedColumn<String>(
      'received_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        docNo,
        transferDate,
        sourceWarehouseId,
        destinationWarehouseId,
        refNo,
        notes,
        status,
        dispatchedAt,
        dispatchedBy,
        receivedAt,
        receivedBy,
        createdBy,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'warehouse_transfers';
  @override
  VerificationContext validateIntegrity(Insertable<WarehouseTransfer> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('doc_no')) {
      context.handle(
          _docNoMeta, docNo.isAcceptableOrUnknown(data['doc_no']!, _docNoMeta));
    } else if (isInserting) {
      context.missing(_docNoMeta);
    }
    if (data.containsKey('transfer_date')) {
      context.handle(
          _transferDateMeta,
          transferDate.isAcceptableOrUnknown(
              data['transfer_date']!, _transferDateMeta));
    } else if (isInserting) {
      context.missing(_transferDateMeta);
    }
    if (data.containsKey('source_warehouse_id')) {
      context.handle(
          _sourceWarehouseIdMeta,
          sourceWarehouseId.isAcceptableOrUnknown(
              data['source_warehouse_id']!, _sourceWarehouseIdMeta));
    } else if (isInserting) {
      context.missing(_sourceWarehouseIdMeta);
    }
    if (data.containsKey('destination_warehouse_id')) {
      context.handle(
          _destinationWarehouseIdMeta,
          destinationWarehouseId.isAcceptableOrUnknown(
              data['destination_warehouse_id']!, _destinationWarehouseIdMeta));
    } else if (isInserting) {
      context.missing(_destinationWarehouseIdMeta);
    }
    if (data.containsKey('ref_no')) {
      context.handle(
          _refNoMeta, refNo.isAcceptableOrUnknown(data['ref_no']!, _refNoMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('dispatched_at')) {
      context.handle(
          _dispatchedAtMeta,
          dispatchedAt.isAcceptableOrUnknown(
              data['dispatched_at']!, _dispatchedAtMeta));
    }
    if (data.containsKey('dispatched_by')) {
      context.handle(
          _dispatchedByMeta,
          dispatchedBy.isAcceptableOrUnknown(
              data['dispatched_by']!, _dispatchedByMeta));
    }
    if (data.containsKey('received_at')) {
      context.handle(
          _receivedAtMeta,
          receivedAt.isAcceptableOrUnknown(
              data['received_at']!, _receivedAtMeta));
    }
    if (data.containsKey('received_by')) {
      context.handle(
          _receivedByMeta,
          receivedBy.isAcceptableOrUnknown(
              data['received_by']!, _receivedByMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WarehouseTransfer map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WarehouseTransfer(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      docNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}doc_no'])!,
      transferDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}transfer_date'])!,
      sourceWarehouseId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}source_warehouse_id'])!,
      destinationWarehouseId: attachedDatabase.typeMapping.read(
          DriftSqlType.int,
          data['${effectivePrefix}destination_warehouse_id'])!,
      refNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ref_no']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      dispatchedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}dispatched_at']),
      dispatchedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}dispatched_by']),
      receivedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}received_at']),
      receivedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}received_by']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  WarehouseTransfers createAlias(String alias) {
    return WarehouseTransfers(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class WarehouseTransfer extends DataClass
    implements Insertable<WarehouseTransfer> {
  final int id;
  final String docNo;
  final int transferDate;
  final int sourceWarehouseId;
  final int destinationWarehouseId;
  final String? refNo;
  final String? notes;
  final String status;
  final int? dispatchedAt;
  final String? dispatchedBy;
  final int? receivedAt;
  final String? receivedBy;
  final String createdBy;
  final int createdAt;
  final int updatedAt;
  const WarehouseTransfer(
      {required this.id,
      required this.docNo,
      required this.transferDate,
      required this.sourceWarehouseId,
      required this.destinationWarehouseId,
      this.refNo,
      this.notes,
      required this.status,
      this.dispatchedAt,
      this.dispatchedBy,
      this.receivedAt,
      this.receivedBy,
      required this.createdBy,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['doc_no'] = Variable<String>(docNo);
    map['transfer_date'] = Variable<int>(transferDate);
    map['source_warehouse_id'] = Variable<int>(sourceWarehouseId);
    map['destination_warehouse_id'] = Variable<int>(destinationWarehouseId);
    if (!nullToAbsent || refNo != null) {
      map['ref_no'] = Variable<String>(refNo);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || dispatchedAt != null) {
      map['dispatched_at'] = Variable<int>(dispatchedAt);
    }
    if (!nullToAbsent || dispatchedBy != null) {
      map['dispatched_by'] = Variable<String>(dispatchedBy);
    }
    if (!nullToAbsent || receivedAt != null) {
      map['received_at'] = Variable<int>(receivedAt);
    }
    if (!nullToAbsent || receivedBy != null) {
      map['received_by'] = Variable<String>(receivedBy);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  WarehouseTransfersCompanion toCompanion(bool nullToAbsent) {
    return WarehouseTransfersCompanion(
      id: Value(id),
      docNo: Value(docNo),
      transferDate: Value(transferDate),
      sourceWarehouseId: Value(sourceWarehouseId),
      destinationWarehouseId: Value(destinationWarehouseId),
      refNo:
          refNo == null && nullToAbsent ? const Value.absent() : Value(refNo),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      status: Value(status),
      dispatchedAt: dispatchedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(dispatchedAt),
      dispatchedBy: dispatchedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(dispatchedBy),
      receivedAt: receivedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(receivedAt),
      receivedBy: receivedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(receivedBy),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory WarehouseTransfer.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WarehouseTransfer(
      id: serializer.fromJson<int>(json['id']),
      docNo: serializer.fromJson<String>(json['doc_no']),
      transferDate: serializer.fromJson<int>(json['transfer_date']),
      sourceWarehouseId: serializer.fromJson<int>(json['source_warehouse_id']),
      destinationWarehouseId:
          serializer.fromJson<int>(json['destination_warehouse_id']),
      refNo: serializer.fromJson<String?>(json['ref_no']),
      notes: serializer.fromJson<String?>(json['notes']),
      status: serializer.fromJson<String>(json['status']),
      dispatchedAt: serializer.fromJson<int?>(json['dispatched_at']),
      dispatchedBy: serializer.fromJson<String?>(json['dispatched_by']),
      receivedAt: serializer.fromJson<int?>(json['received_at']),
      receivedBy: serializer.fromJson<String?>(json['received_by']),
      createdBy: serializer.fromJson<String>(json['created_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'doc_no': serializer.toJson<String>(docNo),
      'transfer_date': serializer.toJson<int>(transferDate),
      'source_warehouse_id': serializer.toJson<int>(sourceWarehouseId),
      'destination_warehouse_id':
          serializer.toJson<int>(destinationWarehouseId),
      'ref_no': serializer.toJson<String?>(refNo),
      'notes': serializer.toJson<String?>(notes),
      'status': serializer.toJson<String>(status),
      'dispatched_at': serializer.toJson<int?>(dispatchedAt),
      'dispatched_by': serializer.toJson<String?>(dispatchedBy),
      'received_at': serializer.toJson<int?>(receivedAt),
      'received_by': serializer.toJson<String?>(receivedBy),
      'created_by': serializer.toJson<String>(createdBy),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  WarehouseTransfer copyWith(
          {int? id,
          String? docNo,
          int? transferDate,
          int? sourceWarehouseId,
          int? destinationWarehouseId,
          Value<String?> refNo = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          String? status,
          Value<int?> dispatchedAt = const Value.absent(),
          Value<String?> dispatchedBy = const Value.absent(),
          Value<int?> receivedAt = const Value.absent(),
          Value<String?> receivedBy = const Value.absent(),
          String? createdBy,
          int? createdAt,
          int? updatedAt}) =>
      WarehouseTransfer(
        id: id ?? this.id,
        docNo: docNo ?? this.docNo,
        transferDate: transferDate ?? this.transferDate,
        sourceWarehouseId: sourceWarehouseId ?? this.sourceWarehouseId,
        destinationWarehouseId:
            destinationWarehouseId ?? this.destinationWarehouseId,
        refNo: refNo.present ? refNo.value : this.refNo,
        notes: notes.present ? notes.value : this.notes,
        status: status ?? this.status,
        dispatchedAt:
            dispatchedAt.present ? dispatchedAt.value : this.dispatchedAt,
        dispatchedBy:
            dispatchedBy.present ? dispatchedBy.value : this.dispatchedBy,
        receivedAt: receivedAt.present ? receivedAt.value : this.receivedAt,
        receivedBy: receivedBy.present ? receivedBy.value : this.receivedBy,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  WarehouseTransfer copyWithCompanion(WarehouseTransfersCompanion data) {
    return WarehouseTransfer(
      id: data.id.present ? data.id.value : this.id,
      docNo: data.docNo.present ? data.docNo.value : this.docNo,
      transferDate: data.transferDate.present
          ? data.transferDate.value
          : this.transferDate,
      sourceWarehouseId: data.sourceWarehouseId.present
          ? data.sourceWarehouseId.value
          : this.sourceWarehouseId,
      destinationWarehouseId: data.destinationWarehouseId.present
          ? data.destinationWarehouseId.value
          : this.destinationWarehouseId,
      refNo: data.refNo.present ? data.refNo.value : this.refNo,
      notes: data.notes.present ? data.notes.value : this.notes,
      status: data.status.present ? data.status.value : this.status,
      dispatchedAt: data.dispatchedAt.present
          ? data.dispatchedAt.value
          : this.dispatchedAt,
      dispatchedBy: data.dispatchedBy.present
          ? data.dispatchedBy.value
          : this.dispatchedBy,
      receivedAt:
          data.receivedAt.present ? data.receivedAt.value : this.receivedAt,
      receivedBy:
          data.receivedBy.present ? data.receivedBy.value : this.receivedBy,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WarehouseTransfer(')
          ..write('id: $id, ')
          ..write('docNo: $docNo, ')
          ..write('transferDate: $transferDate, ')
          ..write('sourceWarehouseId: $sourceWarehouseId, ')
          ..write('destinationWarehouseId: $destinationWarehouseId, ')
          ..write('refNo: $refNo, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('dispatchedAt: $dispatchedAt, ')
          ..write('dispatchedBy: $dispatchedBy, ')
          ..write('receivedAt: $receivedAt, ')
          ..write('receivedBy: $receivedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      docNo,
      transferDate,
      sourceWarehouseId,
      destinationWarehouseId,
      refNo,
      notes,
      status,
      dispatchedAt,
      dispatchedBy,
      receivedAt,
      receivedBy,
      createdBy,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WarehouseTransfer &&
          other.id == this.id &&
          other.docNo == this.docNo &&
          other.transferDate == this.transferDate &&
          other.sourceWarehouseId == this.sourceWarehouseId &&
          other.destinationWarehouseId == this.destinationWarehouseId &&
          other.refNo == this.refNo &&
          other.notes == this.notes &&
          other.status == this.status &&
          other.dispatchedAt == this.dispatchedAt &&
          other.dispatchedBy == this.dispatchedBy &&
          other.receivedAt == this.receivedAt &&
          other.receivedBy == this.receivedBy &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class WarehouseTransfersCompanion extends UpdateCompanion<WarehouseTransfer> {
  final Value<int> id;
  final Value<String> docNo;
  final Value<int> transferDate;
  final Value<int> sourceWarehouseId;
  final Value<int> destinationWarehouseId;
  final Value<String?> refNo;
  final Value<String?> notes;
  final Value<String> status;
  final Value<int?> dispatchedAt;
  final Value<String?> dispatchedBy;
  final Value<int?> receivedAt;
  final Value<String?> receivedBy;
  final Value<String> createdBy;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const WarehouseTransfersCompanion({
    this.id = const Value.absent(),
    this.docNo = const Value.absent(),
    this.transferDate = const Value.absent(),
    this.sourceWarehouseId = const Value.absent(),
    this.destinationWarehouseId = const Value.absent(),
    this.refNo = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.dispatchedAt = const Value.absent(),
    this.dispatchedBy = const Value.absent(),
    this.receivedAt = const Value.absent(),
    this.receivedBy = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  WarehouseTransfersCompanion.insert({
    this.id = const Value.absent(),
    required String docNo,
    required int transferDate,
    required int sourceWarehouseId,
    required int destinationWarehouseId,
    this.refNo = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.dispatchedAt = const Value.absent(),
    this.dispatchedBy = const Value.absent(),
    this.receivedAt = const Value.absent(),
    this.receivedBy = const Value.absent(),
    required String createdBy,
    required int createdAt,
    required int updatedAt,
  })  : docNo = Value(docNo),
        transferDate = Value(transferDate),
        sourceWarehouseId = Value(sourceWarehouseId),
        destinationWarehouseId = Value(destinationWarehouseId),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<WarehouseTransfer> custom({
    Expression<int>? id,
    Expression<String>? docNo,
    Expression<int>? transferDate,
    Expression<int>? sourceWarehouseId,
    Expression<int>? destinationWarehouseId,
    Expression<String>? refNo,
    Expression<String>? notes,
    Expression<String>? status,
    Expression<int>? dispatchedAt,
    Expression<String>? dispatchedBy,
    Expression<int>? receivedAt,
    Expression<String>? receivedBy,
    Expression<String>? createdBy,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (docNo != null) 'doc_no': docNo,
      if (transferDate != null) 'transfer_date': transferDate,
      if (sourceWarehouseId != null) 'source_warehouse_id': sourceWarehouseId,
      if (destinationWarehouseId != null)
        'destination_warehouse_id': destinationWarehouseId,
      if (refNo != null) 'ref_no': refNo,
      if (notes != null) 'notes': notes,
      if (status != null) 'status': status,
      if (dispatchedAt != null) 'dispatched_at': dispatchedAt,
      if (dispatchedBy != null) 'dispatched_by': dispatchedBy,
      if (receivedAt != null) 'received_at': receivedAt,
      if (receivedBy != null) 'received_by': receivedBy,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  WarehouseTransfersCompanion copyWith(
      {Value<int>? id,
      Value<String>? docNo,
      Value<int>? transferDate,
      Value<int>? sourceWarehouseId,
      Value<int>? destinationWarehouseId,
      Value<String?>? refNo,
      Value<String?>? notes,
      Value<String>? status,
      Value<int?>? dispatchedAt,
      Value<String?>? dispatchedBy,
      Value<int?>? receivedAt,
      Value<String?>? receivedBy,
      Value<String>? createdBy,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return WarehouseTransfersCompanion(
      id: id ?? this.id,
      docNo: docNo ?? this.docNo,
      transferDate: transferDate ?? this.transferDate,
      sourceWarehouseId: sourceWarehouseId ?? this.sourceWarehouseId,
      destinationWarehouseId:
          destinationWarehouseId ?? this.destinationWarehouseId,
      refNo: refNo ?? this.refNo,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      dispatchedAt: dispatchedAt ?? this.dispatchedAt,
      dispatchedBy: dispatchedBy ?? this.dispatchedBy,
      receivedAt: receivedAt ?? this.receivedAt,
      receivedBy: receivedBy ?? this.receivedBy,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (docNo.present) {
      map['doc_no'] = Variable<String>(docNo.value);
    }
    if (transferDate.present) {
      map['transfer_date'] = Variable<int>(transferDate.value);
    }
    if (sourceWarehouseId.present) {
      map['source_warehouse_id'] = Variable<int>(sourceWarehouseId.value);
    }
    if (destinationWarehouseId.present) {
      map['destination_warehouse_id'] =
          Variable<int>(destinationWarehouseId.value);
    }
    if (refNo.present) {
      map['ref_no'] = Variable<String>(refNo.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (dispatchedAt.present) {
      map['dispatched_at'] = Variable<int>(dispatchedAt.value);
    }
    if (dispatchedBy.present) {
      map['dispatched_by'] = Variable<String>(dispatchedBy.value);
    }
    if (receivedAt.present) {
      map['received_at'] = Variable<int>(receivedAt.value);
    }
    if (receivedBy.present) {
      map['received_by'] = Variable<String>(receivedBy.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WarehouseTransfersCompanion(')
          ..write('id: $id, ')
          ..write('docNo: $docNo, ')
          ..write('transferDate: $transferDate, ')
          ..write('sourceWarehouseId: $sourceWarehouseId, ')
          ..write('destinationWarehouseId: $destinationWarehouseId, ')
          ..write('refNo: $refNo, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('dispatchedAt: $dispatchedAt, ')
          ..write('dispatchedBy: $dispatchedBy, ')
          ..write('receivedAt: $receivedAt, ')
          ..write('receivedBy: $receivedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class WarehouseTransferLines extends Table
    with TableInfo<WarehouseTransferLines, WarehouseTransferLine> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  WarehouseTransferLines(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _transferIdMeta =
      const VerificationMeta('transferId');
  late final GeneratedColumn<int> transferId = GeneratedColumn<int>(
      'transfer_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL REFERENCES warehouse_transfers(id)ON DELETE CASCADE');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _quantityMeta =
      const VerificationMeta('quantity');
  late final GeneratedColumn<double> quantity = GeneratedColumn<double>(
      'quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _unitCostMeta =
      const VerificationMeta('unitCost');
  late final GeneratedColumn<double> unitCost = GeneratedColumn<double>(
      'unit_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _totalCostMeta =
      const VerificationMeta('totalCost');
  late final GeneratedColumn<double> totalCost = GeneratedColumn<double>(
      'total_cost', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, transferId, itemId, quantity, unitCost, totalCost, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'warehouse_transfer_lines';
  @override
  VerificationContext validateIntegrity(
      Insertable<WarehouseTransferLine> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('transfer_id')) {
      context.handle(
          _transferIdMeta,
          transferId.isAcceptableOrUnknown(
              data['transfer_id']!, _transferIdMeta));
    } else if (isInserting) {
      context.missing(_transferIdMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(_quantityMeta,
          quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta));
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('unit_cost')) {
      context.handle(_unitCostMeta,
          unitCost.isAcceptableOrUnknown(data['unit_cost']!, _unitCostMeta));
    } else if (isInserting) {
      context.missing(_unitCostMeta);
    }
    if (data.containsKey('total_cost')) {
      context.handle(_totalCostMeta,
          totalCost.isAcceptableOrUnknown(data['total_cost']!, _totalCostMeta));
    } else if (isInserting) {
      context.missing(_totalCostMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WarehouseTransferLine map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WarehouseTransferLine(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      transferId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}transfer_id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      quantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}quantity'])!,
      unitCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}unit_cost'])!,
      totalCost: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}total_cost'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  WarehouseTransferLines createAlias(String alias) {
    return WarehouseTransferLines(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class WarehouseTransferLine extends DataClass
    implements Insertable<WarehouseTransferLine> {
  final int id;
  final int transferId;
  final int itemId;
  final double quantity;
  final double unitCost;
  final double totalCost;
  final int createdAt;
  const WarehouseTransferLine(
      {required this.id,
      required this.transferId,
      required this.itemId,
      required this.quantity,
      required this.unitCost,
      required this.totalCost,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['transfer_id'] = Variable<int>(transferId);
    map['item_id'] = Variable<int>(itemId);
    map['quantity'] = Variable<double>(quantity);
    map['unit_cost'] = Variable<double>(unitCost);
    map['total_cost'] = Variable<double>(totalCost);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  WarehouseTransferLinesCompanion toCompanion(bool nullToAbsent) {
    return WarehouseTransferLinesCompanion(
      id: Value(id),
      transferId: Value(transferId),
      itemId: Value(itemId),
      quantity: Value(quantity),
      unitCost: Value(unitCost),
      totalCost: Value(totalCost),
      createdAt: Value(createdAt),
    );
  }

  factory WarehouseTransferLine.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WarehouseTransferLine(
      id: serializer.fromJson<int>(json['id']),
      transferId: serializer.fromJson<int>(json['transfer_id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      quantity: serializer.fromJson<double>(json['quantity']),
      unitCost: serializer.fromJson<double>(json['unit_cost']),
      totalCost: serializer.fromJson<double>(json['total_cost']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'transfer_id': serializer.toJson<int>(transferId),
      'item_id': serializer.toJson<int>(itemId),
      'quantity': serializer.toJson<double>(quantity),
      'unit_cost': serializer.toJson<double>(unitCost),
      'total_cost': serializer.toJson<double>(totalCost),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  WarehouseTransferLine copyWith(
          {int? id,
          int? transferId,
          int? itemId,
          double? quantity,
          double? unitCost,
          double? totalCost,
          int? createdAt}) =>
      WarehouseTransferLine(
        id: id ?? this.id,
        transferId: transferId ?? this.transferId,
        itemId: itemId ?? this.itemId,
        quantity: quantity ?? this.quantity,
        unitCost: unitCost ?? this.unitCost,
        totalCost: totalCost ?? this.totalCost,
        createdAt: createdAt ?? this.createdAt,
      );
  WarehouseTransferLine copyWithCompanion(
      WarehouseTransferLinesCompanion data) {
    return WarehouseTransferLine(
      id: data.id.present ? data.id.value : this.id,
      transferId:
          data.transferId.present ? data.transferId.value : this.transferId,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      unitCost: data.unitCost.present ? data.unitCost.value : this.unitCost,
      totalCost: data.totalCost.present ? data.totalCost.value : this.totalCost,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WarehouseTransferLine(')
          ..write('id: $id, ')
          ..write('transferId: $transferId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, transferId, itemId, quantity, unitCost, totalCost, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WarehouseTransferLine &&
          other.id == this.id &&
          other.transferId == this.transferId &&
          other.itemId == this.itemId &&
          other.quantity == this.quantity &&
          other.unitCost == this.unitCost &&
          other.totalCost == this.totalCost &&
          other.createdAt == this.createdAt);
}

class WarehouseTransferLinesCompanion
    extends UpdateCompanion<WarehouseTransferLine> {
  final Value<int> id;
  final Value<int> transferId;
  final Value<int> itemId;
  final Value<double> quantity;
  final Value<double> unitCost;
  final Value<double> totalCost;
  final Value<int> createdAt;
  const WarehouseTransferLinesCompanion({
    this.id = const Value.absent(),
    this.transferId = const Value.absent(),
    this.itemId = const Value.absent(),
    this.quantity = const Value.absent(),
    this.unitCost = const Value.absent(),
    this.totalCost = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  WarehouseTransferLinesCompanion.insert({
    this.id = const Value.absent(),
    required int transferId,
    required int itemId,
    required double quantity,
    required double unitCost,
    required double totalCost,
    required int createdAt,
  })  : transferId = Value(transferId),
        itemId = Value(itemId),
        quantity = Value(quantity),
        unitCost = Value(unitCost),
        totalCost = Value(totalCost),
        createdAt = Value(createdAt);
  static Insertable<WarehouseTransferLine> custom({
    Expression<int>? id,
    Expression<int>? transferId,
    Expression<int>? itemId,
    Expression<double>? quantity,
    Expression<double>? unitCost,
    Expression<double>? totalCost,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (transferId != null) 'transfer_id': transferId,
      if (itemId != null) 'item_id': itemId,
      if (quantity != null) 'quantity': quantity,
      if (unitCost != null) 'unit_cost': unitCost,
      if (totalCost != null) 'total_cost': totalCost,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  WarehouseTransferLinesCompanion copyWith(
      {Value<int>? id,
      Value<int>? transferId,
      Value<int>? itemId,
      Value<double>? quantity,
      Value<double>? unitCost,
      Value<double>? totalCost,
      Value<int>? createdAt}) {
    return WarehouseTransferLinesCompanion(
      id: id ?? this.id,
      transferId: transferId ?? this.transferId,
      itemId: itemId ?? this.itemId,
      quantity: quantity ?? this.quantity,
      unitCost: unitCost ?? this.unitCost,
      totalCost: totalCost ?? this.totalCost,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (transferId.present) {
      map['transfer_id'] = Variable<int>(transferId.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<double>(quantity.value);
    }
    if (unitCost.present) {
      map['unit_cost'] = Variable<double>(unitCost.value);
    }
    if (totalCost.present) {
      map['total_cost'] = Variable<double>(totalCost.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WarehouseTransferLinesCompanion(')
          ..write('id: $id, ')
          ..write('transferId: $transferId, ')
          ..write('itemId: $itemId, ')
          ..write('quantity: $quantity, ')
          ..write('unitCost: $unitCost, ')
          ..write('totalCost: $totalCost, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class StocktakingSessions extends Table
    with TableInfo<StocktakingSessions, StocktakingSession> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  StocktakingSessions(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _sessionNoMeta =
      const VerificationMeta('sessionNo');
  late final GeneratedColumn<String> sessionNo = GeneratedColumn<String>(
      'session_no', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _warehouseIdMeta =
      const VerificationMeta('warehouseId');
  late final GeneratedColumn<int> warehouseId = GeneratedColumn<int>(
      'warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _sessionDateMeta =
      const VerificationMeta('sessionDate');
  late final GeneratedColumn<int> sessionDate = GeneratedColumn<int>(
      'session_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'NOT NULL CHECK (status IN (\'Active\', \'Completed\', \'Posted\')) DEFAULT \'Active\'',
      defaultValue: const CustomExpression('\'Active\''));
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _postedAtMeta =
      const VerificationMeta('postedAt');
  late final GeneratedColumn<int> postedAt = GeneratedColumn<int>(
      'posted_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _postedByMeta =
      const VerificationMeta('postedBy');
  late final GeneratedColumn<String> postedBy = GeneratedColumn<String>(
      'posted_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        sessionNo,
        warehouseId,
        sessionDate,
        status,
        notes,
        postedAt,
        postedBy,
        createdBy,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stocktaking_sessions';
  @override
  VerificationContext validateIntegrity(Insertable<StocktakingSession> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('session_no')) {
      context.handle(_sessionNoMeta,
          sessionNo.isAcceptableOrUnknown(data['session_no']!, _sessionNoMeta));
    } else if (isInserting) {
      context.missing(_sessionNoMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
          _warehouseIdMeta,
          warehouseId.isAcceptableOrUnknown(
              data['warehouse_id']!, _warehouseIdMeta));
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('session_date')) {
      context.handle(
          _sessionDateMeta,
          sessionDate.isAcceptableOrUnknown(
              data['session_date']!, _sessionDateMeta));
    } else if (isInserting) {
      context.missing(_sessionDateMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('posted_at')) {
      context.handle(_postedAtMeta,
          postedAt.isAcceptableOrUnknown(data['posted_at']!, _postedAtMeta));
    }
    if (data.containsKey('posted_by')) {
      context.handle(_postedByMeta,
          postedBy.isAcceptableOrUnknown(data['posted_by']!, _postedByMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StocktakingSession map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StocktakingSession(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      sessionNo: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}session_no'])!,
      warehouseId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}warehouse_id'])!,
      sessionDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}session_date'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      postedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}posted_at']),
      postedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}posted_by']),
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  StocktakingSessions createAlias(String alias) {
    return StocktakingSessions(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class StocktakingSession extends DataClass
    implements Insertable<StocktakingSession> {
  final int id;
  final String sessionNo;
  final int warehouseId;
  final int sessionDate;
  final String status;
  final String? notes;
  final int? postedAt;
  final String? postedBy;
  final String createdBy;
  final int createdAt;
  final int updatedAt;
  const StocktakingSession(
      {required this.id,
      required this.sessionNo,
      required this.warehouseId,
      required this.sessionDate,
      required this.status,
      this.notes,
      this.postedAt,
      this.postedBy,
      required this.createdBy,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['session_no'] = Variable<String>(sessionNo);
    map['warehouse_id'] = Variable<int>(warehouseId);
    map['session_date'] = Variable<int>(sessionDate);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || postedAt != null) {
      map['posted_at'] = Variable<int>(postedAt);
    }
    if (!nullToAbsent || postedBy != null) {
      map['posted_by'] = Variable<String>(postedBy);
    }
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  StocktakingSessionsCompanion toCompanion(bool nullToAbsent) {
    return StocktakingSessionsCompanion(
      id: Value(id),
      sessionNo: Value(sessionNo),
      warehouseId: Value(warehouseId),
      sessionDate: Value(sessionDate),
      status: Value(status),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      postedAt: postedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(postedAt),
      postedBy: postedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(postedBy),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StocktakingSession.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StocktakingSession(
      id: serializer.fromJson<int>(json['id']),
      sessionNo: serializer.fromJson<String>(json['session_no']),
      warehouseId: serializer.fromJson<int>(json['warehouse_id']),
      sessionDate: serializer.fromJson<int>(json['session_date']),
      status: serializer.fromJson<String>(json['status']),
      notes: serializer.fromJson<String?>(json['notes']),
      postedAt: serializer.fromJson<int?>(json['posted_at']),
      postedBy: serializer.fromJson<String?>(json['posted_by']),
      createdBy: serializer.fromJson<String>(json['created_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'session_no': serializer.toJson<String>(sessionNo),
      'warehouse_id': serializer.toJson<int>(warehouseId),
      'session_date': serializer.toJson<int>(sessionDate),
      'status': serializer.toJson<String>(status),
      'notes': serializer.toJson<String?>(notes),
      'posted_at': serializer.toJson<int?>(postedAt),
      'posted_by': serializer.toJson<String?>(postedBy),
      'created_by': serializer.toJson<String>(createdBy),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  StocktakingSession copyWith(
          {int? id,
          String? sessionNo,
          int? warehouseId,
          int? sessionDate,
          String? status,
          Value<String?> notes = const Value.absent(),
          Value<int?> postedAt = const Value.absent(),
          Value<String?> postedBy = const Value.absent(),
          String? createdBy,
          int? createdAt,
          int? updatedAt}) =>
      StocktakingSession(
        id: id ?? this.id,
        sessionNo: sessionNo ?? this.sessionNo,
        warehouseId: warehouseId ?? this.warehouseId,
        sessionDate: sessionDate ?? this.sessionDate,
        status: status ?? this.status,
        notes: notes.present ? notes.value : this.notes,
        postedAt: postedAt.present ? postedAt.value : this.postedAt,
        postedBy: postedBy.present ? postedBy.value : this.postedBy,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StocktakingSession copyWithCompanion(StocktakingSessionsCompanion data) {
    return StocktakingSession(
      id: data.id.present ? data.id.value : this.id,
      sessionNo: data.sessionNo.present ? data.sessionNo.value : this.sessionNo,
      warehouseId:
          data.warehouseId.present ? data.warehouseId.value : this.warehouseId,
      sessionDate:
          data.sessionDate.present ? data.sessionDate.value : this.sessionDate,
      status: data.status.present ? data.status.value : this.status,
      notes: data.notes.present ? data.notes.value : this.notes,
      postedAt: data.postedAt.present ? data.postedAt.value : this.postedAt,
      postedBy: data.postedBy.present ? data.postedBy.value : this.postedBy,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StocktakingSession(')
          ..write('id: $id, ')
          ..write('sessionNo: $sessionNo, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('sessionDate: $sessionDate, ')
          ..write('status: $status, ')
          ..write('notes: $notes, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, sessionNo, warehouseId, sessionDate,
      status, notes, postedAt, postedBy, createdBy, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StocktakingSession &&
          other.id == this.id &&
          other.sessionNo == this.sessionNo &&
          other.warehouseId == this.warehouseId &&
          other.sessionDate == this.sessionDate &&
          other.status == this.status &&
          other.notes == this.notes &&
          other.postedAt == this.postedAt &&
          other.postedBy == this.postedBy &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StocktakingSessionsCompanion extends UpdateCompanion<StocktakingSession> {
  final Value<int> id;
  final Value<String> sessionNo;
  final Value<int> warehouseId;
  final Value<int> sessionDate;
  final Value<String> status;
  final Value<String?> notes;
  final Value<int?> postedAt;
  final Value<String?> postedBy;
  final Value<String> createdBy;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const StocktakingSessionsCompanion({
    this.id = const Value.absent(),
    this.sessionNo = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.sessionDate = const Value.absent(),
    this.status = const Value.absent(),
    this.notes = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StocktakingSessionsCompanion.insert({
    this.id = const Value.absent(),
    required String sessionNo,
    required int warehouseId,
    required int sessionDate,
    this.status = const Value.absent(),
    this.notes = const Value.absent(),
    this.postedAt = const Value.absent(),
    this.postedBy = const Value.absent(),
    required String createdBy,
    required int createdAt,
    required int updatedAt,
  })  : sessionNo = Value(sessionNo),
        warehouseId = Value(warehouseId),
        sessionDate = Value(sessionDate),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<StocktakingSession> custom({
    Expression<int>? id,
    Expression<String>? sessionNo,
    Expression<int>? warehouseId,
    Expression<int>? sessionDate,
    Expression<String>? status,
    Expression<String>? notes,
    Expression<int>? postedAt,
    Expression<String>? postedBy,
    Expression<String>? createdBy,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionNo != null) 'session_no': sessionNo,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (sessionDate != null) 'session_date': sessionDate,
      if (status != null) 'status': status,
      if (notes != null) 'notes': notes,
      if (postedAt != null) 'posted_at': postedAt,
      if (postedBy != null) 'posted_by': postedBy,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StocktakingSessionsCompanion copyWith(
      {Value<int>? id,
      Value<String>? sessionNo,
      Value<int>? warehouseId,
      Value<int>? sessionDate,
      Value<String>? status,
      Value<String?>? notes,
      Value<int?>? postedAt,
      Value<String?>? postedBy,
      Value<String>? createdBy,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return StocktakingSessionsCompanion(
      id: id ?? this.id,
      sessionNo: sessionNo ?? this.sessionNo,
      warehouseId: warehouseId ?? this.warehouseId,
      sessionDate: sessionDate ?? this.sessionDate,
      status: status ?? this.status,
      notes: notes ?? this.notes,
      postedAt: postedAt ?? this.postedAt,
      postedBy: postedBy ?? this.postedBy,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (sessionNo.present) {
      map['session_no'] = Variable<String>(sessionNo.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<int>(warehouseId.value);
    }
    if (sessionDate.present) {
      map['session_date'] = Variable<int>(sessionDate.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (postedAt.present) {
      map['posted_at'] = Variable<int>(postedAt.value);
    }
    if (postedBy.present) {
      map['posted_by'] = Variable<String>(postedBy.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StocktakingSessionsCompanion(')
          ..write('id: $id, ')
          ..write('sessionNo: $sessionNo, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('sessionDate: $sessionDate, ')
          ..write('status: $status, ')
          ..write('notes: $notes, ')
          ..write('postedAt: $postedAt, ')
          ..write('postedBy: $postedBy, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class StocktakingCounts extends Table
    with TableInfo<StocktakingCounts, StocktakingCount> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  StocktakingCounts(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _sessionIdMeta =
      const VerificationMeta('sessionId');
  late final GeneratedColumn<int> sessionId = GeneratedColumn<int>(
      'session_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL REFERENCES stocktaking_sessions(id)ON DELETE CASCADE');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _bookQuantityMeta =
      const VerificationMeta('bookQuantity');
  late final GeneratedColumn<double> bookQuantity = GeneratedColumn<double>(
      'book_quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _physicalQuantityMeta =
      const VerificationMeta('physicalQuantity');
  late final GeneratedColumn<double> physicalQuantity = GeneratedColumn<double>(
      'physical_quantity', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _discrepancyMeta =
      const VerificationMeta('discrepancy');
  late final GeneratedColumn<double> discrepancy = GeneratedColumn<double>(
      'discrepancy', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _discrepancyValueMeta =
      const VerificationMeta('discrepancyValue');
  late final GeneratedColumn<double> discrepancyValue = GeneratedColumn<double>(
      'discrepancy_value', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _countedAtMeta =
      const VerificationMeta('countedAt');
  late final GeneratedColumn<int> countedAt = GeneratedColumn<int>(
      'counted_at', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _countedByMeta =
      const VerificationMeta('countedBy');
  late final GeneratedColumn<String> countedBy = GeneratedColumn<String>(
      'counted_by', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        sessionId,
        itemId,
        bookQuantity,
        physicalQuantity,
        discrepancy,
        discrepancyValue,
        countedAt,
        countedBy,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stocktaking_counts';
  @override
  VerificationContext validateIntegrity(Insertable<StocktakingCount> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('session_id')) {
      context.handle(_sessionIdMeta,
          sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta));
    } else if (isInserting) {
      context.missing(_sessionIdMeta);
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('book_quantity')) {
      context.handle(
          _bookQuantityMeta,
          bookQuantity.isAcceptableOrUnknown(
              data['book_quantity']!, _bookQuantityMeta));
    } else if (isInserting) {
      context.missing(_bookQuantityMeta);
    }
    if (data.containsKey('physical_quantity')) {
      context.handle(
          _physicalQuantityMeta,
          physicalQuantity.isAcceptableOrUnknown(
              data['physical_quantity']!, _physicalQuantityMeta));
    }
    if (data.containsKey('discrepancy')) {
      context.handle(
          _discrepancyMeta,
          discrepancy.isAcceptableOrUnknown(
              data['discrepancy']!, _discrepancyMeta));
    }
    if (data.containsKey('discrepancy_value')) {
      context.handle(
          _discrepancyValueMeta,
          discrepancyValue.isAcceptableOrUnknown(
              data['discrepancy_value']!, _discrepancyValueMeta));
    }
    if (data.containsKey('counted_at')) {
      context.handle(_countedAtMeta,
          countedAt.isAcceptableOrUnknown(data['counted_at']!, _countedAtMeta));
    }
    if (data.containsKey('counted_by')) {
      context.handle(_countedByMeta,
          countedBy.isAcceptableOrUnknown(data['counted_by']!, _countedByMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StocktakingCount map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StocktakingCount(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      sessionId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}session_id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      bookQuantity: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}book_quantity'])!,
      physicalQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}physical_quantity']),
      discrepancy: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}discrepancy']),
      discrepancyValue: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}discrepancy_value']),
      countedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}counted_at']),
      countedBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}counted_by']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  StocktakingCounts createAlias(String alias) {
    return StocktakingCounts(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class StocktakingCount extends DataClass
    implements Insertable<StocktakingCount> {
  final int id;
  final int sessionId;
  final int itemId;
  final double bookQuantity;
  final double? physicalQuantity;
  final double? discrepancy;
  final double? discrepancyValue;
  final int? countedAt;
  final String? countedBy;
  final int createdAt;
  const StocktakingCount(
      {required this.id,
      required this.sessionId,
      required this.itemId,
      required this.bookQuantity,
      this.physicalQuantity,
      this.discrepancy,
      this.discrepancyValue,
      this.countedAt,
      this.countedBy,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['session_id'] = Variable<int>(sessionId);
    map['item_id'] = Variable<int>(itemId);
    map['book_quantity'] = Variable<double>(bookQuantity);
    if (!nullToAbsent || physicalQuantity != null) {
      map['physical_quantity'] = Variable<double>(physicalQuantity);
    }
    if (!nullToAbsent || discrepancy != null) {
      map['discrepancy'] = Variable<double>(discrepancy);
    }
    if (!nullToAbsent || discrepancyValue != null) {
      map['discrepancy_value'] = Variable<double>(discrepancyValue);
    }
    if (!nullToAbsent || countedAt != null) {
      map['counted_at'] = Variable<int>(countedAt);
    }
    if (!nullToAbsent || countedBy != null) {
      map['counted_by'] = Variable<String>(countedBy);
    }
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  StocktakingCountsCompanion toCompanion(bool nullToAbsent) {
    return StocktakingCountsCompanion(
      id: Value(id),
      sessionId: Value(sessionId),
      itemId: Value(itemId),
      bookQuantity: Value(bookQuantity),
      physicalQuantity: physicalQuantity == null && nullToAbsent
          ? const Value.absent()
          : Value(physicalQuantity),
      discrepancy: discrepancy == null && nullToAbsent
          ? const Value.absent()
          : Value(discrepancy),
      discrepancyValue: discrepancyValue == null && nullToAbsent
          ? const Value.absent()
          : Value(discrepancyValue),
      countedAt: countedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(countedAt),
      countedBy: countedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(countedBy),
      createdAt: Value(createdAt),
    );
  }

  factory StocktakingCount.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StocktakingCount(
      id: serializer.fromJson<int>(json['id']),
      sessionId: serializer.fromJson<int>(json['session_id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      bookQuantity: serializer.fromJson<double>(json['book_quantity']),
      physicalQuantity: serializer.fromJson<double?>(json['physical_quantity']),
      discrepancy: serializer.fromJson<double?>(json['discrepancy']),
      discrepancyValue: serializer.fromJson<double?>(json['discrepancy_value']),
      countedAt: serializer.fromJson<int?>(json['counted_at']),
      countedBy: serializer.fromJson<String?>(json['counted_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'session_id': serializer.toJson<int>(sessionId),
      'item_id': serializer.toJson<int>(itemId),
      'book_quantity': serializer.toJson<double>(bookQuantity),
      'physical_quantity': serializer.toJson<double?>(physicalQuantity),
      'discrepancy': serializer.toJson<double?>(discrepancy),
      'discrepancy_value': serializer.toJson<double?>(discrepancyValue),
      'counted_at': serializer.toJson<int?>(countedAt),
      'counted_by': serializer.toJson<String?>(countedBy),
      'created_at': serializer.toJson<int>(createdAt),
    };
  }

  StocktakingCount copyWith(
          {int? id,
          int? sessionId,
          int? itemId,
          double? bookQuantity,
          Value<double?> physicalQuantity = const Value.absent(),
          Value<double?> discrepancy = const Value.absent(),
          Value<double?> discrepancyValue = const Value.absent(),
          Value<int?> countedAt = const Value.absent(),
          Value<String?> countedBy = const Value.absent(),
          int? createdAt}) =>
      StocktakingCount(
        id: id ?? this.id,
        sessionId: sessionId ?? this.sessionId,
        itemId: itemId ?? this.itemId,
        bookQuantity: bookQuantity ?? this.bookQuantity,
        physicalQuantity: physicalQuantity.present
            ? physicalQuantity.value
            : this.physicalQuantity,
        discrepancy: discrepancy.present ? discrepancy.value : this.discrepancy,
        discrepancyValue: discrepancyValue.present
            ? discrepancyValue.value
            : this.discrepancyValue,
        countedAt: countedAt.present ? countedAt.value : this.countedAt,
        countedBy: countedBy.present ? countedBy.value : this.countedBy,
        createdAt: createdAt ?? this.createdAt,
      );
  StocktakingCount copyWithCompanion(StocktakingCountsCompanion data) {
    return StocktakingCount(
      id: data.id.present ? data.id.value : this.id,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      bookQuantity: data.bookQuantity.present
          ? data.bookQuantity.value
          : this.bookQuantity,
      physicalQuantity: data.physicalQuantity.present
          ? data.physicalQuantity.value
          : this.physicalQuantity,
      discrepancy:
          data.discrepancy.present ? data.discrepancy.value : this.discrepancy,
      discrepancyValue: data.discrepancyValue.present
          ? data.discrepancyValue.value
          : this.discrepancyValue,
      countedAt: data.countedAt.present ? data.countedAt.value : this.countedAt,
      countedBy: data.countedBy.present ? data.countedBy.value : this.countedBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StocktakingCount(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('itemId: $itemId, ')
          ..write('bookQuantity: $bookQuantity, ')
          ..write('physicalQuantity: $physicalQuantity, ')
          ..write('discrepancy: $discrepancy, ')
          ..write('discrepancyValue: $discrepancyValue, ')
          ..write('countedAt: $countedAt, ')
          ..write('countedBy: $countedBy, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      sessionId,
      itemId,
      bookQuantity,
      physicalQuantity,
      discrepancy,
      discrepancyValue,
      countedAt,
      countedBy,
      createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StocktakingCount &&
          other.id == this.id &&
          other.sessionId == this.sessionId &&
          other.itemId == this.itemId &&
          other.bookQuantity == this.bookQuantity &&
          other.physicalQuantity == this.physicalQuantity &&
          other.discrepancy == this.discrepancy &&
          other.discrepancyValue == this.discrepancyValue &&
          other.countedAt == this.countedAt &&
          other.countedBy == this.countedBy &&
          other.createdAt == this.createdAt);
}

class StocktakingCountsCompanion extends UpdateCompanion<StocktakingCount> {
  final Value<int> id;
  final Value<int> sessionId;
  final Value<int> itemId;
  final Value<double> bookQuantity;
  final Value<double?> physicalQuantity;
  final Value<double?> discrepancy;
  final Value<double?> discrepancyValue;
  final Value<int?> countedAt;
  final Value<String?> countedBy;
  final Value<int> createdAt;
  const StocktakingCountsCompanion({
    this.id = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.itemId = const Value.absent(),
    this.bookQuantity = const Value.absent(),
    this.physicalQuantity = const Value.absent(),
    this.discrepancy = const Value.absent(),
    this.discrepancyValue = const Value.absent(),
    this.countedAt = const Value.absent(),
    this.countedBy = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  StocktakingCountsCompanion.insert({
    this.id = const Value.absent(),
    required int sessionId,
    required int itemId,
    required double bookQuantity,
    this.physicalQuantity = const Value.absent(),
    this.discrepancy = const Value.absent(),
    this.discrepancyValue = const Value.absent(),
    this.countedAt = const Value.absent(),
    this.countedBy = const Value.absent(),
    required int createdAt,
  })  : sessionId = Value(sessionId),
        itemId = Value(itemId),
        bookQuantity = Value(bookQuantity),
        createdAt = Value(createdAt);
  static Insertable<StocktakingCount> custom({
    Expression<int>? id,
    Expression<int>? sessionId,
    Expression<int>? itemId,
    Expression<double>? bookQuantity,
    Expression<double>? physicalQuantity,
    Expression<double>? discrepancy,
    Expression<double>? discrepancyValue,
    Expression<int>? countedAt,
    Expression<String>? countedBy,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (sessionId != null) 'session_id': sessionId,
      if (itemId != null) 'item_id': itemId,
      if (bookQuantity != null) 'book_quantity': bookQuantity,
      if (physicalQuantity != null) 'physical_quantity': physicalQuantity,
      if (discrepancy != null) 'discrepancy': discrepancy,
      if (discrepancyValue != null) 'discrepancy_value': discrepancyValue,
      if (countedAt != null) 'counted_at': countedAt,
      if (countedBy != null) 'counted_by': countedBy,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  StocktakingCountsCompanion copyWith(
      {Value<int>? id,
      Value<int>? sessionId,
      Value<int>? itemId,
      Value<double>? bookQuantity,
      Value<double?>? physicalQuantity,
      Value<double?>? discrepancy,
      Value<double?>? discrepancyValue,
      Value<int?>? countedAt,
      Value<String?>? countedBy,
      Value<int>? createdAt}) {
    return StocktakingCountsCompanion(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      itemId: itemId ?? this.itemId,
      bookQuantity: bookQuantity ?? this.bookQuantity,
      physicalQuantity: physicalQuantity ?? this.physicalQuantity,
      discrepancy: discrepancy ?? this.discrepancy,
      discrepancyValue: discrepancyValue ?? this.discrepancyValue,
      countedAt: countedAt ?? this.countedAt,
      countedBy: countedBy ?? this.countedBy,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<int>(sessionId.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (bookQuantity.present) {
      map['book_quantity'] = Variable<double>(bookQuantity.value);
    }
    if (physicalQuantity.present) {
      map['physical_quantity'] = Variable<double>(physicalQuantity.value);
    }
    if (discrepancy.present) {
      map['discrepancy'] = Variable<double>(discrepancy.value);
    }
    if (discrepancyValue.present) {
      map['discrepancy_value'] = Variable<double>(discrepancyValue.value);
    }
    if (countedAt.present) {
      map['counted_at'] = Variable<int>(countedAt.value);
    }
    if (countedBy.present) {
      map['counted_by'] = Variable<String>(countedBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StocktakingCountsCompanion(')
          ..write('id: $id, ')
          ..write('sessionId: $sessionId, ')
          ..write('itemId: $itemId, ')
          ..write('bookQuantity: $bookQuantity, ')
          ..write('physicalQuantity: $physicalQuantity, ')
          ..write('discrepancy: $discrepancy, ')
          ..write('discrepancyValue: $discrepancyValue, ')
          ..write('countedAt: $countedAt, ')
          ..write('countedBy: $countedBy, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class StockReservations extends Table
    with TableInfo<StockReservations, StockReservation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  StockReservations(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _itemIdMeta = const VerificationMeta('itemId');
  late final GeneratedColumn<int> itemId = GeneratedColumn<int>(
      'item_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES items(id)');
  static const VerificationMeta _warehouseIdMeta =
      const VerificationMeta('warehouseId');
  late final GeneratedColumn<int> warehouseId = GeneratedColumn<int>(
      'warehouse_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES warehouses(id)');
  static const VerificationMeta _reservedQuantityMeta =
      const VerificationMeta('reservedQuantity');
  late final GeneratedColumn<double> reservedQuantity = GeneratedColumn<double>(
      'reserved_quantity', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _reservationEndDateMeta =
      const VerificationMeta('reservationEndDate');
  late final GeneratedColumn<int> reservationEndDate = GeneratedColumn<int>(
      'reservation_end_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints:
          'NOT NULL CHECK (status IN (\'Active\', \'Released\')) DEFAULT \'Active\'',
      defaultValue: const CustomExpression('\'Active\''));
  static const VerificationMeta _createdByMeta =
      const VerificationMeta('createdBy');
  late final GeneratedColumn<String> createdBy = GeneratedColumn<String>(
      'created_by', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        itemId,
        warehouseId,
        reservedQuantity,
        reservationEndDate,
        notes,
        status,
        createdBy,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'stock_reservations';
  @override
  VerificationContext validateIntegrity(Insertable<StockReservation> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('item_id')) {
      context.handle(_itemIdMeta,
          itemId.isAcceptableOrUnknown(data['item_id']!, _itemIdMeta));
    } else if (isInserting) {
      context.missing(_itemIdMeta);
    }
    if (data.containsKey('warehouse_id')) {
      context.handle(
          _warehouseIdMeta,
          warehouseId.isAcceptableOrUnknown(
              data['warehouse_id']!, _warehouseIdMeta));
    } else if (isInserting) {
      context.missing(_warehouseIdMeta);
    }
    if (data.containsKey('reserved_quantity')) {
      context.handle(
          _reservedQuantityMeta,
          reservedQuantity.isAcceptableOrUnknown(
              data['reserved_quantity']!, _reservedQuantityMeta));
    } else if (isInserting) {
      context.missing(_reservedQuantityMeta);
    }
    if (data.containsKey('reservation_end_date')) {
      context.handle(
          _reservationEndDateMeta,
          reservationEndDate.isAcceptableOrUnknown(
              data['reservation_end_date']!, _reservationEndDateMeta));
    } else if (isInserting) {
      context.missing(_reservationEndDateMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('created_by')) {
      context.handle(_createdByMeta,
          createdBy.isAcceptableOrUnknown(data['created_by']!, _createdByMeta));
    } else if (isInserting) {
      context.missing(_createdByMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  StockReservation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return StockReservation(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      itemId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}item_id'])!,
      warehouseId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}warehouse_id'])!,
      reservedQuantity: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}reserved_quantity'])!,
      reservationEndDate: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}reservation_end_date'])!,
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      createdBy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}created_by'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  StockReservations createAlias(String alias) {
    return StockReservations(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class StockReservation extends DataClass
    implements Insertable<StockReservation> {
  final int id;
  final int itemId;
  final int warehouseId;
  final double reservedQuantity;
  final int reservationEndDate;
  final String? notes;
  final String status;
  final String createdBy;
  final int createdAt;
  final int updatedAt;
  const StockReservation(
      {required this.id,
      required this.itemId,
      required this.warehouseId,
      required this.reservedQuantity,
      required this.reservationEndDate,
      this.notes,
      required this.status,
      required this.createdBy,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['item_id'] = Variable<int>(itemId);
    map['warehouse_id'] = Variable<int>(warehouseId);
    map['reserved_quantity'] = Variable<double>(reservedQuantity);
    map['reservation_end_date'] = Variable<int>(reservationEndDate);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['status'] = Variable<String>(status);
    map['created_by'] = Variable<String>(createdBy);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  StockReservationsCompanion toCompanion(bool nullToAbsent) {
    return StockReservationsCompanion(
      id: Value(id),
      itemId: Value(itemId),
      warehouseId: Value(warehouseId),
      reservedQuantity: Value(reservedQuantity),
      reservationEndDate: Value(reservationEndDate),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      status: Value(status),
      createdBy: Value(createdBy),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory StockReservation.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return StockReservation(
      id: serializer.fromJson<int>(json['id']),
      itemId: serializer.fromJson<int>(json['item_id']),
      warehouseId: serializer.fromJson<int>(json['warehouse_id']),
      reservedQuantity: serializer.fromJson<double>(json['reserved_quantity']),
      reservationEndDate:
          serializer.fromJson<int>(json['reservation_end_date']),
      notes: serializer.fromJson<String?>(json['notes']),
      status: serializer.fromJson<String>(json['status']),
      createdBy: serializer.fromJson<String>(json['created_by']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'item_id': serializer.toJson<int>(itemId),
      'warehouse_id': serializer.toJson<int>(warehouseId),
      'reserved_quantity': serializer.toJson<double>(reservedQuantity),
      'reservation_end_date': serializer.toJson<int>(reservationEndDate),
      'notes': serializer.toJson<String?>(notes),
      'status': serializer.toJson<String>(status),
      'created_by': serializer.toJson<String>(createdBy),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  StockReservation copyWith(
          {int? id,
          int? itemId,
          int? warehouseId,
          double? reservedQuantity,
          int? reservationEndDate,
          Value<String?> notes = const Value.absent(),
          String? status,
          String? createdBy,
          int? createdAt,
          int? updatedAt}) =>
      StockReservation(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        warehouseId: warehouseId ?? this.warehouseId,
        reservedQuantity: reservedQuantity ?? this.reservedQuantity,
        reservationEndDate: reservationEndDate ?? this.reservationEndDate,
        notes: notes.present ? notes.value : this.notes,
        status: status ?? this.status,
        createdBy: createdBy ?? this.createdBy,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  StockReservation copyWithCompanion(StockReservationsCompanion data) {
    return StockReservation(
      id: data.id.present ? data.id.value : this.id,
      itemId: data.itemId.present ? data.itemId.value : this.itemId,
      warehouseId:
          data.warehouseId.present ? data.warehouseId.value : this.warehouseId,
      reservedQuantity: data.reservedQuantity.present
          ? data.reservedQuantity.value
          : this.reservedQuantity,
      reservationEndDate: data.reservationEndDate.present
          ? data.reservationEndDate.value
          : this.reservationEndDate,
      notes: data.notes.present ? data.notes.value : this.notes,
      status: data.status.present ? data.status.value : this.status,
      createdBy: data.createdBy.present ? data.createdBy.value : this.createdBy,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('StockReservation(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('reservedQuantity: $reservedQuantity, ')
          ..write('reservationEndDate: $reservationEndDate, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, itemId, warehouseId, reservedQuantity,
      reservationEndDate, notes, status, createdBy, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is StockReservation &&
          other.id == this.id &&
          other.itemId == this.itemId &&
          other.warehouseId == this.warehouseId &&
          other.reservedQuantity == this.reservedQuantity &&
          other.reservationEndDate == this.reservationEndDate &&
          other.notes == this.notes &&
          other.status == this.status &&
          other.createdBy == this.createdBy &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class StockReservationsCompanion extends UpdateCompanion<StockReservation> {
  final Value<int> id;
  final Value<int> itemId;
  final Value<int> warehouseId;
  final Value<double> reservedQuantity;
  final Value<int> reservationEndDate;
  final Value<String?> notes;
  final Value<String> status;
  final Value<String> createdBy;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const StockReservationsCompanion({
    this.id = const Value.absent(),
    this.itemId = const Value.absent(),
    this.warehouseId = const Value.absent(),
    this.reservedQuantity = const Value.absent(),
    this.reservationEndDate = const Value.absent(),
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    this.createdBy = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  StockReservationsCompanion.insert({
    this.id = const Value.absent(),
    required int itemId,
    required int warehouseId,
    required double reservedQuantity,
    required int reservationEndDate,
    this.notes = const Value.absent(),
    this.status = const Value.absent(),
    required String createdBy,
    required int createdAt,
    required int updatedAt,
  })  : itemId = Value(itemId),
        warehouseId = Value(warehouseId),
        reservedQuantity = Value(reservedQuantity),
        reservationEndDate = Value(reservationEndDate),
        createdBy = Value(createdBy),
        createdAt = Value(createdAt),
        updatedAt = Value(updatedAt);
  static Insertable<StockReservation> custom({
    Expression<int>? id,
    Expression<int>? itemId,
    Expression<int>? warehouseId,
    Expression<double>? reservedQuantity,
    Expression<int>? reservationEndDate,
    Expression<String>? notes,
    Expression<String>? status,
    Expression<String>? createdBy,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (itemId != null) 'item_id': itemId,
      if (warehouseId != null) 'warehouse_id': warehouseId,
      if (reservedQuantity != null) 'reserved_quantity': reservedQuantity,
      if (reservationEndDate != null)
        'reservation_end_date': reservationEndDate,
      if (notes != null) 'notes': notes,
      if (status != null) 'status': status,
      if (createdBy != null) 'created_by': createdBy,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  StockReservationsCompanion copyWith(
      {Value<int>? id,
      Value<int>? itemId,
      Value<int>? warehouseId,
      Value<double>? reservedQuantity,
      Value<int>? reservationEndDate,
      Value<String?>? notes,
      Value<String>? status,
      Value<String>? createdBy,
      Value<int>? createdAt,
      Value<int>? updatedAt}) {
    return StockReservationsCompanion(
      id: id ?? this.id,
      itemId: itemId ?? this.itemId,
      warehouseId: warehouseId ?? this.warehouseId,
      reservedQuantity: reservedQuantity ?? this.reservedQuantity,
      reservationEndDate: reservationEndDate ?? this.reservationEndDate,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      createdBy: createdBy ?? this.createdBy,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (itemId.present) {
      map['item_id'] = Variable<int>(itemId.value);
    }
    if (warehouseId.present) {
      map['warehouse_id'] = Variable<int>(warehouseId.value);
    }
    if (reservedQuantity.present) {
      map['reserved_quantity'] = Variable<double>(reservedQuantity.value);
    }
    if (reservationEndDate.present) {
      map['reservation_end_date'] = Variable<int>(reservationEndDate.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (createdBy.present) {
      map['created_by'] = Variable<String>(createdBy.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('StockReservationsCompanion(')
          ..write('id: $id, ')
          ..write('itemId: $itemId, ')
          ..write('warehouseId: $warehouseId, ')
          ..write('reservedQuantity: $reservedQuantity, ')
          ..write('reservationEndDate: $reservationEndDate, ')
          ..write('notes: $notes, ')
          ..write('status: $status, ')
          ..write('createdBy: $createdBy, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class FinancialPeriods extends Table
    with TableInfo<FinancialPeriods, FinancialPeriod> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  FinancialPeriods(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _periodCodeMeta =
      const VerificationMeta('periodCode');
  late final GeneratedColumn<String> periodCode = GeneratedColumn<String>(
      'period_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _periodNameMeta =
      const VerificationMeta('periodName');
  late final GeneratedColumn<String> periodName = GeneratedColumn<String>(
      'period_name', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _fiscalYearMeta =
      const VerificationMeta('fiscalYear');
  late final GeneratedColumn<int> fiscalYear = GeneratedColumn<int>(
      'fiscal_year', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _periodTypeMeta =
      const VerificationMeta('periodType');
  late final GeneratedColumn<String> periodType = GeneratedColumn<String>(
      'period_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _periodNumberMeta =
      const VerificationMeta('periodNumber');
  late final GeneratedColumn<int> periodNumber = GeneratedColumn<int>(
      'period_number', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  late final GeneratedColumn<int> startDate = GeneratedColumn<int>(
      'start_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  late final GeneratedColumn<int> endDate = GeneratedColumn<int>(
      'end_date', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _isLockedMeta =
      const VerificationMeta('isLocked');
  late final GeneratedColumn<bool> isLocked = GeneratedColumn<bool>(
      'is_locked', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        periodCode,
        periodName,
        fiscalYear,
        periodType,
        periodNumber,
        startDate,
        endDate,
        isLocked
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'financial_periods';
  @override
  VerificationContext validateIntegrity(Insertable<FinancialPeriod> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('period_code')) {
      context.handle(
          _periodCodeMeta,
          periodCode.isAcceptableOrUnknown(
              data['period_code']!, _periodCodeMeta));
    } else if (isInserting) {
      context.missing(_periodCodeMeta);
    }
    if (data.containsKey('period_name')) {
      context.handle(
          _periodNameMeta,
          periodName.isAcceptableOrUnknown(
              data['period_name']!, _periodNameMeta));
    }
    if (data.containsKey('fiscal_year')) {
      context.handle(
          _fiscalYearMeta,
          fiscalYear.isAcceptableOrUnknown(
              data['fiscal_year']!, _fiscalYearMeta));
    } else if (isInserting) {
      context.missing(_fiscalYearMeta);
    }
    if (data.containsKey('period_type')) {
      context.handle(
          _periodTypeMeta,
          periodType.isAcceptableOrUnknown(
              data['period_type']!, _periodTypeMeta));
    } else if (isInserting) {
      context.missing(_periodTypeMeta);
    }
    if (data.containsKey('period_number')) {
      context.handle(
          _periodNumberMeta,
          periodNumber.isAcceptableOrUnknown(
              data['period_number']!, _periodNumberMeta));
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    } else if (isInserting) {
      context.missing(_startDateMeta);
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    } else if (isInserting) {
      context.missing(_endDateMeta);
    }
    if (data.containsKey('is_locked')) {
      context.handle(_isLockedMeta,
          isLocked.isAcceptableOrUnknown(data['is_locked']!, _isLockedMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FinancialPeriod map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FinancialPeriod(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      periodCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}period_code'])!,
      periodName: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}period_name']),
      fiscalYear: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}fiscal_year'])!,
      periodType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}period_type'])!,
      periodNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}period_number']),
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}start_date'])!,
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}end_date'])!,
      isLocked: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_locked'])!,
    );
  }

  @override
  FinancialPeriods createAlias(String alias) {
    return FinancialPeriods(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class FinancialPeriod extends DataClass implements Insertable<FinancialPeriod> {
  final int id;
  final String periodCode;
  final String? periodName;
  final int fiscalYear;
  final String periodType;
  final int? periodNumber;
  final int startDate;
  final int endDate;
  final bool isLocked;
  const FinancialPeriod(
      {required this.id,
      required this.periodCode,
      this.periodName,
      required this.fiscalYear,
      required this.periodType,
      this.periodNumber,
      required this.startDate,
      required this.endDate,
      required this.isLocked});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['period_code'] = Variable<String>(periodCode);
    if (!nullToAbsent || periodName != null) {
      map['period_name'] = Variable<String>(periodName);
    }
    map['fiscal_year'] = Variable<int>(fiscalYear);
    map['period_type'] = Variable<String>(periodType);
    if (!nullToAbsent || periodNumber != null) {
      map['period_number'] = Variable<int>(periodNumber);
    }
    map['start_date'] = Variable<int>(startDate);
    map['end_date'] = Variable<int>(endDate);
    map['is_locked'] = Variable<bool>(isLocked);
    return map;
  }

  FinancialPeriodsCompanion toCompanion(bool nullToAbsent) {
    return FinancialPeriodsCompanion(
      id: Value(id),
      periodCode: Value(periodCode),
      periodName: periodName == null && nullToAbsent
          ? const Value.absent()
          : Value(periodName),
      fiscalYear: Value(fiscalYear),
      periodType: Value(periodType),
      periodNumber: periodNumber == null && nullToAbsent
          ? const Value.absent()
          : Value(periodNumber),
      startDate: Value(startDate),
      endDate: Value(endDate),
      isLocked: Value(isLocked),
    );
  }

  factory FinancialPeriod.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FinancialPeriod(
      id: serializer.fromJson<int>(json['id']),
      periodCode: serializer.fromJson<String>(json['period_code']),
      periodName: serializer.fromJson<String?>(json['period_name']),
      fiscalYear: serializer.fromJson<int>(json['fiscal_year']),
      periodType: serializer.fromJson<String>(json['period_type']),
      periodNumber: serializer.fromJson<int?>(json['period_number']),
      startDate: serializer.fromJson<int>(json['start_date']),
      endDate: serializer.fromJson<int>(json['end_date']),
      isLocked: serializer.fromJson<bool>(json['is_locked']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'period_code': serializer.toJson<String>(periodCode),
      'period_name': serializer.toJson<String?>(periodName),
      'fiscal_year': serializer.toJson<int>(fiscalYear),
      'period_type': serializer.toJson<String>(periodType),
      'period_number': serializer.toJson<int?>(periodNumber),
      'start_date': serializer.toJson<int>(startDate),
      'end_date': serializer.toJson<int>(endDate),
      'is_locked': serializer.toJson<bool>(isLocked),
    };
  }

  FinancialPeriod copyWith(
          {int? id,
          String? periodCode,
          Value<String?> periodName = const Value.absent(),
          int? fiscalYear,
          String? periodType,
          Value<int?> periodNumber = const Value.absent(),
          int? startDate,
          int? endDate,
          bool? isLocked}) =>
      FinancialPeriod(
        id: id ?? this.id,
        periodCode: periodCode ?? this.periodCode,
        periodName: periodName.present ? periodName.value : this.periodName,
        fiscalYear: fiscalYear ?? this.fiscalYear,
        periodType: periodType ?? this.periodType,
        periodNumber:
            periodNumber.present ? periodNumber.value : this.periodNumber,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        isLocked: isLocked ?? this.isLocked,
      );
  FinancialPeriod copyWithCompanion(FinancialPeriodsCompanion data) {
    return FinancialPeriod(
      id: data.id.present ? data.id.value : this.id,
      periodCode:
          data.periodCode.present ? data.periodCode.value : this.periodCode,
      periodName:
          data.periodName.present ? data.periodName.value : this.periodName,
      fiscalYear:
          data.fiscalYear.present ? data.fiscalYear.value : this.fiscalYear,
      periodType:
          data.periodType.present ? data.periodType.value : this.periodType,
      periodNumber: data.periodNumber.present
          ? data.periodNumber.value
          : this.periodNumber,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      isLocked: data.isLocked.present ? data.isLocked.value : this.isLocked,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FinancialPeriod(')
          ..write('id: $id, ')
          ..write('periodCode: $periodCode, ')
          ..write('periodName: $periodName, ')
          ..write('fiscalYear: $fiscalYear, ')
          ..write('periodType: $periodType, ')
          ..write('periodNumber: $periodNumber, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isLocked: $isLocked')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, periodCode, periodName, fiscalYear,
      periodType, periodNumber, startDate, endDate, isLocked);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FinancialPeriod &&
          other.id == this.id &&
          other.periodCode == this.periodCode &&
          other.periodName == this.periodName &&
          other.fiscalYear == this.fiscalYear &&
          other.periodType == this.periodType &&
          other.periodNumber == this.periodNumber &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.isLocked == this.isLocked);
}

class FinancialPeriodsCompanion extends UpdateCompanion<FinancialPeriod> {
  final Value<int> id;
  final Value<String> periodCode;
  final Value<String?> periodName;
  final Value<int> fiscalYear;
  final Value<String> periodType;
  final Value<int?> periodNumber;
  final Value<int> startDate;
  final Value<int> endDate;
  final Value<bool> isLocked;
  const FinancialPeriodsCompanion({
    this.id = const Value.absent(),
    this.periodCode = const Value.absent(),
    this.periodName = const Value.absent(),
    this.fiscalYear = const Value.absent(),
    this.periodType = const Value.absent(),
    this.periodNumber = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isLocked = const Value.absent(),
  });
  FinancialPeriodsCompanion.insert({
    this.id = const Value.absent(),
    required String periodCode,
    this.periodName = const Value.absent(),
    required int fiscalYear,
    required String periodType,
    this.periodNumber = const Value.absent(),
    required int startDate,
    required int endDate,
    this.isLocked = const Value.absent(),
  })  : periodCode = Value(periodCode),
        fiscalYear = Value(fiscalYear),
        periodType = Value(periodType),
        startDate = Value(startDate),
        endDate = Value(endDate);
  static Insertable<FinancialPeriod> custom({
    Expression<int>? id,
    Expression<String>? periodCode,
    Expression<String>? periodName,
    Expression<int>? fiscalYear,
    Expression<String>? periodType,
    Expression<int>? periodNumber,
    Expression<int>? startDate,
    Expression<int>? endDate,
    Expression<bool>? isLocked,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (periodCode != null) 'period_code': periodCode,
      if (periodName != null) 'period_name': periodName,
      if (fiscalYear != null) 'fiscal_year': fiscalYear,
      if (periodType != null) 'period_type': periodType,
      if (periodNumber != null) 'period_number': periodNumber,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (isLocked != null) 'is_locked': isLocked,
    });
  }

  FinancialPeriodsCompanion copyWith(
      {Value<int>? id,
      Value<String>? periodCode,
      Value<String?>? periodName,
      Value<int>? fiscalYear,
      Value<String>? periodType,
      Value<int?>? periodNumber,
      Value<int>? startDate,
      Value<int>? endDate,
      Value<bool>? isLocked}) {
    return FinancialPeriodsCompanion(
      id: id ?? this.id,
      periodCode: periodCode ?? this.periodCode,
      periodName: periodName ?? this.periodName,
      fiscalYear: fiscalYear ?? this.fiscalYear,
      periodType: periodType ?? this.periodType,
      periodNumber: periodNumber ?? this.periodNumber,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isLocked: isLocked ?? this.isLocked,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (periodCode.present) {
      map['period_code'] = Variable<String>(periodCode.value);
    }
    if (periodName.present) {
      map['period_name'] = Variable<String>(periodName.value);
    }
    if (fiscalYear.present) {
      map['fiscal_year'] = Variable<int>(fiscalYear.value);
    }
    if (periodType.present) {
      map['period_type'] = Variable<String>(periodType.value);
    }
    if (periodNumber.present) {
      map['period_number'] = Variable<int>(periodNumber.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<int>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<int>(endDate.value);
    }
    if (isLocked.present) {
      map['is_locked'] = Variable<bool>(isLocked.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FinancialPeriodsCompanion(')
          ..write('id: $id, ')
          ..write('periodCode: $periodCode, ')
          ..write('periodName: $periodName, ')
          ..write('fiscalYear: $fiscalYear, ')
          ..write('periodType: $periodType, ')
          ..write('periodNumber: $periodNumber, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isLocked: $isLocked')
          ..write(')'))
        .toString();
  }
}

class Currencies extends Table with TableInfo<Currencies, Currency> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Currencies(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _currencyCodeMeta =
      const VerificationMeta('currencyCode');
  late final GeneratedColumn<String> currencyCode = GeneratedColumn<String>(
      'currency_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _symbolMeta = const VerificationMeta('symbol');
  late final GeneratedColumn<String> symbol = GeneratedColumn<String>(
      'symbol', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _fractionNameArMeta =
      const VerificationMeta('fractionNameAr');
  late final GeneratedColumn<String> fractionNameAr = GeneratedColumn<String>(
      'fraction_name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _fractionNameEnMeta =
      const VerificationMeta('fractionNameEn');
  late final GeneratedColumn<String> fractionNameEn = GeneratedColumn<String>(
      'fraction_name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _exchangeRateMeta =
      const VerificationMeta('exchangeRate');
  late final GeneratedColumn<double> exchangeRate = GeneratedColumn<double>(
      'exchange_rate', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _isBaseCurrencyMeta =
      const VerificationMeta('isBaseCurrency');
  late final GeneratedColumn<bool> isBaseCurrency = GeneratedColumn<bool>(
      'is_base_currency', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _decimalPlacesMeta =
      const VerificationMeta('decimalPlaces');
  late final GeneratedColumn<int> decimalPlaces = GeneratedColumn<int>(
      'decimal_places', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _minRateLimitMeta =
      const VerificationMeta('minRateLimit');
  late final GeneratedColumn<double> minRateLimit = GeneratedColumn<double>(
      'min_rate_limit', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _maxRateLimitMeta =
      const VerificationMeta('maxRateLimit');
  late final GeneratedColumn<double> maxRateLimit = GeneratedColumn<double>(
      'max_rate_limit', aliasedName, true,
      type: DriftSqlType.double,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        currencyCode,
        nameAr,
        nameEn,
        symbol,
        fractionNameAr,
        fractionNameEn,
        exchangeRate,
        isBaseCurrency,
        decimalPlaces,
        minRateLimit,
        maxRateLimit,
        isActive
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'currencies';
  @override
  VerificationContext validateIntegrity(Insertable<Currency> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('currency_code')) {
      context.handle(
          _currencyCodeMeta,
          currencyCode.isAcceptableOrUnknown(
              data['currency_code']!, _currencyCodeMeta));
    } else if (isInserting) {
      context.missing(_currencyCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('symbol')) {
      context.handle(_symbolMeta,
          symbol.isAcceptableOrUnknown(data['symbol']!, _symbolMeta));
    } else if (isInserting) {
      context.missing(_symbolMeta);
    }
    if (data.containsKey('fraction_name_ar')) {
      context.handle(
          _fractionNameArMeta,
          fractionNameAr.isAcceptableOrUnknown(
              data['fraction_name_ar']!, _fractionNameArMeta));
    } else if (isInserting) {
      context.missing(_fractionNameArMeta);
    }
    if (data.containsKey('fraction_name_en')) {
      context.handle(
          _fractionNameEnMeta,
          fractionNameEn.isAcceptableOrUnknown(
              data['fraction_name_en']!, _fractionNameEnMeta));
    } else if (isInserting) {
      context.missing(_fractionNameEnMeta);
    }
    if (data.containsKey('exchange_rate')) {
      context.handle(
          _exchangeRateMeta,
          exchangeRate.isAcceptableOrUnknown(
              data['exchange_rate']!, _exchangeRateMeta));
    } else if (isInserting) {
      context.missing(_exchangeRateMeta);
    }
    if (data.containsKey('is_base_currency')) {
      context.handle(
          _isBaseCurrencyMeta,
          isBaseCurrency.isAcceptableOrUnknown(
              data['is_base_currency']!, _isBaseCurrencyMeta));
    }
    if (data.containsKey('decimal_places')) {
      context.handle(
          _decimalPlacesMeta,
          decimalPlaces.isAcceptableOrUnknown(
              data['decimal_places']!, _decimalPlacesMeta));
    } else if (isInserting) {
      context.missing(_decimalPlacesMeta);
    }
    if (data.containsKey('min_rate_limit')) {
      context.handle(
          _minRateLimitMeta,
          minRateLimit.isAcceptableOrUnknown(
              data['min_rate_limit']!, _minRateLimitMeta));
    }
    if (data.containsKey('max_rate_limit')) {
      context.handle(
          _maxRateLimitMeta,
          maxRateLimit.isAcceptableOrUnknown(
              data['max_rate_limit']!, _maxRateLimitMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    } else if (isInserting) {
      context.missing(_isActiveMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {currencyCode};
  @override
  Currency map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Currency(
      currencyCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      symbol: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}symbol'])!,
      fractionNameAr: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fraction_name_ar'])!,
      fractionNameEn: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}fraction_name_en'])!,
      exchangeRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}exchange_rate'])!,
      isBaseCurrency: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_base_currency'])!,
      decimalPlaces: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}decimal_places'])!,
      minRateLimit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}min_rate_limit']),
      maxRateLimit: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}max_rate_limit']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Currencies createAlias(String alias) {
    return Currencies(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Currency extends DataClass implements Insertable<Currency> {
  final String currencyCode;
  final String nameAr;
  final String nameEn;
  final String symbol;
  final String fractionNameAr;
  final String fractionNameEn;
  final double exchangeRate;
  final bool isBaseCurrency;
  final int decimalPlaces;
  final double? minRateLimit;
  final double? maxRateLimit;
  final bool isActive;
  const Currency(
      {required this.currencyCode,
      required this.nameAr,
      required this.nameEn,
      required this.symbol,
      required this.fractionNameAr,
      required this.fractionNameEn,
      required this.exchangeRate,
      required this.isBaseCurrency,
      required this.decimalPlaces,
      this.minRateLimit,
      this.maxRateLimit,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['currency_code'] = Variable<String>(currencyCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['symbol'] = Variable<String>(symbol);
    map['fraction_name_ar'] = Variable<String>(fractionNameAr);
    map['fraction_name_en'] = Variable<String>(fractionNameEn);
    map['exchange_rate'] = Variable<double>(exchangeRate);
    map['is_base_currency'] = Variable<bool>(isBaseCurrency);
    map['decimal_places'] = Variable<int>(decimalPlaces);
    if (!nullToAbsent || minRateLimit != null) {
      map['min_rate_limit'] = Variable<double>(minRateLimit);
    }
    if (!nullToAbsent || maxRateLimit != null) {
      map['max_rate_limit'] = Variable<double>(maxRateLimit);
    }
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  CurrenciesCompanion toCompanion(bool nullToAbsent) {
    return CurrenciesCompanion(
      currencyCode: Value(currencyCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      symbol: Value(symbol),
      fractionNameAr: Value(fractionNameAr),
      fractionNameEn: Value(fractionNameEn),
      exchangeRate: Value(exchangeRate),
      isBaseCurrency: Value(isBaseCurrency),
      decimalPlaces: Value(decimalPlaces),
      minRateLimit: minRateLimit == null && nullToAbsent
          ? const Value.absent()
          : Value(minRateLimit),
      maxRateLimit: maxRateLimit == null && nullToAbsent
          ? const Value.absent()
          : Value(maxRateLimit),
      isActive: Value(isActive),
    );
  }

  factory Currency.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Currency(
      currencyCode: serializer.fromJson<String>(json['currency_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      symbol: serializer.fromJson<String>(json['symbol']),
      fractionNameAr: serializer.fromJson<String>(json['fraction_name_ar']),
      fractionNameEn: serializer.fromJson<String>(json['fraction_name_en']),
      exchangeRate: serializer.fromJson<double>(json['exchange_rate']),
      isBaseCurrency: serializer.fromJson<bool>(json['is_base_currency']),
      decimalPlaces: serializer.fromJson<int>(json['decimal_places']),
      minRateLimit: serializer.fromJson<double?>(json['min_rate_limit']),
      maxRateLimit: serializer.fromJson<double?>(json['max_rate_limit']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'currency_code': serializer.toJson<String>(currencyCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'symbol': serializer.toJson<String>(symbol),
      'fraction_name_ar': serializer.toJson<String>(fractionNameAr),
      'fraction_name_en': serializer.toJson<String>(fractionNameEn),
      'exchange_rate': serializer.toJson<double>(exchangeRate),
      'is_base_currency': serializer.toJson<bool>(isBaseCurrency),
      'decimal_places': serializer.toJson<int>(decimalPlaces),
      'min_rate_limit': serializer.toJson<double?>(minRateLimit),
      'max_rate_limit': serializer.toJson<double?>(maxRateLimit),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  Currency copyWith(
          {String? currencyCode,
          String? nameAr,
          String? nameEn,
          String? symbol,
          String? fractionNameAr,
          String? fractionNameEn,
          double? exchangeRate,
          bool? isBaseCurrency,
          int? decimalPlaces,
          Value<double?> minRateLimit = const Value.absent(),
          Value<double?> maxRateLimit = const Value.absent(),
          bool? isActive}) =>
      Currency(
        currencyCode: currencyCode ?? this.currencyCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        symbol: symbol ?? this.symbol,
        fractionNameAr: fractionNameAr ?? this.fractionNameAr,
        fractionNameEn: fractionNameEn ?? this.fractionNameEn,
        exchangeRate: exchangeRate ?? this.exchangeRate,
        isBaseCurrency: isBaseCurrency ?? this.isBaseCurrency,
        decimalPlaces: decimalPlaces ?? this.decimalPlaces,
        minRateLimit:
            minRateLimit.present ? minRateLimit.value : this.minRateLimit,
        maxRateLimit:
            maxRateLimit.present ? maxRateLimit.value : this.maxRateLimit,
        isActive: isActive ?? this.isActive,
      );
  Currency copyWithCompanion(CurrenciesCompanion data) {
    return Currency(
      currencyCode: data.currencyCode.present
          ? data.currencyCode.value
          : this.currencyCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      symbol: data.symbol.present ? data.symbol.value : this.symbol,
      fractionNameAr: data.fractionNameAr.present
          ? data.fractionNameAr.value
          : this.fractionNameAr,
      fractionNameEn: data.fractionNameEn.present
          ? data.fractionNameEn.value
          : this.fractionNameEn,
      exchangeRate: data.exchangeRate.present
          ? data.exchangeRate.value
          : this.exchangeRate,
      isBaseCurrency: data.isBaseCurrency.present
          ? data.isBaseCurrency.value
          : this.isBaseCurrency,
      decimalPlaces: data.decimalPlaces.present
          ? data.decimalPlaces.value
          : this.decimalPlaces,
      minRateLimit: data.minRateLimit.present
          ? data.minRateLimit.value
          : this.minRateLimit,
      maxRateLimit: data.maxRateLimit.present
          ? data.maxRateLimit.value
          : this.maxRateLimit,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Currency(')
          ..write('currencyCode: $currencyCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('symbol: $symbol, ')
          ..write('fractionNameAr: $fractionNameAr, ')
          ..write('fractionNameEn: $fractionNameEn, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('isBaseCurrency: $isBaseCurrency, ')
          ..write('decimalPlaces: $decimalPlaces, ')
          ..write('minRateLimit: $minRateLimit, ')
          ..write('maxRateLimit: $maxRateLimit, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      currencyCode,
      nameAr,
      nameEn,
      symbol,
      fractionNameAr,
      fractionNameEn,
      exchangeRate,
      isBaseCurrency,
      decimalPlaces,
      minRateLimit,
      maxRateLimit,
      isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Currency &&
          other.currencyCode == this.currencyCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.symbol == this.symbol &&
          other.fractionNameAr == this.fractionNameAr &&
          other.fractionNameEn == this.fractionNameEn &&
          other.exchangeRate == this.exchangeRate &&
          other.isBaseCurrency == this.isBaseCurrency &&
          other.decimalPlaces == this.decimalPlaces &&
          other.minRateLimit == this.minRateLimit &&
          other.maxRateLimit == this.maxRateLimit &&
          other.isActive == this.isActive);
}

class CurrenciesCompanion extends UpdateCompanion<Currency> {
  final Value<String> currencyCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String> symbol;
  final Value<String> fractionNameAr;
  final Value<String> fractionNameEn;
  final Value<double> exchangeRate;
  final Value<bool> isBaseCurrency;
  final Value<int> decimalPlaces;
  final Value<double?> minRateLimit;
  final Value<double?> maxRateLimit;
  final Value<bool> isActive;
  final Value<int> rowid;
  const CurrenciesCompanion({
    this.currencyCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.symbol = const Value.absent(),
    this.fractionNameAr = const Value.absent(),
    this.fractionNameEn = const Value.absent(),
    this.exchangeRate = const Value.absent(),
    this.isBaseCurrency = const Value.absent(),
    this.decimalPlaces = const Value.absent(),
    this.minRateLimit = const Value.absent(),
    this.maxRateLimit = const Value.absent(),
    this.isActive = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CurrenciesCompanion.insert({
    required String currencyCode,
    required String nameAr,
    required String nameEn,
    required String symbol,
    required String fractionNameAr,
    required String fractionNameEn,
    required double exchangeRate,
    this.isBaseCurrency = const Value.absent(),
    required int decimalPlaces,
    this.minRateLimit = const Value.absent(),
    this.maxRateLimit = const Value.absent(),
    required bool isActive,
    this.rowid = const Value.absent(),
  })  : currencyCode = Value(currencyCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        symbol = Value(symbol),
        fractionNameAr = Value(fractionNameAr),
        fractionNameEn = Value(fractionNameEn),
        exchangeRate = Value(exchangeRate),
        decimalPlaces = Value(decimalPlaces),
        isActive = Value(isActive);
  static Insertable<Currency> custom({
    Expression<String>? currencyCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? symbol,
    Expression<String>? fractionNameAr,
    Expression<String>? fractionNameEn,
    Expression<double>? exchangeRate,
    Expression<bool>? isBaseCurrency,
    Expression<int>? decimalPlaces,
    Expression<double>? minRateLimit,
    Expression<double>? maxRateLimit,
    Expression<bool>? isActive,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (currencyCode != null) 'currency_code': currencyCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (symbol != null) 'symbol': symbol,
      if (fractionNameAr != null) 'fraction_name_ar': fractionNameAr,
      if (fractionNameEn != null) 'fraction_name_en': fractionNameEn,
      if (exchangeRate != null) 'exchange_rate': exchangeRate,
      if (isBaseCurrency != null) 'is_base_currency': isBaseCurrency,
      if (decimalPlaces != null) 'decimal_places': decimalPlaces,
      if (minRateLimit != null) 'min_rate_limit': minRateLimit,
      if (maxRateLimit != null) 'max_rate_limit': maxRateLimit,
      if (isActive != null) 'is_active': isActive,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CurrenciesCompanion copyWith(
      {Value<String>? currencyCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String>? symbol,
      Value<String>? fractionNameAr,
      Value<String>? fractionNameEn,
      Value<double>? exchangeRate,
      Value<bool>? isBaseCurrency,
      Value<int>? decimalPlaces,
      Value<double?>? minRateLimit,
      Value<double?>? maxRateLimit,
      Value<bool>? isActive,
      Value<int>? rowid}) {
    return CurrenciesCompanion(
      currencyCode: currencyCode ?? this.currencyCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      symbol: symbol ?? this.symbol,
      fractionNameAr: fractionNameAr ?? this.fractionNameAr,
      fractionNameEn: fractionNameEn ?? this.fractionNameEn,
      exchangeRate: exchangeRate ?? this.exchangeRate,
      isBaseCurrency: isBaseCurrency ?? this.isBaseCurrency,
      decimalPlaces: decimalPlaces ?? this.decimalPlaces,
      minRateLimit: minRateLimit ?? this.minRateLimit,
      maxRateLimit: maxRateLimit ?? this.maxRateLimit,
      isActive: isActive ?? this.isActive,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (currencyCode.present) {
      map['currency_code'] = Variable<String>(currencyCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (symbol.present) {
      map['symbol'] = Variable<String>(symbol.value);
    }
    if (fractionNameAr.present) {
      map['fraction_name_ar'] = Variable<String>(fractionNameAr.value);
    }
    if (fractionNameEn.present) {
      map['fraction_name_en'] = Variable<String>(fractionNameEn.value);
    }
    if (exchangeRate.present) {
      map['exchange_rate'] = Variable<double>(exchangeRate.value);
    }
    if (isBaseCurrency.present) {
      map['is_base_currency'] = Variable<bool>(isBaseCurrency.value);
    }
    if (decimalPlaces.present) {
      map['decimal_places'] = Variable<int>(decimalPlaces.value);
    }
    if (minRateLimit.present) {
      map['min_rate_limit'] = Variable<double>(minRateLimit.value);
    }
    if (maxRateLimit.present) {
      map['max_rate_limit'] = Variable<double>(maxRateLimit.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CurrenciesCompanion(')
          ..write('currencyCode: $currencyCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('symbol: $symbol, ')
          ..write('fractionNameAr: $fractionNameAr, ')
          ..write('fractionNameEn: $fractionNameEn, ')
          ..write('exchangeRate: $exchangeRate, ')
          ..write('isBaseCurrency: $isBaseCurrency, ')
          ..write('decimalPlaces: $decimalPlaces, ')
          ..write('minRateLimit: $minRateLimit, ')
          ..write('maxRateLimit: $maxRateLimit, ')
          ..write('isActive: $isActive, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class CurrencyDenominations extends Table
    with TableInfo<CurrencyDenominations, CurrencyDenomination> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  CurrencyDenominations(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _currencyCodeMeta =
      const VerificationMeta('currencyCode');
  late final GeneratedColumn<String> currencyCode = GeneratedColumn<String>(
      'currency_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES currencies(currency_code)');
  static const VerificationMeta _denominationValueMeta =
      const VerificationMeta('denominationValue');
  late final GeneratedColumn<double> denominationValue =
      GeneratedColumn<double>('denomination_value', aliasedName, false,
          type: DriftSqlType.double,
          requiredDuringInsert: true,
          $customConstraints: 'NOT NULL');
  static const VerificationMeta _denominationNameArMeta =
      const VerificationMeta('denominationNameAr');
  late final GeneratedColumn<String> denominationNameAr =
      GeneratedColumn<String>('denomination_name_ar', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints: 'NOT NULL');
  static const VerificationMeta _denominationNameEnMeta =
      const VerificationMeta('denominationNameEn');
  late final GeneratedColumn<String> denominationNameEn =
      GeneratedColumn<String>('denomination_name_en', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints: 'NOT NULL');
  static const VerificationMeta _denominationTypeMeta =
      const VerificationMeta('denominationType');
  late final GeneratedColumn<String> denominationType = GeneratedColumn<String>(
      'denomination_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        currencyCode,
        denominationValue,
        denominationNameAr,
        denominationNameEn,
        denominationType
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'currency_denominations';
  @override
  VerificationContext validateIntegrity(
      Insertable<CurrencyDenomination> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('currency_code')) {
      context.handle(
          _currencyCodeMeta,
          currencyCode.isAcceptableOrUnknown(
              data['currency_code']!, _currencyCodeMeta));
    } else if (isInserting) {
      context.missing(_currencyCodeMeta);
    }
    if (data.containsKey('denomination_value')) {
      context.handle(
          _denominationValueMeta,
          denominationValue.isAcceptableOrUnknown(
              data['denomination_value']!, _denominationValueMeta));
    } else if (isInserting) {
      context.missing(_denominationValueMeta);
    }
    if (data.containsKey('denomination_name_ar')) {
      context.handle(
          _denominationNameArMeta,
          denominationNameAr.isAcceptableOrUnknown(
              data['denomination_name_ar']!, _denominationNameArMeta));
    } else if (isInserting) {
      context.missing(_denominationNameArMeta);
    }
    if (data.containsKey('denomination_name_en')) {
      context.handle(
          _denominationNameEnMeta,
          denominationNameEn.isAcceptableOrUnknown(
              data['denomination_name_en']!, _denominationNameEnMeta));
    } else if (isInserting) {
      context.missing(_denominationNameEnMeta);
    }
    if (data.containsKey('denomination_type')) {
      context.handle(
          _denominationTypeMeta,
          denominationType.isAcceptableOrUnknown(
              data['denomination_type']!, _denominationTypeMeta));
    } else if (isInserting) {
      context.missing(_denominationTypeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CurrencyDenomination map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CurrencyDenomination(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      currencyCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}currency_code'])!,
      denominationValue: attachedDatabase.typeMapping.read(
          DriftSqlType.double, data['${effectivePrefix}denomination_value'])!,
      denominationNameAr: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}denomination_name_ar'])!,
      denominationNameEn: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}denomination_name_en'])!,
      denominationType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}denomination_type'])!,
    );
  }

  @override
  CurrencyDenominations createAlias(String alias) {
    return CurrencyDenominations(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class CurrencyDenomination extends DataClass
    implements Insertable<CurrencyDenomination> {
  final int id;
  final String currencyCode;
  final double denominationValue;
  final String denominationNameAr;
  final String denominationNameEn;
  final String denominationType;
  const CurrencyDenomination(
      {required this.id,
      required this.currencyCode,
      required this.denominationValue,
      required this.denominationNameAr,
      required this.denominationNameEn,
      required this.denominationType});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['currency_code'] = Variable<String>(currencyCode);
    map['denomination_value'] = Variable<double>(denominationValue);
    map['denomination_name_ar'] = Variable<String>(denominationNameAr);
    map['denomination_name_en'] = Variable<String>(denominationNameEn);
    map['denomination_type'] = Variable<String>(denominationType);
    return map;
  }

  CurrencyDenominationsCompanion toCompanion(bool nullToAbsent) {
    return CurrencyDenominationsCompanion(
      id: Value(id),
      currencyCode: Value(currencyCode),
      denominationValue: Value(denominationValue),
      denominationNameAr: Value(denominationNameAr),
      denominationNameEn: Value(denominationNameEn),
      denominationType: Value(denominationType),
    );
  }

  factory CurrencyDenomination.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CurrencyDenomination(
      id: serializer.fromJson<int>(json['id']),
      currencyCode: serializer.fromJson<String>(json['currency_code']),
      denominationValue:
          serializer.fromJson<double>(json['denomination_value']),
      denominationNameAr:
          serializer.fromJson<String>(json['denomination_name_ar']),
      denominationNameEn:
          serializer.fromJson<String>(json['denomination_name_en']),
      denominationType: serializer.fromJson<String>(json['denomination_type']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'currency_code': serializer.toJson<String>(currencyCode),
      'denomination_value': serializer.toJson<double>(denominationValue),
      'denomination_name_ar': serializer.toJson<String>(denominationNameAr),
      'denomination_name_en': serializer.toJson<String>(denominationNameEn),
      'denomination_type': serializer.toJson<String>(denominationType),
    };
  }

  CurrencyDenomination copyWith(
          {int? id,
          String? currencyCode,
          double? denominationValue,
          String? denominationNameAr,
          String? denominationNameEn,
          String? denominationType}) =>
      CurrencyDenomination(
        id: id ?? this.id,
        currencyCode: currencyCode ?? this.currencyCode,
        denominationValue: denominationValue ?? this.denominationValue,
        denominationNameAr: denominationNameAr ?? this.denominationNameAr,
        denominationNameEn: denominationNameEn ?? this.denominationNameEn,
        denominationType: denominationType ?? this.denominationType,
      );
  CurrencyDenomination copyWithCompanion(CurrencyDenominationsCompanion data) {
    return CurrencyDenomination(
      id: data.id.present ? data.id.value : this.id,
      currencyCode: data.currencyCode.present
          ? data.currencyCode.value
          : this.currencyCode,
      denominationValue: data.denominationValue.present
          ? data.denominationValue.value
          : this.denominationValue,
      denominationNameAr: data.denominationNameAr.present
          ? data.denominationNameAr.value
          : this.denominationNameAr,
      denominationNameEn: data.denominationNameEn.present
          ? data.denominationNameEn.value
          : this.denominationNameEn,
      denominationType: data.denominationType.present
          ? data.denominationType.value
          : this.denominationType,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CurrencyDenomination(')
          ..write('id: $id, ')
          ..write('currencyCode: $currencyCode, ')
          ..write('denominationValue: $denominationValue, ')
          ..write('denominationNameAr: $denominationNameAr, ')
          ..write('denominationNameEn: $denominationNameEn, ')
          ..write('denominationType: $denominationType')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, currencyCode, denominationValue,
      denominationNameAr, denominationNameEn, denominationType);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CurrencyDenomination &&
          other.id == this.id &&
          other.currencyCode == this.currencyCode &&
          other.denominationValue == this.denominationValue &&
          other.denominationNameAr == this.denominationNameAr &&
          other.denominationNameEn == this.denominationNameEn &&
          other.denominationType == this.denominationType);
}

class CurrencyDenominationsCompanion
    extends UpdateCompanion<CurrencyDenomination> {
  final Value<int> id;
  final Value<String> currencyCode;
  final Value<double> denominationValue;
  final Value<String> denominationNameAr;
  final Value<String> denominationNameEn;
  final Value<String> denominationType;
  const CurrencyDenominationsCompanion({
    this.id = const Value.absent(),
    this.currencyCode = const Value.absent(),
    this.denominationValue = const Value.absent(),
    this.denominationNameAr = const Value.absent(),
    this.denominationNameEn = const Value.absent(),
    this.denominationType = const Value.absent(),
  });
  CurrencyDenominationsCompanion.insert({
    this.id = const Value.absent(),
    required String currencyCode,
    required double denominationValue,
    required String denominationNameAr,
    required String denominationNameEn,
    required String denominationType,
  })  : currencyCode = Value(currencyCode),
        denominationValue = Value(denominationValue),
        denominationNameAr = Value(denominationNameAr),
        denominationNameEn = Value(denominationNameEn),
        denominationType = Value(denominationType);
  static Insertable<CurrencyDenomination> custom({
    Expression<int>? id,
    Expression<String>? currencyCode,
    Expression<double>? denominationValue,
    Expression<String>? denominationNameAr,
    Expression<String>? denominationNameEn,
    Expression<String>? denominationType,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (currencyCode != null) 'currency_code': currencyCode,
      if (denominationValue != null) 'denomination_value': denominationValue,
      if (denominationNameAr != null)
        'denomination_name_ar': denominationNameAr,
      if (denominationNameEn != null)
        'denomination_name_en': denominationNameEn,
      if (denominationType != null) 'denomination_type': denominationType,
    });
  }

  CurrencyDenominationsCompanion copyWith(
      {Value<int>? id,
      Value<String>? currencyCode,
      Value<double>? denominationValue,
      Value<String>? denominationNameAr,
      Value<String>? denominationNameEn,
      Value<String>? denominationType}) {
    return CurrencyDenominationsCompanion(
      id: id ?? this.id,
      currencyCode: currencyCode ?? this.currencyCode,
      denominationValue: denominationValue ?? this.denominationValue,
      denominationNameAr: denominationNameAr ?? this.denominationNameAr,
      denominationNameEn: denominationNameEn ?? this.denominationNameEn,
      denominationType: denominationType ?? this.denominationType,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (currencyCode.present) {
      map['currency_code'] = Variable<String>(currencyCode.value);
    }
    if (denominationValue.present) {
      map['denomination_value'] = Variable<double>(denominationValue.value);
    }
    if (denominationNameAr.present) {
      map['denomination_name_ar'] = Variable<String>(denominationNameAr.value);
    }
    if (denominationNameEn.present) {
      map['denomination_name_en'] = Variable<String>(denominationNameEn.value);
    }
    if (denominationType.present) {
      map['denomination_type'] = Variable<String>(denominationType.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CurrencyDenominationsCompanion(')
          ..write('id: $id, ')
          ..write('currencyCode: $currencyCode, ')
          ..write('denominationValue: $denominationValue, ')
          ..write('denominationNameAr: $denominationNameAr, ')
          ..write('denominationNameEn: $denominationNameEn, ')
          ..write('denominationType: $denominationType')
          ..write(')'))
        .toString();
  }
}

class TaxBracket extends Table with TableInfo<TaxBracket, TaxBracketData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  TaxBracket(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _bracketCodeMeta =
      const VerificationMeta('bracketCode');
  late final GeneratedColumn<String> bracketCode = GeneratedColumn<String>(
      'bracket_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _taxRateMeta =
      const VerificationMeta('taxRate');
  late final GeneratedColumn<double> taxRate = GeneratedColumn<double>(
      'tax_rate', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _isCompoundMeta =
      const VerificationMeta('isCompound');
  late final GeneratedColumn<bool> isCompound = GeneratedColumn<bool>(
      'is_compound', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _isDefaultMeta =
      const VerificationMeta('isDefault');
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
      'is_default', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  @override
  List<GeneratedColumn> get $columns =>
      [bracketCode, nameAr, nameEn, taxRate, isCompound, isDefault];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tax_bracket';
  @override
  VerificationContext validateIntegrity(Insertable<TaxBracketData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('bracket_code')) {
      context.handle(
          _bracketCodeMeta,
          bracketCode.isAcceptableOrUnknown(
              data['bracket_code']!, _bracketCodeMeta));
    } else if (isInserting) {
      context.missing(_bracketCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('tax_rate')) {
      context.handle(_taxRateMeta,
          taxRate.isAcceptableOrUnknown(data['tax_rate']!, _taxRateMeta));
    } else if (isInserting) {
      context.missing(_taxRateMeta);
    }
    if (data.containsKey('is_compound')) {
      context.handle(
          _isCompoundMeta,
          isCompound.isAcceptableOrUnknown(
              data['is_compound']!, _isCompoundMeta));
    }
    if (data.containsKey('is_default')) {
      context.handle(_isDefaultMeta,
          isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {bracketCode};
  @override
  TaxBracketData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaxBracketData(
      bracketCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}bracket_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      taxRate: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}tax_rate'])!,
      isCompound: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_compound'])!,
      isDefault: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_default'])!,
    );
  }

  @override
  TaxBracket createAlias(String alias) {
    return TaxBracket(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class TaxBracketData extends DataClass implements Insertable<TaxBracketData> {
  final String bracketCode;
  final String nameAr;
  final String nameEn;
  final double taxRate;
  final bool isCompound;
  final bool isDefault;
  const TaxBracketData(
      {required this.bracketCode,
      required this.nameAr,
      required this.nameEn,
      required this.taxRate,
      required this.isCompound,
      required this.isDefault});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['bracket_code'] = Variable<String>(bracketCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['tax_rate'] = Variable<double>(taxRate);
    map['is_compound'] = Variable<bool>(isCompound);
    map['is_default'] = Variable<bool>(isDefault);
    return map;
  }

  TaxBracketCompanion toCompanion(bool nullToAbsent) {
    return TaxBracketCompanion(
      bracketCode: Value(bracketCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      taxRate: Value(taxRate),
      isCompound: Value(isCompound),
      isDefault: Value(isDefault),
    );
  }

  factory TaxBracketData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaxBracketData(
      bracketCode: serializer.fromJson<String>(json['bracket_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      taxRate: serializer.fromJson<double>(json['tax_rate']),
      isCompound: serializer.fromJson<bool>(json['is_compound']),
      isDefault: serializer.fromJson<bool>(json['is_default']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'bracket_code': serializer.toJson<String>(bracketCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'tax_rate': serializer.toJson<double>(taxRate),
      'is_compound': serializer.toJson<bool>(isCompound),
      'is_default': serializer.toJson<bool>(isDefault),
    };
  }

  TaxBracketData copyWith(
          {String? bracketCode,
          String? nameAr,
          String? nameEn,
          double? taxRate,
          bool? isCompound,
          bool? isDefault}) =>
      TaxBracketData(
        bracketCode: bracketCode ?? this.bracketCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        taxRate: taxRate ?? this.taxRate,
        isCompound: isCompound ?? this.isCompound,
        isDefault: isDefault ?? this.isDefault,
      );
  TaxBracketData copyWithCompanion(TaxBracketCompanion data) {
    return TaxBracketData(
      bracketCode:
          data.bracketCode.present ? data.bracketCode.value : this.bracketCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      taxRate: data.taxRate.present ? data.taxRate.value : this.taxRate,
      isCompound:
          data.isCompound.present ? data.isCompound.value : this.isCompound,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TaxBracketData(')
          ..write('bracketCode: $bracketCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('taxRate: $taxRate, ')
          ..write('isCompound: $isCompound, ')
          ..write('isDefault: $isDefault')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(bracketCode, nameAr, nameEn, taxRate, isCompound, isDefault);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaxBracketData &&
          other.bracketCode == this.bracketCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.taxRate == this.taxRate &&
          other.isCompound == this.isCompound &&
          other.isDefault == this.isDefault);
}

class TaxBracketCompanion extends UpdateCompanion<TaxBracketData> {
  final Value<String> bracketCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<double> taxRate;
  final Value<bool> isCompound;
  final Value<bool> isDefault;
  final Value<int> rowid;
  const TaxBracketCompanion({
    this.bracketCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.taxRate = const Value.absent(),
    this.isCompound = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaxBracketCompanion.insert({
    required String bracketCode,
    required String nameAr,
    required String nameEn,
    required double taxRate,
    this.isCompound = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : bracketCode = Value(bracketCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        taxRate = Value(taxRate);
  static Insertable<TaxBracketData> custom({
    Expression<String>? bracketCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<double>? taxRate,
    Expression<bool>? isCompound,
    Expression<bool>? isDefault,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (bracketCode != null) 'bracket_code': bracketCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (taxRate != null) 'tax_rate': taxRate,
      if (isCompound != null) 'is_compound': isCompound,
      if (isDefault != null) 'is_default': isDefault,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaxBracketCompanion copyWith(
      {Value<String>? bracketCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<double>? taxRate,
      Value<bool>? isCompound,
      Value<bool>? isDefault,
      Value<int>? rowid}) {
    return TaxBracketCompanion(
      bracketCode: bracketCode ?? this.bracketCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      taxRate: taxRate ?? this.taxRate,
      isCompound: isCompound ?? this.isCompound,
      isDefault: isDefault ?? this.isDefault,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (bracketCode.present) {
      map['bracket_code'] = Variable<String>(bracketCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (taxRate.present) {
      map['tax_rate'] = Variable<double>(taxRate.value);
    }
    if (isCompound.present) {
      map['is_compound'] = Variable<bool>(isCompound.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaxBracketCompanion(')
          ..write('bracketCode: $bracketCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('taxRate: $taxRate, ')
          ..write('isCompound: $isCompound, ')
          ..write('isDefault: $isDefault, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class TaxCalcMethods extends Table
    with TableInfo<TaxCalcMethods, TaxCalcMethod> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  TaxCalcMethods(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _methodCodeMeta =
      const VerificationMeta('methodCode');
  late final GeneratedColumn<String> methodCode = GeneratedColumn<String>(
      'method_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _categoryMeta =
      const VerificationMeta('category');
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
      'category', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [methodCode, nameAr, nameEn, category];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tax_calc_methods';
  @override
  VerificationContext validateIntegrity(Insertable<TaxCalcMethod> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('method_code')) {
      context.handle(
          _methodCodeMeta,
          methodCode.isAcceptableOrUnknown(
              data['method_code']!, _methodCodeMeta));
    } else if (isInserting) {
      context.missing(_methodCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('category')) {
      context.handle(_categoryMeta,
          category.isAcceptableOrUnknown(data['category']!, _categoryMeta));
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {methodCode};
  @override
  TaxCalcMethod map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaxCalcMethod(
      methodCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}method_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      category: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}category'])!,
    );
  }

  @override
  TaxCalcMethods createAlias(String alias) {
    return TaxCalcMethods(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class TaxCalcMethod extends DataClass implements Insertable<TaxCalcMethod> {
  final String methodCode;
  final String nameAr;
  final String nameEn;
  final String category;
  const TaxCalcMethod(
      {required this.methodCode,
      required this.nameAr,
      required this.nameEn,
      required this.category});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['method_code'] = Variable<String>(methodCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['category'] = Variable<String>(category);
    return map;
  }

  TaxCalcMethodsCompanion toCompanion(bool nullToAbsent) {
    return TaxCalcMethodsCompanion(
      methodCode: Value(methodCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      category: Value(category),
    );
  }

  factory TaxCalcMethod.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaxCalcMethod(
      methodCode: serializer.fromJson<String>(json['method_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      category: serializer.fromJson<String>(json['category']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'method_code': serializer.toJson<String>(methodCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'category': serializer.toJson<String>(category),
    };
  }

  TaxCalcMethod copyWith(
          {String? methodCode,
          String? nameAr,
          String? nameEn,
          String? category}) =>
      TaxCalcMethod(
        methodCode: methodCode ?? this.methodCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        category: category ?? this.category,
      );
  TaxCalcMethod copyWithCompanion(TaxCalcMethodsCompanion data) {
    return TaxCalcMethod(
      methodCode:
          data.methodCode.present ? data.methodCode.value : this.methodCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      category: data.category.present ? data.category.value : this.category,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TaxCalcMethod(')
          ..write('methodCode: $methodCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('category: $category')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(methodCode, nameAr, nameEn, category);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaxCalcMethod &&
          other.methodCode == this.methodCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.category == this.category);
}

class TaxCalcMethodsCompanion extends UpdateCompanion<TaxCalcMethod> {
  final Value<String> methodCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String> category;
  final Value<int> rowid;
  const TaxCalcMethodsCompanion({
    this.methodCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.category = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaxCalcMethodsCompanion.insert({
    required String methodCode,
    required String nameAr,
    required String nameEn,
    required String category,
    this.rowid = const Value.absent(),
  })  : methodCode = Value(methodCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        category = Value(category);
  static Insertable<TaxCalcMethod> custom({
    Expression<String>? methodCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? category,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (methodCode != null) 'method_code': methodCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (category != null) 'category': category,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaxCalcMethodsCompanion copyWith(
      {Value<String>? methodCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String>? category,
      Value<int>? rowid}) {
    return TaxCalcMethodsCompanion(
      methodCode: methodCode ?? this.methodCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      category: category ?? this.category,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (methodCode.present) {
      map['method_code'] = Variable<String>(methodCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaxCalcMethodsCompanion(')
          ..write('methodCode: $methodCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('category: $category, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class TaxTypes extends Table with TableInfo<TaxTypes, TaxType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  TaxTypes(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _typeCodeMeta =
      const VerificationMeta('typeCode');
  late final GeneratedColumn<String> typeCode = GeneratedColumn<String>(
      'type_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _calcMethodCodeMeta =
      const VerificationMeta('calcMethodCode');
  late final GeneratedColumn<String> calcMethodCode = GeneratedColumn<String>(
      'calc_method_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES tax_calc_methods(method_code)');
  static const VerificationMeta _salesAccountIdMeta =
      const VerificationMeta('salesAccountId');
  late final GeneratedColumn<String> salesAccountId = GeneratedColumn<String>(
      'sales_account_id', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _purchasesAccountIdMeta =
      const VerificationMeta('purchasesAccountId');
  late final GeneratedColumn<String> purchasesAccountId =
      GeneratedColumn<String>('purchases_account_id', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        typeCode,
        nameAr,
        nameEn,
        calcMethodCode,
        salesAccountId,
        purchasesAccountId
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tax_types';
  @override
  VerificationContext validateIntegrity(Insertable<TaxType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('type_code')) {
      context.handle(_typeCodeMeta,
          typeCode.isAcceptableOrUnknown(data['type_code']!, _typeCodeMeta));
    } else if (isInserting) {
      context.missing(_typeCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('calc_method_code')) {
      context.handle(
          _calcMethodCodeMeta,
          calcMethodCode.isAcceptableOrUnknown(
              data['calc_method_code']!, _calcMethodCodeMeta));
    } else if (isInserting) {
      context.missing(_calcMethodCodeMeta);
    }
    if (data.containsKey('sales_account_id')) {
      context.handle(
          _salesAccountIdMeta,
          salesAccountId.isAcceptableOrUnknown(
              data['sales_account_id']!, _salesAccountIdMeta));
    }
    if (data.containsKey('purchases_account_id')) {
      context.handle(
          _purchasesAccountIdMeta,
          purchasesAccountId.isAcceptableOrUnknown(
              data['purchases_account_id']!, _purchasesAccountIdMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {typeCode};
  @override
  TaxType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TaxType(
      typeCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      calcMethodCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}calc_method_code'])!,
      salesAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sales_account_id']),
      purchasesAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}purchases_account_id']),
    );
  }

  @override
  TaxTypes createAlias(String alias) {
    return TaxTypes(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class TaxType extends DataClass implements Insertable<TaxType> {
  final String typeCode;
  final String nameAr;
  final String nameEn;
  final String calcMethodCode;
  final String? salesAccountId;
  final String? purchasesAccountId;
  const TaxType(
      {required this.typeCode,
      required this.nameAr,
      required this.nameEn,
      required this.calcMethodCode,
      this.salesAccountId,
      this.purchasesAccountId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['type_code'] = Variable<String>(typeCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['calc_method_code'] = Variable<String>(calcMethodCode);
    if (!nullToAbsent || salesAccountId != null) {
      map['sales_account_id'] = Variable<String>(salesAccountId);
    }
    if (!nullToAbsent || purchasesAccountId != null) {
      map['purchases_account_id'] = Variable<String>(purchasesAccountId);
    }
    return map;
  }

  TaxTypesCompanion toCompanion(bool nullToAbsent) {
    return TaxTypesCompanion(
      typeCode: Value(typeCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      calcMethodCode: Value(calcMethodCode),
      salesAccountId: salesAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(salesAccountId),
      purchasesAccountId: purchasesAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(purchasesAccountId),
    );
  }

  factory TaxType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TaxType(
      typeCode: serializer.fromJson<String>(json['type_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      calcMethodCode: serializer.fromJson<String>(json['calc_method_code']),
      salesAccountId: serializer.fromJson<String?>(json['sales_account_id']),
      purchasesAccountId:
          serializer.fromJson<String?>(json['purchases_account_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'type_code': serializer.toJson<String>(typeCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'calc_method_code': serializer.toJson<String>(calcMethodCode),
      'sales_account_id': serializer.toJson<String?>(salesAccountId),
      'purchases_account_id': serializer.toJson<String?>(purchasesAccountId),
    };
  }

  TaxType copyWith(
          {String? typeCode,
          String? nameAr,
          String? nameEn,
          String? calcMethodCode,
          Value<String?> salesAccountId = const Value.absent(),
          Value<String?> purchasesAccountId = const Value.absent()}) =>
      TaxType(
        typeCode: typeCode ?? this.typeCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        calcMethodCode: calcMethodCode ?? this.calcMethodCode,
        salesAccountId:
            salesAccountId.present ? salesAccountId.value : this.salesAccountId,
        purchasesAccountId: purchasesAccountId.present
            ? purchasesAccountId.value
            : this.purchasesAccountId,
      );
  TaxType copyWithCompanion(TaxTypesCompanion data) {
    return TaxType(
      typeCode: data.typeCode.present ? data.typeCode.value : this.typeCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      calcMethodCode: data.calcMethodCode.present
          ? data.calcMethodCode.value
          : this.calcMethodCode,
      salesAccountId: data.salesAccountId.present
          ? data.salesAccountId.value
          : this.salesAccountId,
      purchasesAccountId: data.purchasesAccountId.present
          ? data.purchasesAccountId.value
          : this.purchasesAccountId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TaxType(')
          ..write('typeCode: $typeCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('calcMethodCode: $calcMethodCode, ')
          ..write('salesAccountId: $salesAccountId, ')
          ..write('purchasesAccountId: $purchasesAccountId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(typeCode, nameAr, nameEn, calcMethodCode,
      salesAccountId, purchasesAccountId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TaxType &&
          other.typeCode == this.typeCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.calcMethodCode == this.calcMethodCode &&
          other.salesAccountId == this.salesAccountId &&
          other.purchasesAccountId == this.purchasesAccountId);
}

class TaxTypesCompanion extends UpdateCompanion<TaxType> {
  final Value<String> typeCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String> calcMethodCode;
  final Value<String?> salesAccountId;
  final Value<String?> purchasesAccountId;
  final Value<int> rowid;
  const TaxTypesCompanion({
    this.typeCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.calcMethodCode = const Value.absent(),
    this.salesAccountId = const Value.absent(),
    this.purchasesAccountId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TaxTypesCompanion.insert({
    required String typeCode,
    required String nameAr,
    required String nameEn,
    required String calcMethodCode,
    this.salesAccountId = const Value.absent(),
    this.purchasesAccountId = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : typeCode = Value(typeCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        calcMethodCode = Value(calcMethodCode);
  static Insertable<TaxType> custom({
    Expression<String>? typeCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? calcMethodCode,
    Expression<String>? salesAccountId,
    Expression<String>? purchasesAccountId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (typeCode != null) 'type_code': typeCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (calcMethodCode != null) 'calc_method_code': calcMethodCode,
      if (salesAccountId != null) 'sales_account_id': salesAccountId,
      if (purchasesAccountId != null)
        'purchases_account_id': purchasesAccountId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TaxTypesCompanion copyWith(
      {Value<String>? typeCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String>? calcMethodCode,
      Value<String?>? salesAccountId,
      Value<String?>? purchasesAccountId,
      Value<int>? rowid}) {
    return TaxTypesCompanion(
      typeCode: typeCode ?? this.typeCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      calcMethodCode: calcMethodCode ?? this.calcMethodCode,
      salesAccountId: salesAccountId ?? this.salesAccountId,
      purchasesAccountId: purchasesAccountId ?? this.purchasesAccountId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (typeCode.present) {
      map['type_code'] = Variable<String>(typeCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (calcMethodCode.present) {
      map['calc_method_code'] = Variable<String>(calcMethodCode.value);
    }
    if (salesAccountId.present) {
      map['sales_account_id'] = Variable<String>(salesAccountId.value);
    }
    if (purchasesAccountId.present) {
      map['purchases_account_id'] = Variable<String>(purchasesAccountId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TaxTypesCompanion(')
          ..write('typeCode: $typeCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('calcMethodCode: $calcMethodCode, ')
          ..write('salesAccountId: $salesAccountId, ')
          ..write('purchasesAccountId: $purchasesAccountId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class Accounts extends Table with TableInfo<Accounts, Account> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Accounts(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _accountCodeMeta =
      const VerificationMeta('accountCode');
  late final GeneratedColumn<String> accountCode = GeneratedColumn<String>(
      'account_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _accountNameArMeta =
      const VerificationMeta('accountNameAr');
  late final GeneratedColumn<String> accountNameAr = GeneratedColumn<String>(
      'account_name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _accountNameEnMeta =
      const VerificationMeta('accountNameEn');
  late final GeneratedColumn<String> accountNameEn = GeneratedColumn<String>(
      'account_name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _accountTypeCodeMeta =
      const VerificationMeta('accountTypeCode');
  late final GeneratedColumn<String> accountTypeCode = GeneratedColumn<String>(
      'account_type_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _accountGroupCodeMeta =
      const VerificationMeta('accountGroupCode');
  late final GeneratedColumn<String> accountGroupCode = GeneratedColumn<String>(
      'account_group_code', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _classificationCodeMeta =
      const VerificationMeta('classificationCode');
  late final GeneratedColumn<String> classificationCode =
      GeneratedColumn<String>('classification_code', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: '');
  static const VerificationMeta _reportTypeCodeMeta =
      const VerificationMeta('reportTypeCode');
  late final GeneratedColumn<String> reportTypeCode = GeneratedColumn<String>(
      'report_type_code', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _parentAccountIdMeta =
      const VerificationMeta('parentAccountId');
  late final GeneratedColumn<int> parentAccountId = GeneratedColumn<int>(
      'parent_account_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'REFERENCES accounts(id)');
  static const VerificationMeta _isParentMeta =
      const VerificationMeta('isParent');
  late final GeneratedColumn<bool> isParent = GeneratedColumn<bool>(
      'is_parent', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _natureMeta = const VerificationMeta('nature');
  late final GeneratedColumn<String> nature = GeneratedColumn<String>(
      'nature', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _reportTypeMeta =
      const VerificationMeta('reportType');
  late final GeneratedColumn<String> reportType = GeneratedColumn<String>(
      'report_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _cashFlowTypeMeta =
      const VerificationMeta('cashFlowType');
  late final GeneratedColumn<String> cashFlowType = GeneratedColumn<String>(
      'cash_flow_type', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _detailAccountTypeMeta =
      const VerificationMeta('detailAccountType');
  late final GeneratedColumn<String> detailAccountType =
      GeneratedColumn<String>('detail_account_type', aliasedName, true,
          type: DriftSqlType.string,
          requiredDuringInsert: false,
          $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        accountCode,
        accountNameAr,
        accountNameEn,
        accountTypeCode,
        accountGroupCode,
        classificationCode,
        reportTypeCode,
        parentAccountId,
        isParent,
        isActive,
        nature,
        reportType,
        cashFlowType,
        detailAccountType
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'accounts';
  @override
  VerificationContext validateIntegrity(Insertable<Account> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('account_code')) {
      context.handle(
          _accountCodeMeta,
          accountCode.isAcceptableOrUnknown(
              data['account_code']!, _accountCodeMeta));
    } else if (isInserting) {
      context.missing(_accountCodeMeta);
    }
    if (data.containsKey('account_name_ar')) {
      context.handle(
          _accountNameArMeta,
          accountNameAr.isAcceptableOrUnknown(
              data['account_name_ar']!, _accountNameArMeta));
    } else if (isInserting) {
      context.missing(_accountNameArMeta);
    }
    if (data.containsKey('account_name_en')) {
      context.handle(
          _accountNameEnMeta,
          accountNameEn.isAcceptableOrUnknown(
              data['account_name_en']!, _accountNameEnMeta));
    } else if (isInserting) {
      context.missing(_accountNameEnMeta);
    }
    if (data.containsKey('account_type_code')) {
      context.handle(
          _accountTypeCodeMeta,
          accountTypeCode.isAcceptableOrUnknown(
              data['account_type_code']!, _accountTypeCodeMeta));
    } else if (isInserting) {
      context.missing(_accountTypeCodeMeta);
    }
    if (data.containsKey('account_group_code')) {
      context.handle(
          _accountGroupCodeMeta,
          accountGroupCode.isAcceptableOrUnknown(
              data['account_group_code']!, _accountGroupCodeMeta));
    }
    if (data.containsKey('classification_code')) {
      context.handle(
          _classificationCodeMeta,
          classificationCode.isAcceptableOrUnknown(
              data['classification_code']!, _classificationCodeMeta));
    }
    if (data.containsKey('report_type_code')) {
      context.handle(
          _reportTypeCodeMeta,
          reportTypeCode.isAcceptableOrUnknown(
              data['report_type_code']!, _reportTypeCodeMeta));
    }
    if (data.containsKey('parent_account_id')) {
      context.handle(
          _parentAccountIdMeta,
          parentAccountId.isAcceptableOrUnknown(
              data['parent_account_id']!, _parentAccountIdMeta));
    }
    if (data.containsKey('is_parent')) {
      context.handle(_isParentMeta,
          isParent.isAcceptableOrUnknown(data['is_parent']!, _isParentMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('nature')) {
      context.handle(_natureMeta,
          nature.isAcceptableOrUnknown(data['nature']!, _natureMeta));
    } else if (isInserting) {
      context.missing(_natureMeta);
    }
    if (data.containsKey('report_type')) {
      context.handle(
          _reportTypeMeta,
          reportType.isAcceptableOrUnknown(
              data['report_type']!, _reportTypeMeta));
    } else if (isInserting) {
      context.missing(_reportTypeMeta);
    }
    if (data.containsKey('cash_flow_type')) {
      context.handle(
          _cashFlowTypeMeta,
          cashFlowType.isAcceptableOrUnknown(
              data['cash_flow_type']!, _cashFlowTypeMeta));
    }
    if (data.containsKey('detail_account_type')) {
      context.handle(
          _detailAccountTypeMeta,
          detailAccountType.isAcceptableOrUnknown(
              data['detail_account_type']!, _detailAccountTypeMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Account map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Account(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      accountCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}account_code'])!,
      accountNameAr: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}account_name_ar'])!,
      accountNameEn: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}account_name_en'])!,
      accountTypeCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}account_type_code'])!,
      accountGroupCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}account_group_code']),
      classificationCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}classification_code']),
      reportTypeCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}report_type_code']),
      parentAccountId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}parent_account_id']),
      isParent: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_parent'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      nature: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nature'])!,
      reportType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}report_type'])!,
      cashFlowType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cash_flow_type']),
      detailAccountType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}detail_account_type']),
    );
  }

  @override
  Accounts createAlias(String alias) {
    return Accounts(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Account extends DataClass implements Insertable<Account> {
  final int id;
  final String accountCode;
  final String accountNameAr;
  final String accountNameEn;
  final String accountTypeCode;

  /// references removed for simplicity if missing from drift
  final String? accountGroupCode;
  final String? classificationCode;
  final String? reportTypeCode;
  final int? parentAccountId;
  final bool isParent;
  final bool isActive;
  final String nature;
  final String reportType;
  final String? cashFlowType;
  final String? detailAccountType;
  const Account(
      {required this.id,
      required this.accountCode,
      required this.accountNameAr,
      required this.accountNameEn,
      required this.accountTypeCode,
      this.accountGroupCode,
      this.classificationCode,
      this.reportTypeCode,
      this.parentAccountId,
      required this.isParent,
      required this.isActive,
      required this.nature,
      required this.reportType,
      this.cashFlowType,
      this.detailAccountType});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['account_code'] = Variable<String>(accountCode);
    map['account_name_ar'] = Variable<String>(accountNameAr);
    map['account_name_en'] = Variable<String>(accountNameEn);
    map['account_type_code'] = Variable<String>(accountTypeCode);
    if (!nullToAbsent || accountGroupCode != null) {
      map['account_group_code'] = Variable<String>(accountGroupCode);
    }
    if (!nullToAbsent || classificationCode != null) {
      map['classification_code'] = Variable<String>(classificationCode);
    }
    if (!nullToAbsent || reportTypeCode != null) {
      map['report_type_code'] = Variable<String>(reportTypeCode);
    }
    if (!nullToAbsent || parentAccountId != null) {
      map['parent_account_id'] = Variable<int>(parentAccountId);
    }
    map['is_parent'] = Variable<bool>(isParent);
    map['is_active'] = Variable<bool>(isActive);
    map['nature'] = Variable<String>(nature);
    map['report_type'] = Variable<String>(reportType);
    if (!nullToAbsent || cashFlowType != null) {
      map['cash_flow_type'] = Variable<String>(cashFlowType);
    }
    if (!nullToAbsent || detailAccountType != null) {
      map['detail_account_type'] = Variable<String>(detailAccountType);
    }
    return map;
  }

  AccountsCompanion toCompanion(bool nullToAbsent) {
    return AccountsCompanion(
      id: Value(id),
      accountCode: Value(accountCode),
      accountNameAr: Value(accountNameAr),
      accountNameEn: Value(accountNameEn),
      accountTypeCode: Value(accountTypeCode),
      accountGroupCode: accountGroupCode == null && nullToAbsent
          ? const Value.absent()
          : Value(accountGroupCode),
      classificationCode: classificationCode == null && nullToAbsent
          ? const Value.absent()
          : Value(classificationCode),
      reportTypeCode: reportTypeCode == null && nullToAbsent
          ? const Value.absent()
          : Value(reportTypeCode),
      parentAccountId: parentAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentAccountId),
      isParent: Value(isParent),
      isActive: Value(isActive),
      nature: Value(nature),
      reportType: Value(reportType),
      cashFlowType: cashFlowType == null && nullToAbsent
          ? const Value.absent()
          : Value(cashFlowType),
      detailAccountType: detailAccountType == null && nullToAbsent
          ? const Value.absent()
          : Value(detailAccountType),
    );
  }

  factory Account.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Account(
      id: serializer.fromJson<int>(json['id']),
      accountCode: serializer.fromJson<String>(json['account_code']),
      accountNameAr: serializer.fromJson<String>(json['account_name_ar']),
      accountNameEn: serializer.fromJson<String>(json['account_name_en']),
      accountTypeCode: serializer.fromJson<String>(json['account_type_code']),
      accountGroupCode:
          serializer.fromJson<String?>(json['account_group_code']),
      classificationCode:
          serializer.fromJson<String?>(json['classification_code']),
      reportTypeCode: serializer.fromJson<String?>(json['report_type_code']),
      parentAccountId: serializer.fromJson<int?>(json['parent_account_id']),
      isParent: serializer.fromJson<bool>(json['is_parent']),
      isActive: serializer.fromJson<bool>(json['is_active']),
      nature: serializer.fromJson<String>(json['nature']),
      reportType: serializer.fromJson<String>(json['report_type']),
      cashFlowType: serializer.fromJson<String?>(json['cash_flow_type']),
      detailAccountType:
          serializer.fromJson<String?>(json['detail_account_type']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'account_code': serializer.toJson<String>(accountCode),
      'account_name_ar': serializer.toJson<String>(accountNameAr),
      'account_name_en': serializer.toJson<String>(accountNameEn),
      'account_type_code': serializer.toJson<String>(accountTypeCode),
      'account_group_code': serializer.toJson<String?>(accountGroupCode),
      'classification_code': serializer.toJson<String?>(classificationCode),
      'report_type_code': serializer.toJson<String?>(reportTypeCode),
      'parent_account_id': serializer.toJson<int?>(parentAccountId),
      'is_parent': serializer.toJson<bool>(isParent),
      'is_active': serializer.toJson<bool>(isActive),
      'nature': serializer.toJson<String>(nature),
      'report_type': serializer.toJson<String>(reportType),
      'cash_flow_type': serializer.toJson<String?>(cashFlowType),
      'detail_account_type': serializer.toJson<String?>(detailAccountType),
    };
  }

  Account copyWith(
          {int? id,
          String? accountCode,
          String? accountNameAr,
          String? accountNameEn,
          String? accountTypeCode,
          Value<String?> accountGroupCode = const Value.absent(),
          Value<String?> classificationCode = const Value.absent(),
          Value<String?> reportTypeCode = const Value.absent(),
          Value<int?> parentAccountId = const Value.absent(),
          bool? isParent,
          bool? isActive,
          String? nature,
          String? reportType,
          Value<String?> cashFlowType = const Value.absent(),
          Value<String?> detailAccountType = const Value.absent()}) =>
      Account(
        id: id ?? this.id,
        accountCode: accountCode ?? this.accountCode,
        accountNameAr: accountNameAr ?? this.accountNameAr,
        accountNameEn: accountNameEn ?? this.accountNameEn,
        accountTypeCode: accountTypeCode ?? this.accountTypeCode,
        accountGroupCode: accountGroupCode.present
            ? accountGroupCode.value
            : this.accountGroupCode,
        classificationCode: classificationCode.present
            ? classificationCode.value
            : this.classificationCode,
        reportTypeCode:
            reportTypeCode.present ? reportTypeCode.value : this.reportTypeCode,
        parentAccountId: parentAccountId.present
            ? parentAccountId.value
            : this.parentAccountId,
        isParent: isParent ?? this.isParent,
        isActive: isActive ?? this.isActive,
        nature: nature ?? this.nature,
        reportType: reportType ?? this.reportType,
        cashFlowType:
            cashFlowType.present ? cashFlowType.value : this.cashFlowType,
        detailAccountType: detailAccountType.present
            ? detailAccountType.value
            : this.detailAccountType,
      );
  Account copyWithCompanion(AccountsCompanion data) {
    return Account(
      id: data.id.present ? data.id.value : this.id,
      accountCode:
          data.accountCode.present ? data.accountCode.value : this.accountCode,
      accountNameAr: data.accountNameAr.present
          ? data.accountNameAr.value
          : this.accountNameAr,
      accountNameEn: data.accountNameEn.present
          ? data.accountNameEn.value
          : this.accountNameEn,
      accountTypeCode: data.accountTypeCode.present
          ? data.accountTypeCode.value
          : this.accountTypeCode,
      accountGroupCode: data.accountGroupCode.present
          ? data.accountGroupCode.value
          : this.accountGroupCode,
      classificationCode: data.classificationCode.present
          ? data.classificationCode.value
          : this.classificationCode,
      reportTypeCode: data.reportTypeCode.present
          ? data.reportTypeCode.value
          : this.reportTypeCode,
      parentAccountId: data.parentAccountId.present
          ? data.parentAccountId.value
          : this.parentAccountId,
      isParent: data.isParent.present ? data.isParent.value : this.isParent,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      nature: data.nature.present ? data.nature.value : this.nature,
      reportType:
          data.reportType.present ? data.reportType.value : this.reportType,
      cashFlowType: data.cashFlowType.present
          ? data.cashFlowType.value
          : this.cashFlowType,
      detailAccountType: data.detailAccountType.present
          ? data.detailAccountType.value
          : this.detailAccountType,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Account(')
          ..write('id: $id, ')
          ..write('accountCode: $accountCode, ')
          ..write('accountNameAr: $accountNameAr, ')
          ..write('accountNameEn: $accountNameEn, ')
          ..write('accountTypeCode: $accountTypeCode, ')
          ..write('accountGroupCode: $accountGroupCode, ')
          ..write('classificationCode: $classificationCode, ')
          ..write('reportTypeCode: $reportTypeCode, ')
          ..write('parentAccountId: $parentAccountId, ')
          ..write('isParent: $isParent, ')
          ..write('isActive: $isActive, ')
          ..write('nature: $nature, ')
          ..write('reportType: $reportType, ')
          ..write('cashFlowType: $cashFlowType, ')
          ..write('detailAccountType: $detailAccountType')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      accountCode,
      accountNameAr,
      accountNameEn,
      accountTypeCode,
      accountGroupCode,
      classificationCode,
      reportTypeCode,
      parentAccountId,
      isParent,
      isActive,
      nature,
      reportType,
      cashFlowType,
      detailAccountType);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Account &&
          other.id == this.id &&
          other.accountCode == this.accountCode &&
          other.accountNameAr == this.accountNameAr &&
          other.accountNameEn == this.accountNameEn &&
          other.accountTypeCode == this.accountTypeCode &&
          other.accountGroupCode == this.accountGroupCode &&
          other.classificationCode == this.classificationCode &&
          other.reportTypeCode == this.reportTypeCode &&
          other.parentAccountId == this.parentAccountId &&
          other.isParent == this.isParent &&
          other.isActive == this.isActive &&
          other.nature == this.nature &&
          other.reportType == this.reportType &&
          other.cashFlowType == this.cashFlowType &&
          other.detailAccountType == this.detailAccountType);
}

class AccountsCompanion extends UpdateCompanion<Account> {
  final Value<int> id;
  final Value<String> accountCode;
  final Value<String> accountNameAr;
  final Value<String> accountNameEn;
  final Value<String> accountTypeCode;
  final Value<String?> accountGroupCode;
  final Value<String?> classificationCode;
  final Value<String?> reportTypeCode;
  final Value<int?> parentAccountId;
  final Value<bool> isParent;
  final Value<bool> isActive;
  final Value<String> nature;
  final Value<String> reportType;
  final Value<String?> cashFlowType;
  final Value<String?> detailAccountType;
  const AccountsCompanion({
    this.id = const Value.absent(),
    this.accountCode = const Value.absent(),
    this.accountNameAr = const Value.absent(),
    this.accountNameEn = const Value.absent(),
    this.accountTypeCode = const Value.absent(),
    this.accountGroupCode = const Value.absent(),
    this.classificationCode = const Value.absent(),
    this.reportTypeCode = const Value.absent(),
    this.parentAccountId = const Value.absent(),
    this.isParent = const Value.absent(),
    this.isActive = const Value.absent(),
    this.nature = const Value.absent(),
    this.reportType = const Value.absent(),
    this.cashFlowType = const Value.absent(),
    this.detailAccountType = const Value.absent(),
  });
  AccountsCompanion.insert({
    this.id = const Value.absent(),
    required String accountCode,
    required String accountNameAr,
    required String accountNameEn,
    required String accountTypeCode,
    this.accountGroupCode = const Value.absent(),
    this.classificationCode = const Value.absent(),
    this.reportTypeCode = const Value.absent(),
    this.parentAccountId = const Value.absent(),
    this.isParent = const Value.absent(),
    this.isActive = const Value.absent(),
    required String nature,
    required String reportType,
    this.cashFlowType = const Value.absent(),
    this.detailAccountType = const Value.absent(),
  })  : accountCode = Value(accountCode),
        accountNameAr = Value(accountNameAr),
        accountNameEn = Value(accountNameEn),
        accountTypeCode = Value(accountTypeCode),
        nature = Value(nature),
        reportType = Value(reportType);
  static Insertable<Account> custom({
    Expression<int>? id,
    Expression<String>? accountCode,
    Expression<String>? accountNameAr,
    Expression<String>? accountNameEn,
    Expression<String>? accountTypeCode,
    Expression<String>? accountGroupCode,
    Expression<String>? classificationCode,
    Expression<String>? reportTypeCode,
    Expression<int>? parentAccountId,
    Expression<bool>? isParent,
    Expression<bool>? isActive,
    Expression<String>? nature,
    Expression<String>? reportType,
    Expression<String>? cashFlowType,
    Expression<String>? detailAccountType,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (accountCode != null) 'account_code': accountCode,
      if (accountNameAr != null) 'account_name_ar': accountNameAr,
      if (accountNameEn != null) 'account_name_en': accountNameEn,
      if (accountTypeCode != null) 'account_type_code': accountTypeCode,
      if (accountGroupCode != null) 'account_group_code': accountGroupCode,
      if (classificationCode != null) 'classification_code': classificationCode,
      if (reportTypeCode != null) 'report_type_code': reportTypeCode,
      if (parentAccountId != null) 'parent_account_id': parentAccountId,
      if (isParent != null) 'is_parent': isParent,
      if (isActive != null) 'is_active': isActive,
      if (nature != null) 'nature': nature,
      if (reportType != null) 'report_type': reportType,
      if (cashFlowType != null) 'cash_flow_type': cashFlowType,
      if (detailAccountType != null) 'detail_account_type': detailAccountType,
    });
  }

  AccountsCompanion copyWith(
      {Value<int>? id,
      Value<String>? accountCode,
      Value<String>? accountNameAr,
      Value<String>? accountNameEn,
      Value<String>? accountTypeCode,
      Value<String?>? accountGroupCode,
      Value<String?>? classificationCode,
      Value<String?>? reportTypeCode,
      Value<int?>? parentAccountId,
      Value<bool>? isParent,
      Value<bool>? isActive,
      Value<String>? nature,
      Value<String>? reportType,
      Value<String?>? cashFlowType,
      Value<String?>? detailAccountType}) {
    return AccountsCompanion(
      id: id ?? this.id,
      accountCode: accountCode ?? this.accountCode,
      accountNameAr: accountNameAr ?? this.accountNameAr,
      accountNameEn: accountNameEn ?? this.accountNameEn,
      accountTypeCode: accountTypeCode ?? this.accountTypeCode,
      accountGroupCode: accountGroupCode ?? this.accountGroupCode,
      classificationCode: classificationCode ?? this.classificationCode,
      reportTypeCode: reportTypeCode ?? this.reportTypeCode,
      parentAccountId: parentAccountId ?? this.parentAccountId,
      isParent: isParent ?? this.isParent,
      isActive: isActive ?? this.isActive,
      nature: nature ?? this.nature,
      reportType: reportType ?? this.reportType,
      cashFlowType: cashFlowType ?? this.cashFlowType,
      detailAccountType: detailAccountType ?? this.detailAccountType,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (accountCode.present) {
      map['account_code'] = Variable<String>(accountCode.value);
    }
    if (accountNameAr.present) {
      map['account_name_ar'] = Variable<String>(accountNameAr.value);
    }
    if (accountNameEn.present) {
      map['account_name_en'] = Variable<String>(accountNameEn.value);
    }
    if (accountTypeCode.present) {
      map['account_type_code'] = Variable<String>(accountTypeCode.value);
    }
    if (accountGroupCode.present) {
      map['account_group_code'] = Variable<String>(accountGroupCode.value);
    }
    if (classificationCode.present) {
      map['classification_code'] = Variable<String>(classificationCode.value);
    }
    if (reportTypeCode.present) {
      map['report_type_code'] = Variable<String>(reportTypeCode.value);
    }
    if (parentAccountId.present) {
      map['parent_account_id'] = Variable<int>(parentAccountId.value);
    }
    if (isParent.present) {
      map['is_parent'] = Variable<bool>(isParent.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (nature.present) {
      map['nature'] = Variable<String>(nature.value);
    }
    if (reportType.present) {
      map['report_type'] = Variable<String>(reportType.value);
    }
    if (cashFlowType.present) {
      map['cash_flow_type'] = Variable<String>(cashFlowType.value);
    }
    if (detailAccountType.present) {
      map['detail_account_type'] = Variable<String>(detailAccountType.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccountsCompanion(')
          ..write('id: $id, ')
          ..write('accountCode: $accountCode, ')
          ..write('accountNameAr: $accountNameAr, ')
          ..write('accountNameEn: $accountNameEn, ')
          ..write('accountTypeCode: $accountTypeCode, ')
          ..write('accountGroupCode: $accountGroupCode, ')
          ..write('classificationCode: $classificationCode, ')
          ..write('reportTypeCode: $reportTypeCode, ')
          ..write('parentAccountId: $parentAccountId, ')
          ..write('isParent: $isParent, ')
          ..write('isActive: $isActive, ')
          ..write('nature: $nature, ')
          ..write('reportType: $reportType, ')
          ..write('cashFlowType: $cashFlowType, ')
          ..write('detailAccountType: $detailAccountType')
          ..write(')'))
        .toString();
  }
}

class DocumentTypes extends Table with TableInfo<DocumentTypes, DocumentType> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  DocumentTypes(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _docTypeCodeMeta =
      const VerificationMeta('docTypeCode');
  late final GeneratedColumn<String> docTypeCode = GeneratedColumn<String>(
      'doc_type_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _sequenceMethodMeta =
      const VerificationMeta('sequenceMethod');
  late final GeneratedColumn<String> sequenceMethod = GeneratedColumn<String>(
      'sequence_method', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL CHECK (sequence_method IN (\'General\', \'Specific\'))');
  static const VerificationMeta _sequenceBehaviorMeta =
      const VerificationMeta('sequenceBehavior');
  late final GeneratedColumn<String> sequenceBehavior = GeneratedColumn<String>(
      'sequence_behavior', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints:
          'NOT NULL CHECK (sequence_behavior IN (\'Auto-Unchangeable\', \'Auto-Changeable\', \'Manual\'))');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<int> isActive = GeneratedColumn<int>(
      'is_active', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT 1',
      defaultValue: const CustomExpression('1'));
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT (strftime(\'%s\', \'now\'))',
      defaultValue: const CustomExpression('strftime(\'%s\', \'now\')'));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT (strftime(\'%s\', \'now\'))',
      defaultValue: const CustomExpression('strftime(\'%s\', \'now\')'));
  @override
  List<GeneratedColumn> get $columns => [
        docTypeCode,
        nameAr,
        nameEn,
        sequenceMethod,
        sequenceBehavior,
        isActive,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'document_types';
  @override
  VerificationContext validateIntegrity(Insertable<DocumentType> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('doc_type_code')) {
      context.handle(
          _docTypeCodeMeta,
          docTypeCode.isAcceptableOrUnknown(
              data['doc_type_code']!, _docTypeCodeMeta));
    } else if (isInserting) {
      context.missing(_docTypeCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('sequence_method')) {
      context.handle(
          _sequenceMethodMeta,
          sequenceMethod.isAcceptableOrUnknown(
              data['sequence_method']!, _sequenceMethodMeta));
    } else if (isInserting) {
      context.missing(_sequenceMethodMeta);
    }
    if (data.containsKey('sequence_behavior')) {
      context.handle(
          _sequenceBehaviorMeta,
          sequenceBehavior.isAcceptableOrUnknown(
              data['sequence_behavior']!, _sequenceBehaviorMeta));
    } else if (isInserting) {
      context.missing(_sequenceBehaviorMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {docTypeCode};
  @override
  DocumentType map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DocumentType(
      docTypeCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}doc_type_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      sequenceMethod: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sequence_method'])!,
      sequenceBehavior: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}sequence_behavior'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}is_active'])!,
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  DocumentTypes createAlias(String alias) {
    return DocumentTypes(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class DocumentType extends DataClass implements Insertable<DocumentType> {
  final String docTypeCode;
  final String nameAr;
  final String nameEn;
  final String sequenceMethod;
  final String sequenceBehavior;
  final int isActive;
  final int createdAt;
  final int updatedAt;
  const DocumentType(
      {required this.docTypeCode,
      required this.nameAr,
      required this.nameEn,
      required this.sequenceMethod,
      required this.sequenceBehavior,
      required this.isActive,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['doc_type_code'] = Variable<String>(docTypeCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['sequence_method'] = Variable<String>(sequenceMethod);
    map['sequence_behavior'] = Variable<String>(sequenceBehavior);
    map['is_active'] = Variable<int>(isActive);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  DocumentTypesCompanion toCompanion(bool nullToAbsent) {
    return DocumentTypesCompanion(
      docTypeCode: Value(docTypeCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      sequenceMethod: Value(sequenceMethod),
      sequenceBehavior: Value(sequenceBehavior),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory DocumentType.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DocumentType(
      docTypeCode: serializer.fromJson<String>(json['doc_type_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      sequenceMethod: serializer.fromJson<String>(json['sequence_method']),
      sequenceBehavior: serializer.fromJson<String>(json['sequence_behavior']),
      isActive: serializer.fromJson<int>(json['is_active']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'doc_type_code': serializer.toJson<String>(docTypeCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'sequence_method': serializer.toJson<String>(sequenceMethod),
      'sequence_behavior': serializer.toJson<String>(sequenceBehavior),
      'is_active': serializer.toJson<int>(isActive),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  DocumentType copyWith(
          {String? docTypeCode,
          String? nameAr,
          String? nameEn,
          String? sequenceMethod,
          String? sequenceBehavior,
          int? isActive,
          int? createdAt,
          int? updatedAt}) =>
      DocumentType(
        docTypeCode: docTypeCode ?? this.docTypeCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        sequenceMethod: sequenceMethod ?? this.sequenceMethod,
        sequenceBehavior: sequenceBehavior ?? this.sequenceBehavior,
        isActive: isActive ?? this.isActive,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  DocumentType copyWithCompanion(DocumentTypesCompanion data) {
    return DocumentType(
      docTypeCode:
          data.docTypeCode.present ? data.docTypeCode.value : this.docTypeCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      sequenceMethod: data.sequenceMethod.present
          ? data.sequenceMethod.value
          : this.sequenceMethod,
      sequenceBehavior: data.sequenceBehavior.present
          ? data.sequenceBehavior.value
          : this.sequenceBehavior,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DocumentType(')
          ..write('docTypeCode: $docTypeCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('sequenceMethod: $sequenceMethod, ')
          ..write('sequenceBehavior: $sequenceBehavior, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(docTypeCode, nameAr, nameEn, sequenceMethod,
      sequenceBehavior, isActive, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DocumentType &&
          other.docTypeCode == this.docTypeCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.sequenceMethod == this.sequenceMethod &&
          other.sequenceBehavior == this.sequenceBehavior &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class DocumentTypesCompanion extends UpdateCompanion<DocumentType> {
  final Value<String> docTypeCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String> sequenceMethod;
  final Value<String> sequenceBehavior;
  final Value<int> isActive;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const DocumentTypesCompanion({
    this.docTypeCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.sequenceMethod = const Value.absent(),
    this.sequenceBehavior = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DocumentTypesCompanion.insert({
    required String docTypeCode,
    required String nameAr,
    required String nameEn,
    required String sequenceMethod,
    required String sequenceBehavior,
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : docTypeCode = Value(docTypeCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        sequenceMethod = Value(sequenceMethod),
        sequenceBehavior = Value(sequenceBehavior);
  static Insertable<DocumentType> custom({
    Expression<String>? docTypeCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? sequenceMethod,
    Expression<String>? sequenceBehavior,
    Expression<int>? isActive,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (docTypeCode != null) 'doc_type_code': docTypeCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (sequenceMethod != null) 'sequence_method': sequenceMethod,
      if (sequenceBehavior != null) 'sequence_behavior': sequenceBehavior,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DocumentTypesCompanion copyWith(
      {Value<String>? docTypeCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String>? sequenceMethod,
      Value<String>? sequenceBehavior,
      Value<int>? isActive,
      Value<int>? createdAt,
      Value<int>? updatedAt,
      Value<int>? rowid}) {
    return DocumentTypesCompanion(
      docTypeCode: docTypeCode ?? this.docTypeCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      sequenceMethod: sequenceMethod ?? this.sequenceMethod,
      sequenceBehavior: sequenceBehavior ?? this.sequenceBehavior,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (docTypeCode.present) {
      map['doc_type_code'] = Variable<String>(docTypeCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (sequenceMethod.present) {
      map['sequence_method'] = Variable<String>(sequenceMethod.value);
    }
    if (sequenceBehavior.present) {
      map['sequence_behavior'] = Variable<String>(sequenceBehavior.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<int>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DocumentTypesCompanion(')
          ..write('docTypeCode: $docTypeCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('sequenceMethod: $sequenceMethod, ')
          ..write('sequenceBehavior: $sequenceBehavior, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class DescriptionCoding extends Table
    with TableInfo<DescriptionCoding, DescriptionCodingData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  DescriptionCoding(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _descCodeMeta =
      const VerificationMeta('descCode');
  late final GeneratedColumn<String> descCode = GeneratedColumn<String>(
      'desc_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _descriptionArMeta =
      const VerificationMeta('descriptionAr');
  late final GeneratedColumn<String> descriptionAr = GeneratedColumn<String>(
      'description_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _descriptionEnMeta =
      const VerificationMeta('descriptionEn');
  late final GeneratedColumn<String> descriptionEn = GeneratedColumn<String>(
      'description_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _linkedAccountIdMeta =
      const VerificationMeta('linkedAccountId');
  late final GeneratedColumn<String> linkedAccountId = GeneratedColumn<String>(
      'linked_account_id', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: 'REFERENCES accounts(account_code)');
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
      'created_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT (strftime(\'%s\', \'now\'))',
      defaultValue: const CustomExpression('strftime(\'%s\', \'now\')'));
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT (strftime(\'%s\', \'now\'))',
      defaultValue: const CustomExpression('strftime(\'%s\', \'now\')'));
  @override
  List<GeneratedColumn> get $columns => [
        descCode,
        descriptionAr,
        descriptionEn,
        linkedAccountId,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'description_coding';
  @override
  VerificationContext validateIntegrity(
      Insertable<DescriptionCodingData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('desc_code')) {
      context.handle(_descCodeMeta,
          descCode.isAcceptableOrUnknown(data['desc_code']!, _descCodeMeta));
    } else if (isInserting) {
      context.missing(_descCodeMeta);
    }
    if (data.containsKey('description_ar')) {
      context.handle(
          _descriptionArMeta,
          descriptionAr.isAcceptableOrUnknown(
              data['description_ar']!, _descriptionArMeta));
    } else if (isInserting) {
      context.missing(_descriptionArMeta);
    }
    if (data.containsKey('description_en')) {
      context.handle(
          _descriptionEnMeta,
          descriptionEn.isAcceptableOrUnknown(
              data['description_en']!, _descriptionEnMeta));
    } else if (isInserting) {
      context.missing(_descriptionEnMeta);
    }
    if (data.containsKey('linked_account_id')) {
      context.handle(
          _linkedAccountIdMeta,
          linkedAccountId.isAcceptableOrUnknown(
              data['linked_account_id']!, _linkedAccountIdMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {descCode};
  @override
  DescriptionCodingData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DescriptionCodingData(
      descCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}desc_code'])!,
      descriptionAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description_ar'])!,
      descriptionEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description_en'])!,
      linkedAccountId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}linked_account_id']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  DescriptionCoding createAlias(String alias) {
    return DescriptionCoding(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class DescriptionCodingData extends DataClass
    implements Insertable<DescriptionCodingData> {
  final String descCode;
  final String descriptionAr;
  final String descriptionEn;
  final String? linkedAccountId;
  final int createdAt;
  final int updatedAt;
  const DescriptionCodingData(
      {required this.descCode,
      required this.descriptionAr,
      required this.descriptionEn,
      this.linkedAccountId,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['desc_code'] = Variable<String>(descCode);
    map['description_ar'] = Variable<String>(descriptionAr);
    map['description_en'] = Variable<String>(descriptionEn);
    if (!nullToAbsent || linkedAccountId != null) {
      map['linked_account_id'] = Variable<String>(linkedAccountId);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  DescriptionCodingCompanion toCompanion(bool nullToAbsent) {
    return DescriptionCodingCompanion(
      descCode: Value(descCode),
      descriptionAr: Value(descriptionAr),
      descriptionEn: Value(descriptionEn),
      linkedAccountId: linkedAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(linkedAccountId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory DescriptionCodingData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DescriptionCodingData(
      descCode: serializer.fromJson<String>(json['desc_code']),
      descriptionAr: serializer.fromJson<String>(json['description_ar']),
      descriptionEn: serializer.fromJson<String>(json['description_en']),
      linkedAccountId: serializer.fromJson<String?>(json['linked_account_id']),
      createdAt: serializer.fromJson<int>(json['created_at']),
      updatedAt: serializer.fromJson<int>(json['updated_at']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'desc_code': serializer.toJson<String>(descCode),
      'description_ar': serializer.toJson<String>(descriptionAr),
      'description_en': serializer.toJson<String>(descriptionEn),
      'linked_account_id': serializer.toJson<String?>(linkedAccountId),
      'created_at': serializer.toJson<int>(createdAt),
      'updated_at': serializer.toJson<int>(updatedAt),
    };
  }

  DescriptionCodingData copyWith(
          {String? descCode,
          String? descriptionAr,
          String? descriptionEn,
          Value<String?> linkedAccountId = const Value.absent(),
          int? createdAt,
          int? updatedAt}) =>
      DescriptionCodingData(
        descCode: descCode ?? this.descCode,
        descriptionAr: descriptionAr ?? this.descriptionAr,
        descriptionEn: descriptionEn ?? this.descriptionEn,
        linkedAccountId: linkedAccountId.present
            ? linkedAccountId.value
            : this.linkedAccountId,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  DescriptionCodingData copyWithCompanion(DescriptionCodingCompanion data) {
    return DescriptionCodingData(
      descCode: data.descCode.present ? data.descCode.value : this.descCode,
      descriptionAr: data.descriptionAr.present
          ? data.descriptionAr.value
          : this.descriptionAr,
      descriptionEn: data.descriptionEn.present
          ? data.descriptionEn.value
          : this.descriptionEn,
      linkedAccountId: data.linkedAccountId.present
          ? data.linkedAccountId.value
          : this.linkedAccountId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DescriptionCodingData(')
          ..write('descCode: $descCode, ')
          ..write('descriptionAr: $descriptionAr, ')
          ..write('descriptionEn: $descriptionEn, ')
          ..write('linkedAccountId: $linkedAccountId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(descCode, descriptionAr, descriptionEn,
      linkedAccountId, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DescriptionCodingData &&
          other.descCode == this.descCode &&
          other.descriptionAr == this.descriptionAr &&
          other.descriptionEn == this.descriptionEn &&
          other.linkedAccountId == this.linkedAccountId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class DescriptionCodingCompanion
    extends UpdateCompanion<DescriptionCodingData> {
  final Value<String> descCode;
  final Value<String> descriptionAr;
  final Value<String> descriptionEn;
  final Value<String?> linkedAccountId;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const DescriptionCodingCompanion({
    this.descCode = const Value.absent(),
    this.descriptionAr = const Value.absent(),
    this.descriptionEn = const Value.absent(),
    this.linkedAccountId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  DescriptionCodingCompanion.insert({
    required String descCode,
    required String descriptionAr,
    required String descriptionEn,
    this.linkedAccountId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  })  : descCode = Value(descCode),
        descriptionAr = Value(descriptionAr),
        descriptionEn = Value(descriptionEn);
  static Insertable<DescriptionCodingData> custom({
    Expression<String>? descCode,
    Expression<String>? descriptionAr,
    Expression<String>? descriptionEn,
    Expression<String>? linkedAccountId,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (descCode != null) 'desc_code': descCode,
      if (descriptionAr != null) 'description_ar': descriptionAr,
      if (descriptionEn != null) 'description_en': descriptionEn,
      if (linkedAccountId != null) 'linked_account_id': linkedAccountId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  DescriptionCodingCompanion copyWith(
      {Value<String>? descCode,
      Value<String>? descriptionAr,
      Value<String>? descriptionEn,
      Value<String?>? linkedAccountId,
      Value<int>? createdAt,
      Value<int>? updatedAt,
      Value<int>? rowid}) {
    return DescriptionCodingCompanion(
      descCode: descCode ?? this.descCode,
      descriptionAr: descriptionAr ?? this.descriptionAr,
      descriptionEn: descriptionEn ?? this.descriptionEn,
      linkedAccountId: linkedAccountId ?? this.linkedAccountId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (descCode.present) {
      map['desc_code'] = Variable<String>(descCode.value);
    }
    if (descriptionAr.present) {
      map['description_ar'] = Variable<String>(descriptionAr.value);
    }
    if (descriptionEn.present) {
      map['description_en'] = Variable<String>(descriptionEn.value);
    }
    if (linkedAccountId.present) {
      map['linked_account_id'] = Variable<String>(linkedAccountId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DescriptionCodingCompanion(')
          ..write('descCode: $descCode, ')
          ..write('descriptionAr: $descriptionAr, ')
          ..write('descriptionEn: $descriptionEn, ')
          ..write('linkedAccountId: $linkedAccountId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class Zones extends Table with TableInfo<Zones, Zone> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Zones(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _zoneCodeMeta =
      const VerificationMeta('zoneCode');
  late final GeneratedColumn<String> zoneCode = GeneratedColumn<String>(
      'zone_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  @override
  List<GeneratedColumn> get $columns =>
      [id, zoneCode, nameAr, nameEn, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'zones';
  @override
  VerificationContext validateIntegrity(Insertable<Zone> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('zone_code')) {
      context.handle(_zoneCodeMeta,
          zoneCode.isAcceptableOrUnknown(data['zone_code']!, _zoneCodeMeta));
    } else if (isInserting) {
      context.missing(_zoneCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Zone map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Zone(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      zoneCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}zone_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Zones createAlias(String alias) {
    return Zones(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Zone extends DataClass implements Insertable<Zone> {
  final int id;
  final String zoneCode;
  final String nameAr;
  final String nameEn;
  final bool isActive;
  const Zone(
      {required this.id,
      required this.zoneCode,
      required this.nameAr,
      required this.nameEn,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['zone_code'] = Variable<String>(zoneCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  ZonesCompanion toCompanion(bool nullToAbsent) {
    return ZonesCompanion(
      id: Value(id),
      zoneCode: Value(zoneCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      isActive: Value(isActive),
    );
  }

  factory Zone.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Zone(
      id: serializer.fromJson<int>(json['id']),
      zoneCode: serializer.fromJson<String>(json['zone_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'zone_code': serializer.toJson<String>(zoneCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  Zone copyWith(
          {int? id,
          String? zoneCode,
          String? nameAr,
          String? nameEn,
          bool? isActive}) =>
      Zone(
        id: id ?? this.id,
        zoneCode: zoneCode ?? this.zoneCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        isActive: isActive ?? this.isActive,
      );
  Zone copyWithCompanion(ZonesCompanion data) {
    return Zone(
      id: data.id.present ? data.id.value : this.id,
      zoneCode: data.zoneCode.present ? data.zoneCode.value : this.zoneCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Zone(')
          ..write('id: $id, ')
          ..write('zoneCode: $zoneCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, zoneCode, nameAr, nameEn, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Zone &&
          other.id == this.id &&
          other.zoneCode == this.zoneCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.isActive == this.isActive);
}

class ZonesCompanion extends UpdateCompanion<Zone> {
  final Value<int> id;
  final Value<String> zoneCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<bool> isActive;
  const ZonesCompanion({
    this.id = const Value.absent(),
    this.zoneCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  ZonesCompanion.insert({
    this.id = const Value.absent(),
    required String zoneCode,
    required String nameAr,
    required String nameEn,
    this.isActive = const Value.absent(),
  })  : zoneCode = Value(zoneCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn);
  static Insertable<Zone> custom({
    Expression<int>? id,
    Expression<String>? zoneCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (zoneCode != null) 'zone_code': zoneCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (isActive != null) 'is_active': isActive,
    });
  }

  ZonesCompanion copyWith(
      {Value<int>? id,
      Value<String>? zoneCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<bool>? isActive}) {
    return ZonesCompanion(
      id: id ?? this.id,
      zoneCode: zoneCode ?? this.zoneCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (zoneCode.present) {
      map['zone_code'] = Variable<String>(zoneCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ZonesCompanion(')
          ..write('id: $id, ')
          ..write('zoneCode: $zoneCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class Countries extends Table with TableInfo<Countries, Country> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Countries(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _countryCodeMeta =
      const VerificationMeta('countryCode');
  late final GeneratedColumn<String> countryCode = GeneratedColumn<String>(
      'country_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nationalityArMeta =
      const VerificationMeta('nationalityAr');
  late final GeneratedColumn<String> nationalityAr = GeneratedColumn<String>(
      'nationality_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nationalityEnMeta =
      const VerificationMeta('nationalityEn');
  late final GeneratedColumn<String> nationalityEn = GeneratedColumn<String>(
      'nationality_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _zoneIdMeta = const VerificationMeta('zoneId');
  late final GeneratedColumn<int> zoneId = GeneratedColumn<int>(
      'zone_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES zones(id)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  @override
  List<GeneratedColumn> get $columns => [
        id,
        countryCode,
        nameAr,
        nameEn,
        nationalityAr,
        nationalityEn,
        zoneId,
        isActive
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'countries';
  @override
  VerificationContext validateIntegrity(Insertable<Country> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('country_code')) {
      context.handle(
          _countryCodeMeta,
          countryCode.isAcceptableOrUnknown(
              data['country_code']!, _countryCodeMeta));
    } else if (isInserting) {
      context.missing(_countryCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('nationality_ar')) {
      context.handle(
          _nationalityArMeta,
          nationalityAr.isAcceptableOrUnknown(
              data['nationality_ar']!, _nationalityArMeta));
    } else if (isInserting) {
      context.missing(_nationalityArMeta);
    }
    if (data.containsKey('nationality_en')) {
      context.handle(
          _nationalityEnMeta,
          nationalityEn.isAcceptableOrUnknown(
              data['nationality_en']!, _nationalityEnMeta));
    } else if (isInserting) {
      context.missing(_nationalityEnMeta);
    }
    if (data.containsKey('zone_id')) {
      context.handle(_zoneIdMeta,
          zoneId.isAcceptableOrUnknown(data['zone_id']!, _zoneIdMeta));
    } else if (isInserting) {
      context.missing(_zoneIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Country map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Country(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      countryCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}country_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      nationalityAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nationality_ar'])!,
      nationalityEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}nationality_en'])!,
      zoneId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}zone_id'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Countries createAlias(String alias) {
    return Countries(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Country extends DataClass implements Insertable<Country> {
  final int id;
  final String countryCode;
  final String nameAr;
  final String nameEn;
  final String nationalityAr;
  final String nationalityEn;
  final int zoneId;
  final bool isActive;
  const Country(
      {required this.id,
      required this.countryCode,
      required this.nameAr,
      required this.nameEn,
      required this.nationalityAr,
      required this.nationalityEn,
      required this.zoneId,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['country_code'] = Variable<String>(countryCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['nationality_ar'] = Variable<String>(nationalityAr);
    map['nationality_en'] = Variable<String>(nationalityEn);
    map['zone_id'] = Variable<int>(zoneId);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  CountriesCompanion toCompanion(bool nullToAbsent) {
    return CountriesCompanion(
      id: Value(id),
      countryCode: Value(countryCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      nationalityAr: Value(nationalityAr),
      nationalityEn: Value(nationalityEn),
      zoneId: Value(zoneId),
      isActive: Value(isActive),
    );
  }

  factory Country.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Country(
      id: serializer.fromJson<int>(json['id']),
      countryCode: serializer.fromJson<String>(json['country_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      nationalityAr: serializer.fromJson<String>(json['nationality_ar']),
      nationalityEn: serializer.fromJson<String>(json['nationality_en']),
      zoneId: serializer.fromJson<int>(json['zone_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'country_code': serializer.toJson<String>(countryCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'nationality_ar': serializer.toJson<String>(nationalityAr),
      'nationality_en': serializer.toJson<String>(nationalityEn),
      'zone_id': serializer.toJson<int>(zoneId),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  Country copyWith(
          {int? id,
          String? countryCode,
          String? nameAr,
          String? nameEn,
          String? nationalityAr,
          String? nationalityEn,
          int? zoneId,
          bool? isActive}) =>
      Country(
        id: id ?? this.id,
        countryCode: countryCode ?? this.countryCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        nationalityAr: nationalityAr ?? this.nationalityAr,
        nationalityEn: nationalityEn ?? this.nationalityEn,
        zoneId: zoneId ?? this.zoneId,
        isActive: isActive ?? this.isActive,
      );
  Country copyWithCompanion(CountriesCompanion data) {
    return Country(
      id: data.id.present ? data.id.value : this.id,
      countryCode:
          data.countryCode.present ? data.countryCode.value : this.countryCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      nationalityAr: data.nationalityAr.present
          ? data.nationalityAr.value
          : this.nationalityAr,
      nationalityEn: data.nationalityEn.present
          ? data.nationalityEn.value
          : this.nationalityEn,
      zoneId: data.zoneId.present ? data.zoneId.value : this.zoneId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Country(')
          ..write('id: $id, ')
          ..write('countryCode: $countryCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('nationalityAr: $nationalityAr, ')
          ..write('nationalityEn: $nationalityEn, ')
          ..write('zoneId: $zoneId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, countryCode, nameAr, nameEn,
      nationalityAr, nationalityEn, zoneId, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Country &&
          other.id == this.id &&
          other.countryCode == this.countryCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.nationalityAr == this.nationalityAr &&
          other.nationalityEn == this.nationalityEn &&
          other.zoneId == this.zoneId &&
          other.isActive == this.isActive);
}

class CountriesCompanion extends UpdateCompanion<Country> {
  final Value<int> id;
  final Value<String> countryCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String> nationalityAr;
  final Value<String> nationalityEn;
  final Value<int> zoneId;
  final Value<bool> isActive;
  const CountriesCompanion({
    this.id = const Value.absent(),
    this.countryCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.nationalityAr = const Value.absent(),
    this.nationalityEn = const Value.absent(),
    this.zoneId = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  CountriesCompanion.insert({
    this.id = const Value.absent(),
    required String countryCode,
    required String nameAr,
    required String nameEn,
    required String nationalityAr,
    required String nationalityEn,
    required int zoneId,
    this.isActive = const Value.absent(),
  })  : countryCode = Value(countryCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        nationalityAr = Value(nationalityAr),
        nationalityEn = Value(nationalityEn),
        zoneId = Value(zoneId);
  static Insertable<Country> custom({
    Expression<int>? id,
    Expression<String>? countryCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? nationalityAr,
    Expression<String>? nationalityEn,
    Expression<int>? zoneId,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (countryCode != null) 'country_code': countryCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (nationalityAr != null) 'nationality_ar': nationalityAr,
      if (nationalityEn != null) 'nationality_en': nationalityEn,
      if (zoneId != null) 'zone_id': zoneId,
      if (isActive != null) 'is_active': isActive,
    });
  }

  CountriesCompanion copyWith(
      {Value<int>? id,
      Value<String>? countryCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String>? nationalityAr,
      Value<String>? nationalityEn,
      Value<int>? zoneId,
      Value<bool>? isActive}) {
    return CountriesCompanion(
      id: id ?? this.id,
      countryCode: countryCode ?? this.countryCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      nationalityAr: nationalityAr ?? this.nationalityAr,
      nationalityEn: nationalityEn ?? this.nationalityEn,
      zoneId: zoneId ?? this.zoneId,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (countryCode.present) {
      map['country_code'] = Variable<String>(countryCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (nationalityAr.present) {
      map['nationality_ar'] = Variable<String>(nationalityAr.value);
    }
    if (nationalityEn.present) {
      map['nationality_en'] = Variable<String>(nationalityEn.value);
    }
    if (zoneId.present) {
      map['zone_id'] = Variable<int>(zoneId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CountriesCompanion(')
          ..write('id: $id, ')
          ..write('countryCode: $countryCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('nationalityAr: $nationalityAr, ')
          ..write('nationalityEn: $nationalityEn, ')
          ..write('zoneId: $zoneId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class Governorates extends Table with TableInfo<Governorates, Governorate> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Governorates(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _govCodeMeta =
      const VerificationMeta('govCode');
  late final GeneratedColumn<String> govCode = GeneratedColumn<String>(
      'gov_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _countryIdMeta =
      const VerificationMeta('countryId');
  late final GeneratedColumn<int> countryId = GeneratedColumn<int>(
      'country_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES countries(id)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  @override
  List<GeneratedColumn> get $columns =>
      [id, govCode, nameAr, nameEn, countryId, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'governorates';
  @override
  VerificationContext validateIntegrity(Insertable<Governorate> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('gov_code')) {
      context.handle(_govCodeMeta,
          govCode.isAcceptableOrUnknown(data['gov_code']!, _govCodeMeta));
    } else if (isInserting) {
      context.missing(_govCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('country_id')) {
      context.handle(_countryIdMeta,
          countryId.isAcceptableOrUnknown(data['country_id']!, _countryIdMeta));
    } else if (isInserting) {
      context.missing(_countryIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Governorate map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Governorate(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      govCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}gov_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      countryId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}country_id'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Governorates createAlias(String alias) {
    return Governorates(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Governorate extends DataClass implements Insertable<Governorate> {
  final int id;
  final String govCode;
  final String nameAr;
  final String nameEn;
  final int countryId;
  final bool isActive;
  const Governorate(
      {required this.id,
      required this.govCode,
      required this.nameAr,
      required this.nameEn,
      required this.countryId,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['gov_code'] = Variable<String>(govCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['country_id'] = Variable<int>(countryId);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  GovernoratesCompanion toCompanion(bool nullToAbsent) {
    return GovernoratesCompanion(
      id: Value(id),
      govCode: Value(govCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      countryId: Value(countryId),
      isActive: Value(isActive),
    );
  }

  factory Governorate.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Governorate(
      id: serializer.fromJson<int>(json['id']),
      govCode: serializer.fromJson<String>(json['gov_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      countryId: serializer.fromJson<int>(json['country_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'gov_code': serializer.toJson<String>(govCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'country_id': serializer.toJson<int>(countryId),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  Governorate copyWith(
          {int? id,
          String? govCode,
          String? nameAr,
          String? nameEn,
          int? countryId,
          bool? isActive}) =>
      Governorate(
        id: id ?? this.id,
        govCode: govCode ?? this.govCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        countryId: countryId ?? this.countryId,
        isActive: isActive ?? this.isActive,
      );
  Governorate copyWithCompanion(GovernoratesCompanion data) {
    return Governorate(
      id: data.id.present ? data.id.value : this.id,
      govCode: data.govCode.present ? data.govCode.value : this.govCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      countryId: data.countryId.present ? data.countryId.value : this.countryId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Governorate(')
          ..write('id: $id, ')
          ..write('govCode: $govCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('countryId: $countryId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, govCode, nameAr, nameEn, countryId, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Governorate &&
          other.id == this.id &&
          other.govCode == this.govCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.countryId == this.countryId &&
          other.isActive == this.isActive);
}

class GovernoratesCompanion extends UpdateCompanion<Governorate> {
  final Value<int> id;
  final Value<String> govCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<int> countryId;
  final Value<bool> isActive;
  const GovernoratesCompanion({
    this.id = const Value.absent(),
    this.govCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.countryId = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  GovernoratesCompanion.insert({
    this.id = const Value.absent(),
    required String govCode,
    required String nameAr,
    required String nameEn,
    required int countryId,
    this.isActive = const Value.absent(),
  })  : govCode = Value(govCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        countryId = Value(countryId);
  static Insertable<Governorate> custom({
    Expression<int>? id,
    Expression<String>? govCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<int>? countryId,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (govCode != null) 'gov_code': govCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (countryId != null) 'country_id': countryId,
      if (isActive != null) 'is_active': isActive,
    });
  }

  GovernoratesCompanion copyWith(
      {Value<int>? id,
      Value<String>? govCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<int>? countryId,
      Value<bool>? isActive}) {
    return GovernoratesCompanion(
      id: id ?? this.id,
      govCode: govCode ?? this.govCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      countryId: countryId ?? this.countryId,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (govCode.present) {
      map['gov_code'] = Variable<String>(govCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (countryId.present) {
      map['country_id'] = Variable<int>(countryId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GovernoratesCompanion(')
          ..write('id: $id, ')
          ..write('govCode: $govCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('countryId: $countryId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class Cities extends Table with TableInfo<Cities, City> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Cities(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _cityCodeMeta =
      const VerificationMeta('cityCode');
  late final GeneratedColumn<String> cityCode = GeneratedColumn<String>(
      'city_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _govIdMeta = const VerificationMeta('govId');
  late final GeneratedColumn<int> govId = GeneratedColumn<int>(
      'gov_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES governorates(id)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  @override
  List<GeneratedColumn> get $columns =>
      [id, cityCode, nameAr, nameEn, govId, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cities';
  @override
  VerificationContext validateIntegrity(Insertable<City> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('city_code')) {
      context.handle(_cityCodeMeta,
          cityCode.isAcceptableOrUnknown(data['city_code']!, _cityCodeMeta));
    } else if (isInserting) {
      context.missing(_cityCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('gov_id')) {
      context.handle(
          _govIdMeta, govId.isAcceptableOrUnknown(data['gov_id']!, _govIdMeta));
    } else if (isInserting) {
      context.missing(_govIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  City map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return City(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      cityCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}city_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      govId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}gov_id'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Cities createAlias(String alias) {
    return Cities(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class City extends DataClass implements Insertable<City> {
  final int id;
  final String cityCode;
  final String nameAr;
  final String nameEn;
  final int govId;
  final bool isActive;
  const City(
      {required this.id,
      required this.cityCode,
      required this.nameAr,
      required this.nameEn,
      required this.govId,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['city_code'] = Variable<String>(cityCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['gov_id'] = Variable<int>(govId);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  CitiesCompanion toCompanion(bool nullToAbsent) {
    return CitiesCompanion(
      id: Value(id),
      cityCode: Value(cityCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      govId: Value(govId),
      isActive: Value(isActive),
    );
  }

  factory City.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return City(
      id: serializer.fromJson<int>(json['id']),
      cityCode: serializer.fromJson<String>(json['city_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      govId: serializer.fromJson<int>(json['gov_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'city_code': serializer.toJson<String>(cityCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'gov_id': serializer.toJson<int>(govId),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  City copyWith(
          {int? id,
          String? cityCode,
          String? nameAr,
          String? nameEn,
          int? govId,
          bool? isActive}) =>
      City(
        id: id ?? this.id,
        cityCode: cityCode ?? this.cityCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        govId: govId ?? this.govId,
        isActive: isActive ?? this.isActive,
      );
  City copyWithCompanion(CitiesCompanion data) {
    return City(
      id: data.id.present ? data.id.value : this.id,
      cityCode: data.cityCode.present ? data.cityCode.value : this.cityCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      govId: data.govId.present ? data.govId.value : this.govId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('City(')
          ..write('id: $id, ')
          ..write('cityCode: $cityCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('govId: $govId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, cityCode, nameAr, nameEn, govId, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is City &&
          other.id == this.id &&
          other.cityCode == this.cityCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.govId == this.govId &&
          other.isActive == this.isActive);
}

class CitiesCompanion extends UpdateCompanion<City> {
  final Value<int> id;
  final Value<String> cityCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<int> govId;
  final Value<bool> isActive;
  const CitiesCompanion({
    this.id = const Value.absent(),
    this.cityCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.govId = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  CitiesCompanion.insert({
    this.id = const Value.absent(),
    required String cityCode,
    required String nameAr,
    required String nameEn,
    required int govId,
    this.isActive = const Value.absent(),
  })  : cityCode = Value(cityCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        govId = Value(govId);
  static Insertable<City> custom({
    Expression<int>? id,
    Expression<String>? cityCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<int>? govId,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (cityCode != null) 'city_code': cityCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (govId != null) 'gov_id': govId,
      if (isActive != null) 'is_active': isActive,
    });
  }

  CitiesCompanion copyWith(
      {Value<int>? id,
      Value<String>? cityCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<int>? govId,
      Value<bool>? isActive}) {
    return CitiesCompanion(
      id: id ?? this.id,
      cityCode: cityCode ?? this.cityCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      govId: govId ?? this.govId,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (cityCode.present) {
      map['city_code'] = Variable<String>(cityCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (govId.present) {
      map['gov_id'] = Variable<int>(govId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CitiesCompanion(')
          ..write('id: $id, ')
          ..write('cityCode: $cityCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('govId: $govId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class Regions extends Table with TableInfo<Regions, Region> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Regions(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _regionCodeMeta =
      const VerificationMeta('regionCode');
  late final GeneratedColumn<String> regionCode = GeneratedColumn<String>(
      'region_code', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _cityIdMeta = const VerificationMeta('cityId');
  late final GeneratedColumn<int> cityId = GeneratedColumn<int>(
      'city_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES cities(id)');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  @override
  List<GeneratedColumn> get $columns =>
      [id, regionCode, nameAr, nameEn, cityId, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'regions';
  @override
  VerificationContext validateIntegrity(Insertable<Region> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('region_code')) {
      context.handle(
          _regionCodeMeta,
          regionCode.isAcceptableOrUnknown(
              data['region_code']!, _regionCodeMeta));
    } else if (isInserting) {
      context.missing(_regionCodeMeta);
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('city_id')) {
      context.handle(_cityIdMeta,
          cityId.isAcceptableOrUnknown(data['city_id']!, _cityIdMeta));
    } else if (isInserting) {
      context.missing(_cityIdMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Region map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Region(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      regionCode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}region_code'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      cityId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}city_id'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Regions createAlias(String alias) {
    return Regions(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Region extends DataClass implements Insertable<Region> {
  final int id;
  final String regionCode;
  final String nameAr;
  final String nameEn;
  final int cityId;
  final bool isActive;
  const Region(
      {required this.id,
      required this.regionCode,
      required this.nameAr,
      required this.nameEn,
      required this.cityId,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['region_code'] = Variable<String>(regionCode);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    map['city_id'] = Variable<int>(cityId);
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  RegionsCompanion toCompanion(bool nullToAbsent) {
    return RegionsCompanion(
      id: Value(id),
      regionCode: Value(regionCode),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      cityId: Value(cityId),
      isActive: Value(isActive),
    );
  }

  factory Region.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Region(
      id: serializer.fromJson<int>(json['id']),
      regionCode: serializer.fromJson<String>(json['region_code']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      cityId: serializer.fromJson<int>(json['city_id']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'region_code': serializer.toJson<String>(regionCode),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'city_id': serializer.toJson<int>(cityId),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  Region copyWith(
          {int? id,
          String? regionCode,
          String? nameAr,
          String? nameEn,
          int? cityId,
          bool? isActive}) =>
      Region(
        id: id ?? this.id,
        regionCode: regionCode ?? this.regionCode,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        cityId: cityId ?? this.cityId,
        isActive: isActive ?? this.isActive,
      );
  Region copyWithCompanion(RegionsCompanion data) {
    return Region(
      id: data.id.present ? data.id.value : this.id,
      regionCode:
          data.regionCode.present ? data.regionCode.value : this.regionCode,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      cityId: data.cityId.present ? data.cityId.value : this.cityId,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Region(')
          ..write('id: $id, ')
          ..write('regionCode: $regionCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('cityId: $cityId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, regionCode, nameAr, nameEn, cityId, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Region &&
          other.id == this.id &&
          other.regionCode == this.regionCode &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.cityId == this.cityId &&
          other.isActive == this.isActive);
}

class RegionsCompanion extends UpdateCompanion<Region> {
  final Value<int> id;
  final Value<String> regionCode;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<int> cityId;
  final Value<bool> isActive;
  const RegionsCompanion({
    this.id = const Value.absent(),
    this.regionCode = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.cityId = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  RegionsCompanion.insert({
    this.id = const Value.absent(),
    required String regionCode,
    required String nameAr,
    required String nameEn,
    required int cityId,
    this.isActive = const Value.absent(),
  })  : regionCode = Value(regionCode),
        nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        cityId = Value(cityId);
  static Insertable<Region> custom({
    Expression<int>? id,
    Expression<String>? regionCode,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<int>? cityId,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (regionCode != null) 'region_code': regionCode,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (cityId != null) 'city_id': cityId,
      if (isActive != null) 'is_active': isActive,
    });
  }

  RegionsCompanion copyWith(
      {Value<int>? id,
      Value<String>? regionCode,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<int>? cityId,
      Value<bool>? isActive}) {
    return RegionsCompanion(
      id: id ?? this.id,
      regionCode: regionCode ?? this.regionCode,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      cityId: cityId ?? this.cityId,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (regionCode.present) {
      map['region_code'] = Variable<String>(regionCode.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (cityId.present) {
      map['city_id'] = Variable<int>(cityId.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RegionsCompanion(')
          ..write('id: $id, ')
          ..write('regionCode: $regionCode, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('cityId: $cityId, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class Roles extends Table with TableInfo<Roles, Role> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Roles(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _nameArMeta = const VerificationMeta('nameAr');
  late final GeneratedColumn<String> nameAr = GeneratedColumn<String>(
      'name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _nameEnMeta = const VerificationMeta('nameEn');
  late final GeneratedColumn<String> nameEn = GeneratedColumn<String>(
      'name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns =>
      [id, nameAr, nameEn, description, isActive];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'roles';
  @override
  VerificationContext validateIntegrity(Insertable<Role> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name_ar')) {
      context.handle(_nameArMeta,
          nameAr.isAcceptableOrUnknown(data['name_ar']!, _nameArMeta));
    } else if (isInserting) {
      context.missing(_nameArMeta);
    }
    if (data.containsKey('name_en')) {
      context.handle(_nameEnMeta,
          nameEn.isAcceptableOrUnknown(data['name_en']!, _nameEnMeta));
    } else if (isInserting) {
      context.missing(_nameEnMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    } else if (isInserting) {
      context.missing(_isActiveMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Role map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Role(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      nameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_ar'])!,
      nameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name_en'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
    );
  }

  @override
  Roles createAlias(String alias) {
    return Roles(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class Role extends DataClass implements Insertable<Role> {
  final int id;
  final String nameAr;
  final String nameEn;
  final String? description;
  final bool isActive;
  const Role(
      {required this.id,
      required this.nameAr,
      required this.nameEn,
      this.description,
      required this.isActive});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name_ar'] = Variable<String>(nameAr);
    map['name_en'] = Variable<String>(nameEn);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['is_active'] = Variable<bool>(isActive);
    return map;
  }

  RolesCompanion toCompanion(bool nullToAbsent) {
    return RolesCompanion(
      id: Value(id),
      nameAr: Value(nameAr),
      nameEn: Value(nameEn),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      isActive: Value(isActive),
    );
  }

  factory Role.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Role(
      id: serializer.fromJson<int>(json['id']),
      nameAr: serializer.fromJson<String>(json['name_ar']),
      nameEn: serializer.fromJson<String>(json['name_en']),
      description: serializer.fromJson<String?>(json['description']),
      isActive: serializer.fromJson<bool>(json['is_active']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name_ar': serializer.toJson<String>(nameAr),
      'name_en': serializer.toJson<String>(nameEn),
      'description': serializer.toJson<String?>(description),
      'is_active': serializer.toJson<bool>(isActive),
    };
  }

  Role copyWith(
          {int? id,
          String? nameAr,
          String? nameEn,
          Value<String?> description = const Value.absent(),
          bool? isActive}) =>
      Role(
        id: id ?? this.id,
        nameAr: nameAr ?? this.nameAr,
        nameEn: nameEn ?? this.nameEn,
        description: description.present ? description.value : this.description,
        isActive: isActive ?? this.isActive,
      );
  Role copyWithCompanion(RolesCompanion data) {
    return Role(
      id: data.id.present ? data.id.value : this.id,
      nameAr: data.nameAr.present ? data.nameAr.value : this.nameAr,
      nameEn: data.nameEn.present ? data.nameEn.value : this.nameEn,
      description:
          data.description.present ? data.description.value : this.description,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Role(')
          ..write('id: $id, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('description: $description, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, nameAr, nameEn, description, isActive);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Role &&
          other.id == this.id &&
          other.nameAr == this.nameAr &&
          other.nameEn == this.nameEn &&
          other.description == this.description &&
          other.isActive == this.isActive);
}

class RolesCompanion extends UpdateCompanion<Role> {
  final Value<int> id;
  final Value<String> nameAr;
  final Value<String> nameEn;
  final Value<String?> description;
  final Value<bool> isActive;
  const RolesCompanion({
    this.id = const Value.absent(),
    this.nameAr = const Value.absent(),
    this.nameEn = const Value.absent(),
    this.description = const Value.absent(),
    this.isActive = const Value.absent(),
  });
  RolesCompanion.insert({
    this.id = const Value.absent(),
    required String nameAr,
    required String nameEn,
    this.description = const Value.absent(),
    required bool isActive,
  })  : nameAr = Value(nameAr),
        nameEn = Value(nameEn),
        isActive = Value(isActive);
  static Insertable<Role> custom({
    Expression<int>? id,
    Expression<String>? nameAr,
    Expression<String>? nameEn,
    Expression<String>? description,
    Expression<bool>? isActive,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (nameAr != null) 'name_ar': nameAr,
      if (nameEn != null) 'name_en': nameEn,
      if (description != null) 'description': description,
      if (isActive != null) 'is_active': isActive,
    });
  }

  RolesCompanion copyWith(
      {Value<int>? id,
      Value<String>? nameAr,
      Value<String>? nameEn,
      Value<String?>? description,
      Value<bool>? isActive}) {
    return RolesCompanion(
      id: id ?? this.id,
      nameAr: nameAr ?? this.nameAr,
      nameEn: nameEn ?? this.nameEn,
      description: description ?? this.description,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (nameAr.present) {
      map['name_ar'] = Variable<String>(nameAr.value);
    }
    if (nameEn.present) {
      map['name_en'] = Variable<String>(nameEn.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RolesCompanion(')
          ..write('id: $id, ')
          ..write('nameAr: $nameAr, ')
          ..write('nameEn: $nameEn, ')
          ..write('description: $description, ')
          ..write('isActive: $isActive')
          ..write(')'))
        .toString();
  }
}

class RolePermissions extends Table
    with TableInfo<RolePermissions, RolePermission> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  RolePermissions(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _roleIdMeta = const VerificationMeta('roleId');
  late final GeneratedColumn<int> roleId = GeneratedColumn<int>(
      'role_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES roles(id)');
  static const VerificationMeta _permissionMeta =
      const VerificationMeta('permission');
  late final GeneratedColumn<String> permission = GeneratedColumn<String>(
      'permission', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [roleId, permission];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'role_permissions';
  @override
  VerificationContext validateIntegrity(Insertable<RolePermission> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('role_id')) {
      context.handle(_roleIdMeta,
          roleId.isAcceptableOrUnknown(data['role_id']!, _roleIdMeta));
    } else if (isInserting) {
      context.missing(_roleIdMeta);
    }
    if (data.containsKey('permission')) {
      context.handle(
          _permissionMeta,
          permission.isAcceptableOrUnknown(
              data['permission']!, _permissionMeta));
    } else if (isInserting) {
      context.missing(_permissionMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {roleId, permission};
  @override
  RolePermission map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RolePermission(
      roleId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}role_id'])!,
      permission: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}permission'])!,
    );
  }

  @override
  RolePermissions createAlias(String alias) {
    return RolePermissions(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints =>
      const ['PRIMARY KEY(role_id, permission)'];
  @override
  bool get dontWriteConstraints => true;
}

class RolePermission extends DataClass implements Insertable<RolePermission> {
  final int roleId;
  final String permission;
  const RolePermission({required this.roleId, required this.permission});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['role_id'] = Variable<int>(roleId);
    map['permission'] = Variable<String>(permission);
    return map;
  }

  RolePermissionsCompanion toCompanion(bool nullToAbsent) {
    return RolePermissionsCompanion(
      roleId: Value(roleId),
      permission: Value(permission),
    );
  }

  factory RolePermission.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RolePermission(
      roleId: serializer.fromJson<int>(json['role_id']),
      permission: serializer.fromJson<String>(json['permission']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'role_id': serializer.toJson<int>(roleId),
      'permission': serializer.toJson<String>(permission),
    };
  }

  RolePermission copyWith({int? roleId, String? permission}) => RolePermission(
        roleId: roleId ?? this.roleId,
        permission: permission ?? this.permission,
      );
  RolePermission copyWithCompanion(RolePermissionsCompanion data) {
    return RolePermission(
      roleId: data.roleId.present ? data.roleId.value : this.roleId,
      permission:
          data.permission.present ? data.permission.value : this.permission,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RolePermission(')
          ..write('roleId: $roleId, ')
          ..write('permission: $permission')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(roleId, permission);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RolePermission &&
          other.roleId == this.roleId &&
          other.permission == this.permission);
}

class RolePermissionsCompanion extends UpdateCompanion<RolePermission> {
  final Value<int> roleId;
  final Value<String> permission;
  final Value<int> rowid;
  const RolePermissionsCompanion({
    this.roleId = const Value.absent(),
    this.permission = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RolePermissionsCompanion.insert({
    required int roleId,
    required String permission,
    this.rowid = const Value.absent(),
  })  : roleId = Value(roleId),
        permission = Value(permission);
  static Insertable<RolePermission> custom({
    Expression<int>? roleId,
    Expression<String>? permission,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (roleId != null) 'role_id': roleId,
      if (permission != null) 'permission': permission,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RolePermissionsCompanion copyWith(
      {Value<int>? roleId, Value<String>? permission, Value<int>? rowid}) {
    return RolePermissionsCompanion(
      roleId: roleId ?? this.roleId,
      permission: permission ?? this.permission,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (roleId.present) {
      map['role_id'] = Variable<int>(roleId.value);
    }
    if (permission.present) {
      map['permission'] = Variable<String>(permission.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RolePermissionsCompanion(')
          ..write('roleId: $roleId, ')
          ..write('permission: $permission, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class Users extends Table with TableInfo<Users, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Users(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _usernameMeta =
      const VerificationMeta('username');
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
      'username', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL UNIQUE');
  static const VerificationMeta _passwordMeta =
      const VerificationMeta('password');
  late final GeneratedColumn<String> password = GeneratedColumn<String>(
      'password', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _fullNameArMeta =
      const VerificationMeta('fullNameAr');
  late final GeneratedColumn<String> fullNameAr = GeneratedColumn<String>(
      'full_name_ar', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _fullNameEnMeta =
      const VerificationMeta('fullNameEn');
  late final GeneratedColumn<String> fullNameEn = GeneratedColumn<String>(
      'full_name_en', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _isActiveMeta =
      const VerificationMeta('isActive');
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
      'is_active', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT TRUE',
      defaultValue: const CustomExpression('TRUE'));
  static const VerificationMeta _branchIdMeta =
      const VerificationMeta('branchId');
  late final GeneratedColumn<int> branchId = GeneratedColumn<int>(
      'branch_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'REFERENCES branches(id)');
  static const VerificationMeta _isBiometricEnabledMeta =
      const VerificationMeta('isBiometricEnabled');
  late final GeneratedColumn<bool> isBiometricEnabled = GeneratedColumn<bool>(
      'is_biometric_enabled', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _isDeviceLinkedMeta =
      const VerificationMeta('isDeviceLinked');
  late final GeneratedColumn<bool> isDeviceLinked = GeneratedColumn<bool>(
      'is_device_linked', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT FALSE',
      defaultValue: const CustomExpression('FALSE'));
  static const VerificationMeta _lastLoginMeta =
      const VerificationMeta('lastLogin');
  late final GeneratedColumn<int> lastLogin = GeneratedColumn<int>(
      'last_login', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: '');
  static const VerificationMeta _failedLoginAttemptsMeta =
      const VerificationMeta('failedLoginAttempts');
  late final GeneratedColumn<int> failedLoginAttempts = GeneratedColumn<int>(
      'failed_login_attempts', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL DEFAULT 0',
      defaultValue: const CustomExpression('0'));
  @override
  List<GeneratedColumn> get $columns => [
        userId,
        username,
        password,
        fullNameAr,
        fullNameEn,
        isActive,
        branchId,
        isBiometricEnabled,
        isDeviceLinked,
        lastLogin,
        failedLoginAttempts
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(Insertable<User> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    }
    if (data.containsKey('username')) {
      context.handle(_usernameMeta,
          username.isAcceptableOrUnknown(data['username']!, _usernameMeta));
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('password')) {
      context.handle(_passwordMeta,
          password.isAcceptableOrUnknown(data['password']!, _passwordMeta));
    } else if (isInserting) {
      context.missing(_passwordMeta);
    }
    if (data.containsKey('full_name_ar')) {
      context.handle(
          _fullNameArMeta,
          fullNameAr.isAcceptableOrUnknown(
              data['full_name_ar']!, _fullNameArMeta));
    } else if (isInserting) {
      context.missing(_fullNameArMeta);
    }
    if (data.containsKey('full_name_en')) {
      context.handle(
          _fullNameEnMeta,
          fullNameEn.isAcceptableOrUnknown(
              data['full_name_en']!, _fullNameEnMeta));
    } else if (isInserting) {
      context.missing(_fullNameEnMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(_isActiveMeta,
          isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta));
    }
    if (data.containsKey('branch_id')) {
      context.handle(_branchIdMeta,
          branchId.isAcceptableOrUnknown(data['branch_id']!, _branchIdMeta));
    }
    if (data.containsKey('is_biometric_enabled')) {
      context.handle(
          _isBiometricEnabledMeta,
          isBiometricEnabled.isAcceptableOrUnknown(
              data['is_biometric_enabled']!, _isBiometricEnabledMeta));
    }
    if (data.containsKey('is_device_linked')) {
      context.handle(
          _isDeviceLinkedMeta,
          isDeviceLinked.isAcceptableOrUnknown(
              data['is_device_linked']!, _isDeviceLinkedMeta));
    }
    if (data.containsKey('last_login')) {
      context.handle(_lastLoginMeta,
          lastLogin.isAcceptableOrUnknown(data['last_login']!, _lastLoginMeta));
    }
    if (data.containsKey('failed_login_attempts')) {
      context.handle(
          _failedLoginAttemptsMeta,
          failedLoginAttempts.isAcceptableOrUnknown(
              data['failed_login_attempts']!, _failedLoginAttemptsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {userId};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      username: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}username'])!,
      password: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}password'])!,
      fullNameAr: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}full_name_ar'])!,
      fullNameEn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}full_name_en'])!,
      isActive: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_active'])!,
      branchId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}branch_id']),
      isBiometricEnabled: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_biometric_enabled'])!,
      isDeviceLinked: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_device_linked'])!,
      lastLogin: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}last_login']),
      failedLoginAttempts: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}failed_login_attempts'])!,
    );
  }

  @override
  Users createAlias(String alias) {
    return Users(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class User extends DataClass implements Insertable<User> {
  final int userId;
  final String username;
  final String password;
  final String fullNameAr;
  final String fullNameEn;
  final bool isActive;
  final int? branchId;
  final bool isBiometricEnabled;
  final bool isDeviceLinked;
  final int? lastLogin;
  final int failedLoginAttempts;
  const User(
      {required this.userId,
      required this.username,
      required this.password,
      required this.fullNameAr,
      required this.fullNameEn,
      required this.isActive,
      this.branchId,
      required this.isBiometricEnabled,
      required this.isDeviceLinked,
      this.lastLogin,
      required this.failedLoginAttempts});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['user_id'] = Variable<int>(userId);
    map['username'] = Variable<String>(username);
    map['password'] = Variable<String>(password);
    map['full_name_ar'] = Variable<String>(fullNameAr);
    map['full_name_en'] = Variable<String>(fullNameEn);
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || branchId != null) {
      map['branch_id'] = Variable<int>(branchId);
    }
    map['is_biometric_enabled'] = Variable<bool>(isBiometricEnabled);
    map['is_device_linked'] = Variable<bool>(isDeviceLinked);
    if (!nullToAbsent || lastLogin != null) {
      map['last_login'] = Variable<int>(lastLogin);
    }
    map['failed_login_attempts'] = Variable<int>(failedLoginAttempts);
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      userId: Value(userId),
      username: Value(username),
      password: Value(password),
      fullNameAr: Value(fullNameAr),
      fullNameEn: Value(fullNameEn),
      isActive: Value(isActive),
      branchId: branchId == null && nullToAbsent
          ? const Value.absent()
          : Value(branchId),
      isBiometricEnabled: Value(isBiometricEnabled),
      isDeviceLinked: Value(isDeviceLinked),
      lastLogin: lastLogin == null && nullToAbsent
          ? const Value.absent()
          : Value(lastLogin),
      failedLoginAttempts: Value(failedLoginAttempts),
    );
  }

  factory User.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      userId: serializer.fromJson<int>(json['user_id']),
      username: serializer.fromJson<String>(json['username']),
      password: serializer.fromJson<String>(json['password']),
      fullNameAr: serializer.fromJson<String>(json['full_name_ar']),
      fullNameEn: serializer.fromJson<String>(json['full_name_en']),
      isActive: serializer.fromJson<bool>(json['is_active']),
      branchId: serializer.fromJson<int?>(json['branch_id']),
      isBiometricEnabled:
          serializer.fromJson<bool>(json['is_biometric_enabled']),
      isDeviceLinked: serializer.fromJson<bool>(json['is_device_linked']),
      lastLogin: serializer.fromJson<int?>(json['last_login']),
      failedLoginAttempts:
          serializer.fromJson<int>(json['failed_login_attempts']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'user_id': serializer.toJson<int>(userId),
      'username': serializer.toJson<String>(username),
      'password': serializer.toJson<String>(password),
      'full_name_ar': serializer.toJson<String>(fullNameAr),
      'full_name_en': serializer.toJson<String>(fullNameEn),
      'is_active': serializer.toJson<bool>(isActive),
      'branch_id': serializer.toJson<int?>(branchId),
      'is_biometric_enabled': serializer.toJson<bool>(isBiometricEnabled),
      'is_device_linked': serializer.toJson<bool>(isDeviceLinked),
      'last_login': serializer.toJson<int?>(lastLogin),
      'failed_login_attempts': serializer.toJson<int>(failedLoginAttempts),
    };
  }

  User copyWith(
          {int? userId,
          String? username,
          String? password,
          String? fullNameAr,
          String? fullNameEn,
          bool? isActive,
          Value<int?> branchId = const Value.absent(),
          bool? isBiometricEnabled,
          bool? isDeviceLinked,
          Value<int?> lastLogin = const Value.absent(),
          int? failedLoginAttempts}) =>
      User(
        userId: userId ?? this.userId,
        username: username ?? this.username,
        password: password ?? this.password,
        fullNameAr: fullNameAr ?? this.fullNameAr,
        fullNameEn: fullNameEn ?? this.fullNameEn,
        isActive: isActive ?? this.isActive,
        branchId: branchId.present ? branchId.value : this.branchId,
        isBiometricEnabled: isBiometricEnabled ?? this.isBiometricEnabled,
        isDeviceLinked: isDeviceLinked ?? this.isDeviceLinked,
        lastLogin: lastLogin.present ? lastLogin.value : this.lastLogin,
        failedLoginAttempts: failedLoginAttempts ?? this.failedLoginAttempts,
      );
  User copyWithCompanion(UsersCompanion data) {
    return User(
      userId: data.userId.present ? data.userId.value : this.userId,
      username: data.username.present ? data.username.value : this.username,
      password: data.password.present ? data.password.value : this.password,
      fullNameAr:
          data.fullNameAr.present ? data.fullNameAr.value : this.fullNameAr,
      fullNameEn:
          data.fullNameEn.present ? data.fullNameEn.value : this.fullNameEn,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      branchId: data.branchId.present ? data.branchId.value : this.branchId,
      isBiometricEnabled: data.isBiometricEnabled.present
          ? data.isBiometricEnabled.value
          : this.isBiometricEnabled,
      isDeviceLinked: data.isDeviceLinked.present
          ? data.isDeviceLinked.value
          : this.isDeviceLinked,
      lastLogin: data.lastLogin.present ? data.lastLogin.value : this.lastLogin,
      failedLoginAttempts: data.failedLoginAttempts.present
          ? data.failedLoginAttempts.value
          : this.failedLoginAttempts,
    );
  }

  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('userId: $userId, ')
          ..write('username: $username, ')
          ..write('password: $password, ')
          ..write('fullNameAr: $fullNameAr, ')
          ..write('fullNameEn: $fullNameEn, ')
          ..write('isActive: $isActive, ')
          ..write('branchId: $branchId, ')
          ..write('isBiometricEnabled: $isBiometricEnabled, ')
          ..write('isDeviceLinked: $isDeviceLinked, ')
          ..write('lastLogin: $lastLogin, ')
          ..write('failedLoginAttempts: $failedLoginAttempts')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      userId,
      username,
      password,
      fullNameAr,
      fullNameEn,
      isActive,
      branchId,
      isBiometricEnabled,
      isDeviceLinked,
      lastLogin,
      failedLoginAttempts);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.userId == this.userId &&
          other.username == this.username &&
          other.password == this.password &&
          other.fullNameAr == this.fullNameAr &&
          other.fullNameEn == this.fullNameEn &&
          other.isActive == this.isActive &&
          other.branchId == this.branchId &&
          other.isBiometricEnabled == this.isBiometricEnabled &&
          other.isDeviceLinked == this.isDeviceLinked &&
          other.lastLogin == this.lastLogin &&
          other.failedLoginAttempts == this.failedLoginAttempts);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<int> userId;
  final Value<String> username;
  final Value<String> password;
  final Value<String> fullNameAr;
  final Value<String> fullNameEn;
  final Value<bool> isActive;
  final Value<int?> branchId;
  final Value<bool> isBiometricEnabled;
  final Value<bool> isDeviceLinked;
  final Value<int?> lastLogin;
  final Value<int> failedLoginAttempts;
  const UsersCompanion({
    this.userId = const Value.absent(),
    this.username = const Value.absent(),
    this.password = const Value.absent(),
    this.fullNameAr = const Value.absent(),
    this.fullNameEn = const Value.absent(),
    this.isActive = const Value.absent(),
    this.branchId = const Value.absent(),
    this.isBiometricEnabled = const Value.absent(),
    this.isDeviceLinked = const Value.absent(),
    this.lastLogin = const Value.absent(),
    this.failedLoginAttempts = const Value.absent(),
  });
  UsersCompanion.insert({
    this.userId = const Value.absent(),
    required String username,
    required String password,
    required String fullNameAr,
    required String fullNameEn,
    this.isActive = const Value.absent(),
    this.branchId = const Value.absent(),
    this.isBiometricEnabled = const Value.absent(),
    this.isDeviceLinked = const Value.absent(),
    this.lastLogin = const Value.absent(),
    this.failedLoginAttempts = const Value.absent(),
  })  : username = Value(username),
        password = Value(password),
        fullNameAr = Value(fullNameAr),
        fullNameEn = Value(fullNameEn);
  static Insertable<User> custom({
    Expression<int>? userId,
    Expression<String>? username,
    Expression<String>? password,
    Expression<String>? fullNameAr,
    Expression<String>? fullNameEn,
    Expression<bool>? isActive,
    Expression<int>? branchId,
    Expression<bool>? isBiometricEnabled,
    Expression<bool>? isDeviceLinked,
    Expression<int>? lastLogin,
    Expression<int>? failedLoginAttempts,
  }) {
    return RawValuesInsertable({
      if (userId != null) 'user_id': userId,
      if (username != null) 'username': username,
      if (password != null) 'password': password,
      if (fullNameAr != null) 'full_name_ar': fullNameAr,
      if (fullNameEn != null) 'full_name_en': fullNameEn,
      if (isActive != null) 'is_active': isActive,
      if (branchId != null) 'branch_id': branchId,
      if (isBiometricEnabled != null)
        'is_biometric_enabled': isBiometricEnabled,
      if (isDeviceLinked != null) 'is_device_linked': isDeviceLinked,
      if (lastLogin != null) 'last_login': lastLogin,
      if (failedLoginAttempts != null)
        'failed_login_attempts': failedLoginAttempts,
    });
  }

  UsersCompanion copyWith(
      {Value<int>? userId,
      Value<String>? username,
      Value<String>? password,
      Value<String>? fullNameAr,
      Value<String>? fullNameEn,
      Value<bool>? isActive,
      Value<int?>? branchId,
      Value<bool>? isBiometricEnabled,
      Value<bool>? isDeviceLinked,
      Value<int?>? lastLogin,
      Value<int>? failedLoginAttempts}) {
    return UsersCompanion(
      userId: userId ?? this.userId,
      username: username ?? this.username,
      password: password ?? this.password,
      fullNameAr: fullNameAr ?? this.fullNameAr,
      fullNameEn: fullNameEn ?? this.fullNameEn,
      isActive: isActive ?? this.isActive,
      branchId: branchId ?? this.branchId,
      isBiometricEnabled: isBiometricEnabled ?? this.isBiometricEnabled,
      isDeviceLinked: isDeviceLinked ?? this.isDeviceLinked,
      lastLogin: lastLogin ?? this.lastLogin,
      failedLoginAttempts: failedLoginAttempts ?? this.failedLoginAttempts,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (password.present) {
      map['password'] = Variable<String>(password.value);
    }
    if (fullNameAr.present) {
      map['full_name_ar'] = Variable<String>(fullNameAr.value);
    }
    if (fullNameEn.present) {
      map['full_name_en'] = Variable<String>(fullNameEn.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (branchId.present) {
      map['branch_id'] = Variable<int>(branchId.value);
    }
    if (isBiometricEnabled.present) {
      map['is_biometric_enabled'] = Variable<bool>(isBiometricEnabled.value);
    }
    if (isDeviceLinked.present) {
      map['is_device_linked'] = Variable<bool>(isDeviceLinked.value);
    }
    if (lastLogin.present) {
      map['last_login'] = Variable<int>(lastLogin.value);
    }
    if (failedLoginAttempts.present) {
      map['failed_login_attempts'] = Variable<int>(failedLoginAttempts.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('userId: $userId, ')
          ..write('username: $username, ')
          ..write('password: $password, ')
          ..write('fullNameAr: $fullNameAr, ')
          ..write('fullNameEn: $fullNameEn, ')
          ..write('isActive: $isActive, ')
          ..write('branchId: $branchId, ')
          ..write('isBiometricEnabled: $isBiometricEnabled, ')
          ..write('isDeviceLinked: $isDeviceLinked, ')
          ..write('lastLogin: $lastLogin, ')
          ..write('failedLoginAttempts: $failedLoginAttempts')
          ..write(')'))
        .toString();
  }
}

class UserRoles extends Table with TableInfo<UserRoles, UserRole> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  UserRoles(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES users(user_id)');
  static const VerificationMeta _roleIdMeta = const VerificationMeta('roleId');
  late final GeneratedColumn<int> roleId = GeneratedColumn<int>(
      'role_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES roles(id)');
  @override
  List<GeneratedColumn> get $columns => [userId, roleId];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_roles';
  @override
  VerificationContext validateIntegrity(Insertable<UserRole> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('role_id')) {
      context.handle(_roleIdMeta,
          roleId.isAcceptableOrUnknown(data['role_id']!, _roleIdMeta));
    } else if (isInserting) {
      context.missing(_roleIdMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {userId, roleId};
  @override
  UserRole map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserRole(
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      roleId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}role_id'])!,
    );
  }

  @override
  UserRoles createAlias(String alias) {
    return UserRoles(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(user_id, role_id)'];
  @override
  bool get dontWriteConstraints => true;
}

class UserRole extends DataClass implements Insertable<UserRole> {
  final int userId;
  final int roleId;
  const UserRole({required this.userId, required this.roleId});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['user_id'] = Variable<int>(userId);
    map['role_id'] = Variable<int>(roleId);
    return map;
  }

  UserRolesCompanion toCompanion(bool nullToAbsent) {
    return UserRolesCompanion(
      userId: Value(userId),
      roleId: Value(roleId),
    );
  }

  factory UserRole.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserRole(
      userId: serializer.fromJson<int>(json['user_id']),
      roleId: serializer.fromJson<int>(json['role_id']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'user_id': serializer.toJson<int>(userId),
      'role_id': serializer.toJson<int>(roleId),
    };
  }

  UserRole copyWith({int? userId, int? roleId}) => UserRole(
        userId: userId ?? this.userId,
        roleId: roleId ?? this.roleId,
      );
  UserRole copyWithCompanion(UserRolesCompanion data) {
    return UserRole(
      userId: data.userId.present ? data.userId.value : this.userId,
      roleId: data.roleId.present ? data.roleId.value : this.roleId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserRole(')
          ..write('userId: $userId, ')
          ..write('roleId: $roleId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(userId, roleId);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserRole &&
          other.userId == this.userId &&
          other.roleId == this.roleId);
}

class UserRolesCompanion extends UpdateCompanion<UserRole> {
  final Value<int> userId;
  final Value<int> roleId;
  final Value<int> rowid;
  const UserRolesCompanion({
    this.userId = const Value.absent(),
    this.roleId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserRolesCompanion.insert({
    required int userId,
    required int roleId,
    this.rowid = const Value.absent(),
  })  : userId = Value(userId),
        roleId = Value(roleId);
  static Insertable<UserRole> custom({
    Expression<int>? userId,
    Expression<int>? roleId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (userId != null) 'user_id': userId,
      if (roleId != null) 'role_id': roleId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserRolesCompanion copyWith(
      {Value<int>? userId, Value<int>? roleId, Value<int>? rowid}) {
    return UserRolesCompanion(
      userId: userId ?? this.userId,
      roleId: roleId ?? this.roleId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (roleId.present) {
      map['role_id'] = Variable<int>(roleId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserRolesCompanion(')
          ..write('userId: $userId, ')
          ..write('roleId: $roleId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class AuditLog extends Table with TableInfo<AuditLog, AuditLogData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AuditLog(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT');
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL REFERENCES users(user_id)');
  static const VerificationMeta _timestampMeta =
      const VerificationMeta('timestamp');
  late final GeneratedColumn<double> timestamp = GeneratedColumn<double>(
      'timestamp', aliasedName, false,
      type: DriftSqlType.double,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _eventActionMeta =
      const VerificationMeta('eventAction');
  late final GeneratedColumn<String> eventAction = GeneratedColumn<String>(
      'event_action', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _detailsMeta =
      const VerificationMeta('details');
  late final GeneratedColumn<String> details = GeneratedColumn<String>(
      'details', aliasedName, true,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      $customConstraints: '');
  @override
  List<GeneratedColumn> get $columns =>
      [id, userId, timestamp, eventAction, details];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_log';
  @override
  VerificationContext validateIntegrity(Insertable<AuditLogData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(_timestampMeta,
          timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta));
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('event_action')) {
      context.handle(
          _eventActionMeta,
          eventAction.isAcceptableOrUnknown(
              data['event_action']!, _eventActionMeta));
    } else if (isInserting) {
      context.missing(_eventActionMeta);
    }
    if (data.containsKey('details')) {
      context.handle(_detailsMeta,
          details.isAcceptableOrUnknown(data['details']!, _detailsMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AuditLogData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditLogData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      timestamp: attachedDatabase.typeMapping
          .read(DriftSqlType.double, data['${effectivePrefix}timestamp'])!,
      eventAction: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}event_action'])!,
      details: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}details']),
    );
  }

  @override
  AuditLog createAlias(String alias) {
    return AuditLog(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AuditLogData extends DataClass implements Insertable<AuditLogData> {
  final int id;
  final int userId;
  final double timestamp;
  final String eventAction;
  final String? details;
  const AuditLogData(
      {required this.id,
      required this.userId,
      required this.timestamp,
      required this.eventAction,
      this.details});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['user_id'] = Variable<int>(userId);
    map['timestamp'] = Variable<double>(timestamp);
    map['event_action'] = Variable<String>(eventAction);
    if (!nullToAbsent || details != null) {
      map['details'] = Variable<String>(details);
    }
    return map;
  }

  AuditLogCompanion toCompanion(bool nullToAbsent) {
    return AuditLogCompanion(
      id: Value(id),
      userId: Value(userId),
      timestamp: Value(timestamp),
      eventAction: Value(eventAction),
      details: details == null && nullToAbsent
          ? const Value.absent()
          : Value(details),
    );
  }

  factory AuditLogData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditLogData(
      id: serializer.fromJson<int>(json['id']),
      userId: serializer.fromJson<int>(json['user_id']),
      timestamp: serializer.fromJson<double>(json['timestamp']),
      eventAction: serializer.fromJson<String>(json['event_action']),
      details: serializer.fromJson<String?>(json['details']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'user_id': serializer.toJson<int>(userId),
      'timestamp': serializer.toJson<double>(timestamp),
      'event_action': serializer.toJson<String>(eventAction),
      'details': serializer.toJson<String?>(details),
    };
  }

  AuditLogData copyWith(
          {int? id,
          int? userId,
          double? timestamp,
          String? eventAction,
          Value<String?> details = const Value.absent()}) =>
      AuditLogData(
        id: id ?? this.id,
        userId: userId ?? this.userId,
        timestamp: timestamp ?? this.timestamp,
        eventAction: eventAction ?? this.eventAction,
        details: details.present ? details.value : this.details,
      );
  AuditLogData copyWithCompanion(AuditLogCompanion data) {
    return AuditLogData(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      eventAction:
          data.eventAction.present ? data.eventAction.value : this.eventAction,
      details: data.details.present ? data.details.value : this.details,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogData(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('timestamp: $timestamp, ')
          ..write('eventAction: $eventAction, ')
          ..write('details: $details')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, userId, timestamp, eventAction, details);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditLogData &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.timestamp == this.timestamp &&
          other.eventAction == this.eventAction &&
          other.details == this.details);
}

class AuditLogCompanion extends UpdateCompanion<AuditLogData> {
  final Value<int> id;
  final Value<int> userId;
  final Value<double> timestamp;
  final Value<String> eventAction;
  final Value<String?> details;
  const AuditLogCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.eventAction = const Value.absent(),
    this.details = const Value.absent(),
  });
  AuditLogCompanion.insert({
    this.id = const Value.absent(),
    required int userId,
    required double timestamp,
    required String eventAction,
    this.details = const Value.absent(),
  })  : userId = Value(userId),
        timestamp = Value(timestamp),
        eventAction = Value(eventAction);
  static Insertable<AuditLogData> custom({
    Expression<int>? id,
    Expression<int>? userId,
    Expression<double>? timestamp,
    Expression<String>? eventAction,
    Expression<String>? details,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (timestamp != null) 'timestamp': timestamp,
      if (eventAction != null) 'event_action': eventAction,
      if (details != null) 'details': details,
    });
  }

  AuditLogCompanion copyWith(
      {Value<int>? id,
      Value<int>? userId,
      Value<double>? timestamp,
      Value<String>? eventAction,
      Value<String?>? details}) {
    return AuditLogCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      timestamp: timestamp ?? this.timestamp,
      eventAction: eventAction ?? this.eventAction,
      details: details ?? this.details,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<double>(timestamp.value);
    }
    if (eventAction.present) {
      map['event_action'] = Variable<String>(eventAction.value);
    }
    if (details.present) {
      map['details'] = Variable<String>(details.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('timestamp: $timestamp, ')
          ..write('eventAction: $eventAction, ')
          ..write('details: $details')
          ..write(')'))
        .toString();
  }
}

class SystemConfig extends Table
    with TableInfo<SystemConfig, SystemConfigData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  SystemConfig(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      $customConstraints: 'NOT NULL PRIMARY KEY');
  static const VerificationMeta _languageMeta =
      const VerificationMeta('language');
  late final GeneratedColumn<String> language = GeneratedColumn<String>(
      'language', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _defaultCurrencyCodeMeta =
      const VerificationMeta('defaultCurrencyCode');
  late final GeneratedColumn<String> defaultCurrencyCode =
      GeneratedColumn<String>('default_currency_code', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints: 'NOT NULL');
  static const VerificationMeta _dateFormatMeta =
      const VerificationMeta('dateFormat');
  late final GeneratedColumn<String> dateFormat = GeneratedColumn<String>(
      'date_format', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _calendarTypeMeta =
      const VerificationMeta('calendarType');
  late final GeneratedColumn<String> calendarType = GeneratedColumn<String>(
      'calendar_type', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _accountNumberTypeMeta =
      const VerificationMeta('accountNumberType');
  late final GeneratedColumn<String> accountNumberType =
      GeneratedColumn<String>('account_number_type', aliasedName, false,
          type: DriftSqlType.string,
          requiredDuringInsert: true,
          $customConstraints: 'NOT NULL');
  static const VerificationMeta _accountNumberLengthMeta =
      const VerificationMeta('accountNumberLength');
  late final GeneratedColumn<int> accountNumberLength = GeneratedColumn<int>(
      'account_number_length', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _costCenterPolicyMeta =
      const VerificationMeta('costCenterPolicy');
  late final GeneratedColumn<String> costCenterPolicy = GeneratedColumn<String>(
      'cost_center_policy', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _projectPolicyMeta =
      const VerificationMeta('projectPolicy');
  late final GeneratedColumn<String> projectPolicy = GeneratedColumn<String>(
      'project_policy', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _passwordMinLengthMeta =
      const VerificationMeta('passwordMinLength');
  late final GeneratedColumn<int> passwordMinLength = GeneratedColumn<int>(
      'password_min_length', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _autoLockTimeoutMeta =
      const VerificationMeta('autoLockTimeout');
  late final GeneratedColumn<int> autoLockTimeout = GeneratedColumn<int>(
      'auto_lock_timeout', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _useVatMeta = const VerificationMeta('useVat');
  late final GeneratedColumn<bool> useVat = GeneratedColumn<bool>(
      'use_vat', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _useTdsMeta = const VerificationMeta('useTds');
  late final GeneratedColumn<bool> useTds = GeneratedColumn<bool>(
      'use_tds', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _useEInvoiceMeta =
      const VerificationMeta('useEInvoice');
  late final GeneratedColumn<bool> useEInvoice = GeneratedColumn<bool>(
      'use_e_invoice', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _priceIncludesTaxMeta =
      const VerificationMeta('priceIncludesTax');
  late final GeneratedColumn<bool> priceIncludesTax = GeneratedColumn<bool>(
      'price_includes_tax', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _backupFrequencyMeta =
      const VerificationMeta('backupFrequency');
  late final GeneratedColumn<String> backupFrequency = GeneratedColumn<String>(
      'backup_frequency', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _cloudBackupMeta =
      const VerificationMeta('cloudBackup');
  late final GeneratedColumn<bool> cloudBackup = GeneratedColumn<bool>(
      'cloud_backup', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _uiThemeMeta =
      const VerificationMeta('uiTheme');
  late final GeneratedColumn<String> uiTheme = GeneratedColumn<String>(
      'ui_theme', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  static const VerificationMeta _fontSizeMeta =
      const VerificationMeta('fontSize');
  late final GeneratedColumn<String> fontSize = GeneratedColumn<String>(
      'font_size', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL');
  @override
  List<GeneratedColumn> get $columns => [
        id,
        language,
        defaultCurrencyCode,
        dateFormat,
        calendarType,
        accountNumberType,
        accountNumberLength,
        costCenterPolicy,
        projectPolicy,
        passwordMinLength,
        autoLockTimeout,
        useVat,
        useTds,
        useEInvoice,
        priceIncludesTax,
        backupFrequency,
        cloudBackup,
        uiTheme,
        fontSize
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'system_config';
  @override
  VerificationContext validateIntegrity(Insertable<SystemConfigData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('language')) {
      context.handle(_languageMeta,
          language.isAcceptableOrUnknown(data['language']!, _languageMeta));
    } else if (isInserting) {
      context.missing(_languageMeta);
    }
    if (data.containsKey('default_currency_code')) {
      context.handle(
          _defaultCurrencyCodeMeta,
          defaultCurrencyCode.isAcceptableOrUnknown(
              data['default_currency_code']!, _defaultCurrencyCodeMeta));
    } else if (isInserting) {
      context.missing(_defaultCurrencyCodeMeta);
    }
    if (data.containsKey('date_format')) {
      context.handle(
          _dateFormatMeta,
          dateFormat.isAcceptableOrUnknown(
              data['date_format']!, _dateFormatMeta));
    } else if (isInserting) {
      context.missing(_dateFormatMeta);
    }
    if (data.containsKey('calendar_type')) {
      context.handle(
          _calendarTypeMeta,
          calendarType.isAcceptableOrUnknown(
              data['calendar_type']!, _calendarTypeMeta));
    } else if (isInserting) {
      context.missing(_calendarTypeMeta);
    }
    if (data.containsKey('account_number_type')) {
      context.handle(
          _accountNumberTypeMeta,
          accountNumberType.isAcceptableOrUnknown(
              data['account_number_type']!, _accountNumberTypeMeta));
    } else if (isInserting) {
      context.missing(_accountNumberTypeMeta);
    }
    if (data.containsKey('account_number_length')) {
      context.handle(
          _accountNumberLengthMeta,
          accountNumberLength.isAcceptableOrUnknown(
              data['account_number_length']!, _accountNumberLengthMeta));
    } else if (isInserting) {
      context.missing(_accountNumberLengthMeta);
    }
    if (data.containsKey('cost_center_policy')) {
      context.handle(
          _costCenterPolicyMeta,
          costCenterPolicy.isAcceptableOrUnknown(
              data['cost_center_policy']!, _costCenterPolicyMeta));
    } else if (isInserting) {
      context.missing(_costCenterPolicyMeta);
    }
    if (data.containsKey('project_policy')) {
      context.handle(
          _projectPolicyMeta,
          projectPolicy.isAcceptableOrUnknown(
              data['project_policy']!, _projectPolicyMeta));
    } else if (isInserting) {
      context.missing(_projectPolicyMeta);
    }
    if (data.containsKey('password_min_length')) {
      context.handle(
          _passwordMinLengthMeta,
          passwordMinLength.isAcceptableOrUnknown(
              data['password_min_length']!, _passwordMinLengthMeta));
    } else if (isInserting) {
      context.missing(_passwordMinLengthMeta);
    }
    if (data.containsKey('auto_lock_timeout')) {
      context.handle(
          _autoLockTimeoutMeta,
          autoLockTimeout.isAcceptableOrUnknown(
              data['auto_lock_timeout']!, _autoLockTimeoutMeta));
    } else if (isInserting) {
      context.missing(_autoLockTimeoutMeta);
    }
    if (data.containsKey('use_vat')) {
      context.handle(_useVatMeta,
          useVat.isAcceptableOrUnknown(data['use_vat']!, _useVatMeta));
    } else if (isInserting) {
      context.missing(_useVatMeta);
    }
    if (data.containsKey('use_tds')) {
      context.handle(_useTdsMeta,
          useTds.isAcceptableOrUnknown(data['use_tds']!, _useTdsMeta));
    } else if (isInserting) {
      context.missing(_useTdsMeta);
    }
    if (data.containsKey('use_e_invoice')) {
      context.handle(
          _useEInvoiceMeta,
          useEInvoice.isAcceptableOrUnknown(
              data['use_e_invoice']!, _useEInvoiceMeta));
    } else if (isInserting) {
      context.missing(_useEInvoiceMeta);
    }
    if (data.containsKey('price_includes_tax')) {
      context.handle(
          _priceIncludesTaxMeta,
          priceIncludesTax.isAcceptableOrUnknown(
              data['price_includes_tax']!, _priceIncludesTaxMeta));
    } else if (isInserting) {
      context.missing(_priceIncludesTaxMeta);
    }
    if (data.containsKey('backup_frequency')) {
      context.handle(
          _backupFrequencyMeta,
          backupFrequency.isAcceptableOrUnknown(
              data['backup_frequency']!, _backupFrequencyMeta));
    } else if (isInserting) {
      context.missing(_backupFrequencyMeta);
    }
    if (data.containsKey('cloud_backup')) {
      context.handle(
          _cloudBackupMeta,
          cloudBackup.isAcceptableOrUnknown(
              data['cloud_backup']!, _cloudBackupMeta));
    } else if (isInserting) {
      context.missing(_cloudBackupMeta);
    }
    if (data.containsKey('ui_theme')) {
      context.handle(_uiThemeMeta,
          uiTheme.isAcceptableOrUnknown(data['ui_theme']!, _uiThemeMeta));
    } else if (isInserting) {
      context.missing(_uiThemeMeta);
    }
    if (data.containsKey('font_size')) {
      context.handle(_fontSizeMeta,
          fontSize.isAcceptableOrUnknown(data['font_size']!, _fontSizeMeta));
    } else if (isInserting) {
      context.missing(_fontSizeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SystemConfigData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SystemConfigData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      language: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}language'])!,
      defaultCurrencyCode: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}default_currency_code'])!,
      dateFormat: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}date_format'])!,
      calendarType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}calendar_type'])!,
      accountNumberType: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}account_number_type'])!,
      accountNumberLength: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}account_number_length'])!,
      costCenterPolicy: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}cost_center_policy'])!,
      projectPolicy: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}project_policy'])!,
      passwordMinLength: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}password_min_length'])!,
      autoLockTimeout: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}auto_lock_timeout'])!,
      useVat: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}use_vat'])!,
      useTds: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}use_tds'])!,
      useEInvoice: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}use_e_invoice'])!,
      priceIncludesTax: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}price_includes_tax'])!,
      backupFrequency: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}backup_frequency'])!,
      cloudBackup: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}cloud_backup'])!,
      uiTheme: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}ui_theme'])!,
      fontSize: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}font_size'])!,
    );
  }

  @override
  SystemConfig createAlias(String alias) {
    return SystemConfig(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class SystemConfigData extends DataClass
    implements Insertable<SystemConfigData> {
  final int id;
  final String language;
  final String defaultCurrencyCode;
  final String dateFormat;
  final String calendarType;
  final String accountNumberType;
  final int accountNumberLength;
  final String costCenterPolicy;
  final String projectPolicy;
  final int passwordMinLength;
  final int autoLockTimeout;
  final bool useVat;
  final bool useTds;
  final bool useEInvoice;
  final bool priceIncludesTax;
  final String backupFrequency;
  final bool cloudBackup;
  final String uiTheme;
  final String fontSize;
  const SystemConfigData(
      {required this.id,
      required this.language,
      required this.defaultCurrencyCode,
      required this.dateFormat,
      required this.calendarType,
      required this.accountNumberType,
      required this.accountNumberLength,
      required this.costCenterPolicy,
      required this.projectPolicy,
      required this.passwordMinLength,
      required this.autoLockTimeout,
      required this.useVat,
      required this.useTds,
      required this.useEInvoice,
      required this.priceIncludesTax,
      required this.backupFrequency,
      required this.cloudBackup,
      required this.uiTheme,
      required this.fontSize});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['language'] = Variable<String>(language);
    map['default_currency_code'] = Variable<String>(defaultCurrencyCode);
    map['date_format'] = Variable<String>(dateFormat);
    map['calendar_type'] = Variable<String>(calendarType);
    map['account_number_type'] = Variable<String>(accountNumberType);
    map['account_number_length'] = Variable<int>(accountNumberLength);
    map['cost_center_policy'] = Variable<String>(costCenterPolicy);
    map['project_policy'] = Variable<String>(projectPolicy);
    map['password_min_length'] = Variable<int>(passwordMinLength);
    map['auto_lock_timeout'] = Variable<int>(autoLockTimeout);
    map['use_vat'] = Variable<bool>(useVat);
    map['use_tds'] = Variable<bool>(useTds);
    map['use_e_invoice'] = Variable<bool>(useEInvoice);
    map['price_includes_tax'] = Variable<bool>(priceIncludesTax);
    map['backup_frequency'] = Variable<String>(backupFrequency);
    map['cloud_backup'] = Variable<bool>(cloudBackup);
    map['ui_theme'] = Variable<String>(uiTheme);
    map['font_size'] = Variable<String>(fontSize);
    return map;
  }

  SystemConfigCompanion toCompanion(bool nullToAbsent) {
    return SystemConfigCompanion(
      id: Value(id),
      language: Value(language),
      defaultCurrencyCode: Value(defaultCurrencyCode),
      dateFormat: Value(dateFormat),
      calendarType: Value(calendarType),
      accountNumberType: Value(accountNumberType),
      accountNumberLength: Value(accountNumberLength),
      costCenterPolicy: Value(costCenterPolicy),
      projectPolicy: Value(projectPolicy),
      passwordMinLength: Value(passwordMinLength),
      autoLockTimeout: Value(autoLockTimeout),
      useVat: Value(useVat),
      useTds: Value(useTds),
      useEInvoice: Value(useEInvoice),
      priceIncludesTax: Value(priceIncludesTax),
      backupFrequency: Value(backupFrequency),
      cloudBackup: Value(cloudBackup),
      uiTheme: Value(uiTheme),
      fontSize: Value(fontSize),
    );
  }

  factory SystemConfigData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SystemConfigData(
      id: serializer.fromJson<int>(json['id']),
      language: serializer.fromJson<String>(json['language']),
      defaultCurrencyCode:
          serializer.fromJson<String>(json['default_currency_code']),
      dateFormat: serializer.fromJson<String>(json['date_format']),
      calendarType: serializer.fromJson<String>(json['calendar_type']),
      accountNumberType:
          serializer.fromJson<String>(json['account_number_type']),
      accountNumberLength:
          serializer.fromJson<int>(json['account_number_length']),
      costCenterPolicy: serializer.fromJson<String>(json['cost_center_policy']),
      projectPolicy: serializer.fromJson<String>(json['project_policy']),
      passwordMinLength: serializer.fromJson<int>(json['password_min_length']),
      autoLockTimeout: serializer.fromJson<int>(json['auto_lock_timeout']),
      useVat: serializer.fromJson<bool>(json['use_vat']),
      useTds: serializer.fromJson<bool>(json['use_tds']),
      useEInvoice: serializer.fromJson<bool>(json['use_e_invoice']),
      priceIncludesTax: serializer.fromJson<bool>(json['price_includes_tax']),
      backupFrequency: serializer.fromJson<String>(json['backup_frequency']),
      cloudBackup: serializer.fromJson<bool>(json['cloud_backup']),
      uiTheme: serializer.fromJson<String>(json['ui_theme']),
      fontSize: serializer.fromJson<String>(json['font_size']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'language': serializer.toJson<String>(language),
      'default_currency_code': serializer.toJson<String>(defaultCurrencyCode),
      'date_format': serializer.toJson<String>(dateFormat),
      'calendar_type': serializer.toJson<String>(calendarType),
      'account_number_type': serializer.toJson<String>(accountNumberType),
      'account_number_length': serializer.toJson<int>(accountNumberLength),
      'cost_center_policy': serializer.toJson<String>(costCenterPolicy),
      'project_policy': serializer.toJson<String>(projectPolicy),
      'password_min_length': serializer.toJson<int>(passwordMinLength),
      'auto_lock_timeout': serializer.toJson<int>(autoLockTimeout),
      'use_vat': serializer.toJson<bool>(useVat),
      'use_tds': serializer.toJson<bool>(useTds),
      'use_e_invoice': serializer.toJson<bool>(useEInvoice),
      'price_includes_tax': serializer.toJson<bool>(priceIncludesTax),
      'backup_frequency': serializer.toJson<String>(backupFrequency),
      'cloud_backup': serializer.toJson<bool>(cloudBackup),
      'ui_theme': serializer.toJson<String>(uiTheme),
      'font_size': serializer.toJson<String>(fontSize),
    };
  }

  SystemConfigData copyWith(
          {int? id,
          String? language,
          String? defaultCurrencyCode,
          String? dateFormat,
          String? calendarType,
          String? accountNumberType,
          int? accountNumberLength,
          String? costCenterPolicy,
          String? projectPolicy,
          int? passwordMinLength,
          int? autoLockTimeout,
          bool? useVat,
          bool? useTds,
          bool? useEInvoice,
          bool? priceIncludesTax,
          String? backupFrequency,
          bool? cloudBackup,
          String? uiTheme,
          String? fontSize}) =>
      SystemConfigData(
        id: id ?? this.id,
        language: language ?? this.language,
        defaultCurrencyCode: defaultCurrencyCode ?? this.defaultCurrencyCode,
        dateFormat: dateFormat ?? this.dateFormat,
        calendarType: calendarType ?? this.calendarType,
        accountNumberType: accountNumberType ?? this.accountNumberType,
        accountNumberLength: accountNumberLength ?? this.accountNumberLength,
        costCenterPolicy: costCenterPolicy ?? this.costCenterPolicy,
        projectPolicy: projectPolicy ?? this.projectPolicy,
        passwordMinLength: passwordMinLength ?? this.passwordMinLength,
        autoLockTimeout: autoLockTimeout ?? this.autoLockTimeout,
        useVat: useVat ?? this.useVat,
        useTds: useTds ?? this.useTds,
        useEInvoice: useEInvoice ?? this.useEInvoice,
        priceIncludesTax: priceIncludesTax ?? this.priceIncludesTax,
        backupFrequency: backupFrequency ?? this.backupFrequency,
        cloudBackup: cloudBackup ?? this.cloudBackup,
        uiTheme: uiTheme ?? this.uiTheme,
        fontSize: fontSize ?? this.fontSize,
      );
  SystemConfigData copyWithCompanion(SystemConfigCompanion data) {
    return SystemConfigData(
      id: data.id.present ? data.id.value : this.id,
      language: data.language.present ? data.language.value : this.language,
      defaultCurrencyCode: data.defaultCurrencyCode.present
          ? data.defaultCurrencyCode.value
          : this.defaultCurrencyCode,
      dateFormat:
          data.dateFormat.present ? data.dateFormat.value : this.dateFormat,
      calendarType: data.calendarType.present
          ? data.calendarType.value
          : this.calendarType,
      accountNumberType: data.accountNumberType.present
          ? data.accountNumberType.value
          : this.accountNumberType,
      accountNumberLength: data.accountNumberLength.present
          ? data.accountNumberLength.value
          : this.accountNumberLength,
      costCenterPolicy: data.costCenterPolicy.present
          ? data.costCenterPolicy.value
          : this.costCenterPolicy,
      projectPolicy: data.projectPolicy.present
          ? data.projectPolicy.value
          : this.projectPolicy,
      passwordMinLength: data.passwordMinLength.present
          ? data.passwordMinLength.value
          : this.passwordMinLength,
      autoLockTimeout: data.autoLockTimeout.present
          ? data.autoLockTimeout.value
          : this.autoLockTimeout,
      useVat: data.useVat.present ? data.useVat.value : this.useVat,
      useTds: data.useTds.present ? data.useTds.value : this.useTds,
      useEInvoice:
          data.useEInvoice.present ? data.useEInvoice.value : this.useEInvoice,
      priceIncludesTax: data.priceIncludesTax.present
          ? data.priceIncludesTax.value
          : this.priceIncludesTax,
      backupFrequency: data.backupFrequency.present
          ? data.backupFrequency.value
          : this.backupFrequency,
      cloudBackup:
          data.cloudBackup.present ? data.cloudBackup.value : this.cloudBackup,
      uiTheme: data.uiTheme.present ? data.uiTheme.value : this.uiTheme,
      fontSize: data.fontSize.present ? data.fontSize.value : this.fontSize,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SystemConfigData(')
          ..write('id: $id, ')
          ..write('language: $language, ')
          ..write('defaultCurrencyCode: $defaultCurrencyCode, ')
          ..write('dateFormat: $dateFormat, ')
          ..write('calendarType: $calendarType, ')
          ..write('accountNumberType: $accountNumberType, ')
          ..write('accountNumberLength: $accountNumberLength, ')
          ..write('costCenterPolicy: $costCenterPolicy, ')
          ..write('projectPolicy: $projectPolicy, ')
          ..write('passwordMinLength: $passwordMinLength, ')
          ..write('autoLockTimeout: $autoLockTimeout, ')
          ..write('useVat: $useVat, ')
          ..write('useTds: $useTds, ')
          ..write('useEInvoice: $useEInvoice, ')
          ..write('priceIncludesTax: $priceIncludesTax, ')
          ..write('backupFrequency: $backupFrequency, ')
          ..write('cloudBackup: $cloudBackup, ')
          ..write('uiTheme: $uiTheme, ')
          ..write('fontSize: $fontSize')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      language,
      defaultCurrencyCode,
      dateFormat,
      calendarType,
      accountNumberType,
      accountNumberLength,
      costCenterPolicy,
      projectPolicy,
      passwordMinLength,
      autoLockTimeout,
      useVat,
      useTds,
      useEInvoice,
      priceIncludesTax,
      backupFrequency,
      cloudBackup,
      uiTheme,
      fontSize);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SystemConfigData &&
          other.id == this.id &&
          other.language == this.language &&
          other.defaultCurrencyCode == this.defaultCurrencyCode &&
          other.dateFormat == this.dateFormat &&
          other.calendarType == this.calendarType &&
          other.accountNumberType == this.accountNumberType &&
          other.accountNumberLength == this.accountNumberLength &&
          other.costCenterPolicy == this.costCenterPolicy &&
          other.projectPolicy == this.projectPolicy &&
          other.passwordMinLength == this.passwordMinLength &&
          other.autoLockTimeout == this.autoLockTimeout &&
          other.useVat == this.useVat &&
          other.useTds == this.useTds &&
          other.useEInvoice == this.useEInvoice &&
          other.priceIncludesTax == this.priceIncludesTax &&
          other.backupFrequency == this.backupFrequency &&
          other.cloudBackup == this.cloudBackup &&
          other.uiTheme == this.uiTheme &&
          other.fontSize == this.fontSize);
}

class SystemConfigCompanion extends UpdateCompanion<SystemConfigData> {
  final Value<int> id;
  final Value<String> language;
  final Value<String> defaultCurrencyCode;
  final Value<String> dateFormat;
  final Value<String> calendarType;
  final Value<String> accountNumberType;
  final Value<int> accountNumberLength;
  final Value<String> costCenterPolicy;
  final Value<String> projectPolicy;
  final Value<int> passwordMinLength;
  final Value<int> autoLockTimeout;
  final Value<bool> useVat;
  final Value<bool> useTds;
  final Value<bool> useEInvoice;
  final Value<bool> priceIncludesTax;
  final Value<String> backupFrequency;
  final Value<bool> cloudBackup;
  final Value<String> uiTheme;
  final Value<String> fontSize;
  const SystemConfigCompanion({
    this.id = const Value.absent(),
    this.language = const Value.absent(),
    this.defaultCurrencyCode = const Value.absent(),
    this.dateFormat = const Value.absent(),
    this.calendarType = const Value.absent(),
    this.accountNumberType = const Value.absent(),
    this.accountNumberLength = const Value.absent(),
    this.costCenterPolicy = const Value.absent(),
    this.projectPolicy = const Value.absent(),
    this.passwordMinLength = const Value.absent(),
    this.autoLockTimeout = const Value.absent(),
    this.useVat = const Value.absent(),
    this.useTds = const Value.absent(),
    this.useEInvoice = const Value.absent(),
    this.priceIncludesTax = const Value.absent(),
    this.backupFrequency = const Value.absent(),
    this.cloudBackup = const Value.absent(),
    this.uiTheme = const Value.absent(),
    this.fontSize = const Value.absent(),
  });
  SystemConfigCompanion.insert({
    this.id = const Value.absent(),
    required String language,
    required String defaultCurrencyCode,
    required String dateFormat,
    required String calendarType,
    required String accountNumberType,
    required int accountNumberLength,
    required String costCenterPolicy,
    required String projectPolicy,
    required int passwordMinLength,
    required int autoLockTimeout,
    required bool useVat,
    required bool useTds,
    required bool useEInvoice,
    required bool priceIncludesTax,
    required String backupFrequency,
    required bool cloudBackup,
    required String uiTheme,
    required String fontSize,
  })  : language = Value(language),
        defaultCurrencyCode = Value(defaultCurrencyCode),
        dateFormat = Value(dateFormat),
        calendarType = Value(calendarType),
        accountNumberType = Value(accountNumberType),
        accountNumberLength = Value(accountNumberLength),
        costCenterPolicy = Value(costCenterPolicy),
        projectPolicy = Value(projectPolicy),
        passwordMinLength = Value(passwordMinLength),
        autoLockTimeout = Value(autoLockTimeout),
        useVat = Value(useVat),
        useTds = Value(useTds),
        useEInvoice = Value(useEInvoice),
        priceIncludesTax = Value(priceIncludesTax),
        backupFrequency = Value(backupFrequency),
        cloudBackup = Value(cloudBackup),
        uiTheme = Value(uiTheme),
        fontSize = Value(fontSize);
  static Insertable<SystemConfigData> custom({
    Expression<int>? id,
    Expression<String>? language,
    Expression<String>? defaultCurrencyCode,
    Expression<String>? dateFormat,
    Expression<String>? calendarType,
    Expression<String>? accountNumberType,
    Expression<int>? accountNumberLength,
    Expression<String>? costCenterPolicy,
    Expression<String>? projectPolicy,
    Expression<int>? passwordMinLength,
    Expression<int>? autoLockTimeout,
    Expression<bool>? useVat,
    Expression<bool>? useTds,
    Expression<bool>? useEInvoice,
    Expression<bool>? priceIncludesTax,
    Expression<String>? backupFrequency,
    Expression<bool>? cloudBackup,
    Expression<String>? uiTheme,
    Expression<String>? fontSize,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (language != null) 'language': language,
      if (defaultCurrencyCode != null)
        'default_currency_code': defaultCurrencyCode,
      if (dateFormat != null) 'date_format': dateFormat,
      if (calendarType != null) 'calendar_type': calendarType,
      if (accountNumberType != null) 'account_number_type': accountNumberType,
      if (accountNumberLength != null)
        'account_number_length': accountNumberLength,
      if (costCenterPolicy != null) 'cost_center_policy': costCenterPolicy,
      if (projectPolicy != null) 'project_policy': projectPolicy,
      if (passwordMinLength != null) 'password_min_length': passwordMinLength,
      if (autoLockTimeout != null) 'auto_lock_timeout': autoLockTimeout,
      if (useVat != null) 'use_vat': useVat,
      if (useTds != null) 'use_tds': useTds,
      if (useEInvoice != null) 'use_e_invoice': useEInvoice,
      if (priceIncludesTax != null) 'price_includes_tax': priceIncludesTax,
      if (backupFrequency != null) 'backup_frequency': backupFrequency,
      if (cloudBackup != null) 'cloud_backup': cloudBackup,
      if (uiTheme != null) 'ui_theme': uiTheme,
      if (fontSize != null) 'font_size': fontSize,
    });
  }

  SystemConfigCompanion copyWith(
      {Value<int>? id,
      Value<String>? language,
      Value<String>? defaultCurrencyCode,
      Value<String>? dateFormat,
      Value<String>? calendarType,
      Value<String>? accountNumberType,
      Value<int>? accountNumberLength,
      Value<String>? costCenterPolicy,
      Value<String>? projectPolicy,
      Value<int>? passwordMinLength,
      Value<int>? autoLockTimeout,
      Value<bool>? useVat,
      Value<bool>? useTds,
      Value<bool>? useEInvoice,
      Value<bool>? priceIncludesTax,
      Value<String>? backupFrequency,
      Value<bool>? cloudBackup,
      Value<String>? uiTheme,
      Value<String>? fontSize}) {
    return SystemConfigCompanion(
      id: id ?? this.id,
      language: language ?? this.language,
      defaultCurrencyCode: defaultCurrencyCode ?? this.defaultCurrencyCode,
      dateFormat: dateFormat ?? this.dateFormat,
      calendarType: calendarType ?? this.calendarType,
      accountNumberType: accountNumberType ?? this.accountNumberType,
      accountNumberLength: accountNumberLength ?? this.accountNumberLength,
      costCenterPolicy: costCenterPolicy ?? this.costCenterPolicy,
      projectPolicy: projectPolicy ?? this.projectPolicy,
      passwordMinLength: passwordMinLength ?? this.passwordMinLength,
      autoLockTimeout: autoLockTimeout ?? this.autoLockTimeout,
      useVat: useVat ?? this.useVat,
      useTds: useTds ?? this.useTds,
      useEInvoice: useEInvoice ?? this.useEInvoice,
      priceIncludesTax: priceIncludesTax ?? this.priceIncludesTax,
      backupFrequency: backupFrequency ?? this.backupFrequency,
      cloudBackup: cloudBackup ?? this.cloudBackup,
      uiTheme: uiTheme ?? this.uiTheme,
      fontSize: fontSize ?? this.fontSize,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (language.present) {
      map['language'] = Variable<String>(language.value);
    }
    if (defaultCurrencyCode.present) {
      map['default_currency_code'] =
          Variable<String>(defaultCurrencyCode.value);
    }
    if (dateFormat.present) {
      map['date_format'] = Variable<String>(dateFormat.value);
    }
    if (calendarType.present) {
      map['calendar_type'] = Variable<String>(calendarType.value);
    }
    if (accountNumberType.present) {
      map['account_number_type'] = Variable<String>(accountNumberType.value);
    }
    if (accountNumberLength.present) {
      map['account_number_length'] = Variable<int>(accountNumberLength.value);
    }
    if (costCenterPolicy.present) {
      map['cost_center_policy'] = Variable<String>(costCenterPolicy.value);
    }
    if (projectPolicy.present) {
      map['project_policy'] = Variable<String>(projectPolicy.value);
    }
    if (passwordMinLength.present) {
      map['password_min_length'] = Variable<int>(passwordMinLength.value);
    }
    if (autoLockTimeout.present) {
      map['auto_lock_timeout'] = Variable<int>(autoLockTimeout.value);
    }
    if (useVat.present) {
      map['use_vat'] = Variable<bool>(useVat.value);
    }
    if (useTds.present) {
      map['use_tds'] = Variable<bool>(useTds.value);
    }
    if (useEInvoice.present) {
      map['use_e_invoice'] = Variable<bool>(useEInvoice.value);
    }
    if (priceIncludesTax.present) {
      map['price_includes_tax'] = Variable<bool>(priceIncludesTax.value);
    }
    if (backupFrequency.present) {
      map['backup_frequency'] = Variable<String>(backupFrequency.value);
    }
    if (cloudBackup.present) {
      map['cloud_backup'] = Variable<bool>(cloudBackup.value);
    }
    if (uiTheme.present) {
      map['ui_theme'] = Variable<String>(uiTheme.value);
    }
    if (fontSize.present) {
      map['font_size'] = Variable<String>(fontSize.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SystemConfigCompanion(')
          ..write('id: $id, ')
          ..write('language: $language, ')
          ..write('defaultCurrencyCode: $defaultCurrencyCode, ')
          ..write('dateFormat: $dateFormat, ')
          ..write('calendarType: $calendarType, ')
          ..write('accountNumberType: $accountNumberType, ')
          ..write('accountNumberLength: $accountNumberLength, ')
          ..write('costCenterPolicy: $costCenterPolicy, ')
          ..write('projectPolicy: $projectPolicy, ')
          ..write('passwordMinLength: $passwordMinLength, ')
          ..write('autoLockTimeout: $autoLockTimeout, ')
          ..write('useVat: $useVat, ')
          ..write('useTds: $useTds, ')
          ..write('useEInvoice: $useEInvoice, ')
          ..write('priceIncludesTax: $priceIncludesTax, ')
          ..write('backupFrequency: $backupFrequency, ')
          ..write('cloudBackup: $cloudBackup, ')
          ..write('uiTheme: $uiTheme, ')
          ..write('fontSize: $fontSize')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final InventoryConfig inventoryConfig = InventoryConfig(this);
  late final CompanyInfo companyInfo = CompanyInfo(this);
  late final BranchGroups branchGroups = BranchGroups(this);
  late final Branches branches = Branches(this);
  late final Warehouses warehouses = Warehouses(this);
  late final ItemGroups itemGroups = ItemGroups(this);
  late final Items items = Items(this);
  late final ItemSubUnits itemSubUnits = ItemSubUnits(this);
  late final ItemSellingPrices itemSellingPrices = ItemSellingPrices(this);
  late final ItemPromotionalPrices itemPromotionalPrices =
      ItemPromotionalPrices(this);
  late final ItemAttachments itemAttachments = ItemAttachments(this);
  late final StockBalances stockBalances = StockBalances(this);
  late final StockTransactions stockTransactions = StockTransactions(this);
  late final IncomingStockOrders incomingStockOrders =
      IncomingStockOrders(this);
  late final IncomingStockOrderLines incomingStockOrderLines =
      IncomingStockOrderLines(this);
  late final OutgoingStockOrders outgoingStockOrders =
      OutgoingStockOrders(this);
  late final OutgoingStockOrderLines outgoingStockOrderLines =
      OutgoingStockOrderLines(this);
  late final WarehouseTransfers warehouseTransfers = WarehouseTransfers(this);
  late final WarehouseTransferLines warehouseTransferLines =
      WarehouseTransferLines(this);
  late final StocktakingSessions stocktakingSessions =
      StocktakingSessions(this);
  late final StocktakingCounts stocktakingCounts = StocktakingCounts(this);
  late final StockReservations stockReservations = StockReservations(this);
  late final FinancialPeriods financialPeriods = FinancialPeriods(this);
  late final Currencies currencies = Currencies(this);
  late final CurrencyDenominations currencyDenominations =
      CurrencyDenominations(this);
  late final TaxBracket taxBracket = TaxBracket(this);
  late final TaxCalcMethods taxCalcMethods = TaxCalcMethods(this);
  late final TaxTypes taxTypes = TaxTypes(this);
  late final Accounts accounts = Accounts(this);
  late final DocumentTypes documentTypes = DocumentTypes(this);
  late final DescriptionCoding descriptionCoding = DescriptionCoding(this);
  late final Index idxDocumentTypesActive = Index('idx_document_types_active',
      'CREATE INDEX idx_document_types_active ON document_types (is_active)');
  late final Index idxDescriptionCodingAccount = Index(
      'idx_description_coding_account',
      'CREATE INDEX idx_description_coding_account ON description_coding (linked_account_id)');
  late final Zones zones = Zones(this);
  late final Countries countries = Countries(this);
  late final Governorates governorates = Governorates(this);
  late final Cities cities = Cities(this);
  late final Regions regions = Regions(this);
  late final Roles roles = Roles(this);
  late final RolePermissions rolePermissions = RolePermissions(this);
  late final Users users = Users(this);
  late final UserRoles userRoles = UserRoles(this);
  late final AuditLog auditLog = AuditLog(this);
  late final SystemConfig systemConfig = SystemConfig(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        inventoryConfig,
        companyInfo,
        branchGroups,
        branches,
        warehouses,
        itemGroups,
        items,
        itemSubUnits,
        itemSellingPrices,
        itemPromotionalPrices,
        itemAttachments,
        stockBalances,
        stockTransactions,
        incomingStockOrders,
        incomingStockOrderLines,
        outgoingStockOrders,
        outgoingStockOrderLines,
        warehouseTransfers,
        warehouseTransferLines,
        stocktakingSessions,
        stocktakingCounts,
        stockReservations,
        financialPeriods,
        currencies,
        currencyDenominations,
        taxBracket,
        taxCalcMethods,
        taxTypes,
        accounts,
        documentTypes,
        descriptionCoding,
        idxDocumentTypesActive,
        idxDescriptionCodingAccount,
        zones,
        countries,
        governorates,
        cities,
        regions,
        roles,
        rolePermissions,
        users,
        userRoles,
        auditLog,
        systemConfig
      ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules(
        [
          WritePropagation(
            on: TableUpdateQuery.onTableName('items',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('item_sub_units', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('items',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('item_selling_prices', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('item_selling_prices',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('item_promotional_prices', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('items',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('item_attachments', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('incoming_stock_orders',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('incoming_stock_order_lines',
                  kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('outgoing_stock_orders',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('outgoing_stock_order_lines',
                  kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('warehouse_transfers',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('warehouse_transfer_lines', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('stocktaking_sessions',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('stocktaking_counts', kind: UpdateKind.delete),
            ],
          ),
        ],
      );
}

typedef $InventoryConfigCreateCompanionBuilder = InventoryConfigCompanion
    Function({
  Value<int> id,
  required String defaultCostingMethod,
  Value<bool> allowItemLevelOverride,
  Value<bool> enableMultipleWarehouses,
  Value<String?> transfersIntermediaryAccountId,
  Value<bool> enableExpiryDateTracking,
  Value<bool> enableBatchTracking,
  Value<String?> openingBalanceEquityAccountId,
  Value<String?> stockReceivedClearingAccountId,
  Value<String?> inventoryShortageExpenseAccountId,
  Value<String?> inventorySurplusRevenueAccountId,
  required int updatedAt,
});
typedef $InventoryConfigUpdateCompanionBuilder = InventoryConfigCompanion
    Function({
  Value<int> id,
  Value<String> defaultCostingMethod,
  Value<bool> allowItemLevelOverride,
  Value<bool> enableMultipleWarehouses,
  Value<String?> transfersIntermediaryAccountId,
  Value<bool> enableExpiryDateTracking,
  Value<bool> enableBatchTracking,
  Value<String?> openingBalanceEquityAccountId,
  Value<String?> stockReceivedClearingAccountId,
  Value<String?> inventoryShortageExpenseAccountId,
  Value<String?> inventorySurplusRevenueAccountId,
  Value<int> updatedAt,
});

class $InventoryConfigFilterComposer
    extends Composer<_$AppDatabase, InventoryConfig> {
  $InventoryConfigFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get defaultCostingMethod => $composableBuilder(
      column: $table.defaultCostingMethod,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get allowItemLevelOverride => $composableBuilder(
      column: $table.allowItemLevelOverride,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get enableMultipleWarehouses => $composableBuilder(
      column: $table.enableMultipleWarehouses,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transfersIntermediaryAccountId =>
      $composableBuilder(
          column: $table.transfersIntermediaryAccountId,
          builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get enableExpiryDateTracking => $composableBuilder(
      column: $table.enableExpiryDateTracking,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get enableBatchTracking => $composableBuilder(
      column: $table.enableBatchTracking,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get openingBalanceEquityAccountId => $composableBuilder(
      column: $table.openingBalanceEquityAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stockReceivedClearingAccountId =>
      $composableBuilder(
          column: $table.stockReceivedClearingAccountId,
          builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inventoryShortageExpenseAccountId =>
      $composableBuilder(
          column: $table.inventoryShortageExpenseAccountId,
          builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inventorySurplusRevenueAccountId =>
      $composableBuilder(
          column: $table.inventorySurplusRevenueAccountId,
          builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $InventoryConfigOrderingComposer
    extends Composer<_$AppDatabase, InventoryConfig> {
  $InventoryConfigOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get defaultCostingMethod => $composableBuilder(
      column: $table.defaultCostingMethod,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get allowItemLevelOverride => $composableBuilder(
      column: $table.allowItemLevelOverride,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get enableMultipleWarehouses => $composableBuilder(
      column: $table.enableMultipleWarehouses,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transfersIntermediaryAccountId =>
      $composableBuilder(
          column: $table.transfersIntermediaryAccountId,
          builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get enableExpiryDateTracking => $composableBuilder(
      column: $table.enableExpiryDateTracking,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get enableBatchTracking => $composableBuilder(
      column: $table.enableBatchTracking,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get openingBalanceEquityAccountId =>
      $composableBuilder(
          column: $table.openingBalanceEquityAccountId,
          builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stockReceivedClearingAccountId =>
      $composableBuilder(
          column: $table.stockReceivedClearingAccountId,
          builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inventoryShortageExpenseAccountId =>
      $composableBuilder(
          column: $table.inventoryShortageExpenseAccountId,
          builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inventorySurplusRevenueAccountId =>
      $composableBuilder(
          column: $table.inventorySurplusRevenueAccountId,
          builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $InventoryConfigAnnotationComposer
    extends Composer<_$AppDatabase, InventoryConfig> {
  $InventoryConfigAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get defaultCostingMethod => $composableBuilder(
      column: $table.defaultCostingMethod, builder: (column) => column);

  GeneratedColumn<bool> get allowItemLevelOverride => $composableBuilder(
      column: $table.allowItemLevelOverride, builder: (column) => column);

  GeneratedColumn<bool> get enableMultipleWarehouses => $composableBuilder(
      column: $table.enableMultipleWarehouses, builder: (column) => column);

  GeneratedColumn<String> get transfersIntermediaryAccountId =>
      $composableBuilder(
          column: $table.transfersIntermediaryAccountId,
          builder: (column) => column);

  GeneratedColumn<bool> get enableExpiryDateTracking => $composableBuilder(
      column: $table.enableExpiryDateTracking, builder: (column) => column);

  GeneratedColumn<bool> get enableBatchTracking => $composableBuilder(
      column: $table.enableBatchTracking, builder: (column) => column);

  GeneratedColumn<String> get openingBalanceEquityAccountId =>
      $composableBuilder(
          column: $table.openingBalanceEquityAccountId,
          builder: (column) => column);

  GeneratedColumn<String> get stockReceivedClearingAccountId =>
      $composableBuilder(
          column: $table.stockReceivedClearingAccountId,
          builder: (column) => column);

  GeneratedColumn<String> get inventoryShortageExpenseAccountId =>
      $composableBuilder(
          column: $table.inventoryShortageExpenseAccountId,
          builder: (column) => column);

  GeneratedColumn<String> get inventorySurplusRevenueAccountId =>
      $composableBuilder(
          column: $table.inventorySurplusRevenueAccountId,
          builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $InventoryConfigTableManager extends RootTableManager<
    _$AppDatabase,
    InventoryConfig,
    InventoryConfigData,
    $InventoryConfigFilterComposer,
    $InventoryConfigOrderingComposer,
    $InventoryConfigAnnotationComposer,
    $InventoryConfigCreateCompanionBuilder,
    $InventoryConfigUpdateCompanionBuilder,
    (
      InventoryConfigData,
      BaseReferences<_$AppDatabase, InventoryConfig, InventoryConfigData>
    ),
    InventoryConfigData,
    PrefetchHooks Function()> {
  $InventoryConfigTableManager(_$AppDatabase db, InventoryConfig table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $InventoryConfigFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $InventoryConfigOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $InventoryConfigAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> defaultCostingMethod = const Value.absent(),
            Value<bool> allowItemLevelOverride = const Value.absent(),
            Value<bool> enableMultipleWarehouses = const Value.absent(),
            Value<String?> transfersIntermediaryAccountId =
                const Value.absent(),
            Value<bool> enableExpiryDateTracking = const Value.absent(),
            Value<bool> enableBatchTracking = const Value.absent(),
            Value<String?> openingBalanceEquityAccountId = const Value.absent(),
            Value<String?> stockReceivedClearingAccountId =
                const Value.absent(),
            Value<String?> inventoryShortageExpenseAccountId =
                const Value.absent(),
            Value<String?> inventorySurplusRevenueAccountId =
                const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              InventoryConfigCompanion(
            id: id,
            defaultCostingMethod: defaultCostingMethod,
            allowItemLevelOverride: allowItemLevelOverride,
            enableMultipleWarehouses: enableMultipleWarehouses,
            transfersIntermediaryAccountId: transfersIntermediaryAccountId,
            enableExpiryDateTracking: enableExpiryDateTracking,
            enableBatchTracking: enableBatchTracking,
            openingBalanceEquityAccountId: openingBalanceEquityAccountId,
            stockReceivedClearingAccountId: stockReceivedClearingAccountId,
            inventoryShortageExpenseAccountId:
                inventoryShortageExpenseAccountId,
            inventorySurplusRevenueAccountId: inventorySurplusRevenueAccountId,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String defaultCostingMethod,
            Value<bool> allowItemLevelOverride = const Value.absent(),
            Value<bool> enableMultipleWarehouses = const Value.absent(),
            Value<String?> transfersIntermediaryAccountId =
                const Value.absent(),
            Value<bool> enableExpiryDateTracking = const Value.absent(),
            Value<bool> enableBatchTracking = const Value.absent(),
            Value<String?> openingBalanceEquityAccountId = const Value.absent(),
            Value<String?> stockReceivedClearingAccountId =
                const Value.absent(),
            Value<String?> inventoryShortageExpenseAccountId =
                const Value.absent(),
            Value<String?> inventorySurplusRevenueAccountId =
                const Value.absent(),
            required int updatedAt,
          }) =>
              InventoryConfigCompanion.insert(
            id: id,
            defaultCostingMethod: defaultCostingMethod,
            allowItemLevelOverride: allowItemLevelOverride,
            enableMultipleWarehouses: enableMultipleWarehouses,
            transfersIntermediaryAccountId: transfersIntermediaryAccountId,
            enableExpiryDateTracking: enableExpiryDateTracking,
            enableBatchTracking: enableBatchTracking,
            openingBalanceEquityAccountId: openingBalanceEquityAccountId,
            stockReceivedClearingAccountId: stockReceivedClearingAccountId,
            inventoryShortageExpenseAccountId:
                inventoryShortageExpenseAccountId,
            inventorySurplusRevenueAccountId: inventorySurplusRevenueAccountId,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $InventoryConfigProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    InventoryConfig,
    InventoryConfigData,
    $InventoryConfigFilterComposer,
    $InventoryConfigOrderingComposer,
    $InventoryConfigAnnotationComposer,
    $InventoryConfigCreateCompanionBuilder,
    $InventoryConfigUpdateCompanionBuilder,
    (
      InventoryConfigData,
      BaseReferences<_$AppDatabase, InventoryConfig, InventoryConfigData>
    ),
    InventoryConfigData,
    PrefetchHooks Function()>;
typedef $CompanyInfoCreateCompanionBuilder = CompanyInfoCompanion Function({
  Value<int> id,
  required String companyCode,
  required String nameAr,
  required String nameEn,
  Value<String?> countryId,
  Value<String?> taxNumber,
  Value<String?> commercialRegNo,
  Value<String?> address,
  Value<String?> phone,
  Value<String?> email,
  Value<Uint8List?> logo,
  required bool isMainCompany,
  Value<String?> remarks,
});
typedef $CompanyInfoUpdateCompanionBuilder = CompanyInfoCompanion Function({
  Value<int> id,
  Value<String> companyCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String?> countryId,
  Value<String?> taxNumber,
  Value<String?> commercialRegNo,
  Value<String?> address,
  Value<String?> phone,
  Value<String?> email,
  Value<Uint8List?> logo,
  Value<bool> isMainCompany,
  Value<String?> remarks,
});

final class $CompanyInfoReferences
    extends BaseReferences<_$AppDatabase, CompanyInfo, CompanyInfoData> {
  $CompanyInfoReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<Branches, List<Branche>> _branchesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.branches,
          aliasName:
              $_aliasNameGenerator(db.companyInfo.id, db.branches.companyId));

  $BranchesProcessedTableManager get branchesRefs {
    final manager = $BranchesTableManager($_db, $_db.branches)
        .filter((f) => f.companyId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_branchesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $CompanyInfoFilterComposer extends Composer<_$AppDatabase, CompanyInfo> {
  $CompanyInfoFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get companyCode => $composableBuilder(
      column: $table.companyCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get countryId => $composableBuilder(
      column: $table.countryId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get taxNumber => $composableBuilder(
      column: $table.taxNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get commercialRegNo => $composableBuilder(
      column: $table.commercialRegNo,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnFilters(column));

  ColumnFilters<Uint8List> get logo => $composableBuilder(
      column: $table.logo, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isMainCompany => $composableBuilder(
      column: $table.isMainCompany, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remarks => $composableBuilder(
      column: $table.remarks, builder: (column) => ColumnFilters(column));

  Expression<bool> branchesRefs(
      Expression<bool> Function($BranchesFilterComposer f) f) {
    final $BranchesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.companyId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesFilterComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CompanyInfoOrderingComposer
    extends Composer<_$AppDatabase, CompanyInfo> {
  $CompanyInfoOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get companyCode => $composableBuilder(
      column: $table.companyCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get countryId => $composableBuilder(
      column: $table.countryId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get taxNumber => $composableBuilder(
      column: $table.taxNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get commercialRegNo => $composableBuilder(
      column: $table.commercialRegNo,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get email => $composableBuilder(
      column: $table.email, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<Uint8List> get logo => $composableBuilder(
      column: $table.logo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isMainCompany => $composableBuilder(
      column: $table.isMainCompany,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remarks => $composableBuilder(
      column: $table.remarks, builder: (column) => ColumnOrderings(column));
}

class $CompanyInfoAnnotationComposer
    extends Composer<_$AppDatabase, CompanyInfo> {
  $CompanyInfoAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get companyCode => $composableBuilder(
      column: $table.companyCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get countryId =>
      $composableBuilder(column: $table.countryId, builder: (column) => column);

  GeneratedColumn<String> get taxNumber =>
      $composableBuilder(column: $table.taxNumber, builder: (column) => column);

  GeneratedColumn<String> get commercialRegNo => $composableBuilder(
      column: $table.commercialRegNo, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<Uint8List> get logo =>
      $composableBuilder(column: $table.logo, builder: (column) => column);

  GeneratedColumn<bool> get isMainCompany => $composableBuilder(
      column: $table.isMainCompany, builder: (column) => column);

  GeneratedColumn<String> get remarks =>
      $composableBuilder(column: $table.remarks, builder: (column) => column);

  Expression<T> branchesRefs<T extends Object>(
      Expression<T> Function($BranchesAnnotationComposer a) f) {
    final $BranchesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.companyId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesAnnotationComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CompanyInfoTableManager extends RootTableManager<
    _$AppDatabase,
    CompanyInfo,
    CompanyInfoData,
    $CompanyInfoFilterComposer,
    $CompanyInfoOrderingComposer,
    $CompanyInfoAnnotationComposer,
    $CompanyInfoCreateCompanionBuilder,
    $CompanyInfoUpdateCompanionBuilder,
    (CompanyInfoData, $CompanyInfoReferences),
    CompanyInfoData,
    PrefetchHooks Function({bool branchesRefs})> {
  $CompanyInfoTableManager(_$AppDatabase db, CompanyInfo table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $CompanyInfoFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $CompanyInfoOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $CompanyInfoAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> companyCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String?> countryId = const Value.absent(),
            Value<String?> taxNumber = const Value.absent(),
            Value<String?> commercialRegNo = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<Uint8List?> logo = const Value.absent(),
            Value<bool> isMainCompany = const Value.absent(),
            Value<String?> remarks = const Value.absent(),
          }) =>
              CompanyInfoCompanion(
            id: id,
            companyCode: companyCode,
            nameAr: nameAr,
            nameEn: nameEn,
            countryId: countryId,
            taxNumber: taxNumber,
            commercialRegNo: commercialRegNo,
            address: address,
            phone: phone,
            email: email,
            logo: logo,
            isMainCompany: isMainCompany,
            remarks: remarks,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String companyCode,
            required String nameAr,
            required String nameEn,
            Value<String?> countryId = const Value.absent(),
            Value<String?> taxNumber = const Value.absent(),
            Value<String?> commercialRegNo = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> email = const Value.absent(),
            Value<Uint8List?> logo = const Value.absent(),
            required bool isMainCompany,
            Value<String?> remarks = const Value.absent(),
          }) =>
              CompanyInfoCompanion.insert(
            id: id,
            companyCode: companyCode,
            nameAr: nameAr,
            nameEn: nameEn,
            countryId: countryId,
            taxNumber: taxNumber,
            commercialRegNo: commercialRegNo,
            address: address,
            phone: phone,
            email: email,
            logo: logo,
            isMainCompany: isMainCompany,
            remarks: remarks,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $CompanyInfoReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({branchesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (branchesRefs) db.branches],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (branchesRefs)
                    await $_getPrefetchedData<CompanyInfoData, CompanyInfo,
                            Branche>(
                        currentTable: table,
                        referencedTable:
                            $CompanyInfoReferences._branchesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $CompanyInfoReferences(db, table, p0).branchesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.companyId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $CompanyInfoProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    CompanyInfo,
    CompanyInfoData,
    $CompanyInfoFilterComposer,
    $CompanyInfoOrderingComposer,
    $CompanyInfoAnnotationComposer,
    $CompanyInfoCreateCompanionBuilder,
    $CompanyInfoUpdateCompanionBuilder,
    (CompanyInfoData, $CompanyInfoReferences),
    CompanyInfoData,
    PrefetchHooks Function({bool branchesRefs})>;
typedef $BranchGroupsCreateCompanionBuilder = BranchGroupsCompanion Function({
  Value<int> id,
  required String nameAr,
  required String nameEn,
  Value<bool> isActive,
});
typedef $BranchGroupsUpdateCompanionBuilder = BranchGroupsCompanion Function({
  Value<int> id,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<bool> isActive,
});

final class $BranchGroupsReferences
    extends BaseReferences<_$AppDatabase, BranchGroups, BranchGroup> {
  $BranchGroupsReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<Branches, List<Branche>> _branchesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.branches,
          aliasName: $_aliasNameGenerator(
              db.branchGroups.id, db.branches.branchGroupId));

  $BranchesProcessedTableManager get branchesRefs {
    final manager = $BranchesTableManager($_db, $_db.branches)
        .filter((f) => f.branchGroupId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_branchesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $BranchGroupsFilterComposer
    extends Composer<_$AppDatabase, BranchGroups> {
  $BranchGroupsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  Expression<bool> branchesRefs(
      Expression<bool> Function($BranchesFilterComposer f) f) {
    final $BranchesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.branchGroupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesFilterComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $BranchGroupsOrderingComposer
    extends Composer<_$AppDatabase, BranchGroups> {
  $BranchGroupsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));
}

class $BranchGroupsAnnotationComposer
    extends Composer<_$AppDatabase, BranchGroups> {
  $BranchGroupsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> branchesRefs<T extends Object>(
      Expression<T> Function($BranchesAnnotationComposer a) f) {
    final $BranchesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.branchGroupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesAnnotationComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $BranchGroupsTableManager extends RootTableManager<
    _$AppDatabase,
    BranchGroups,
    BranchGroup,
    $BranchGroupsFilterComposer,
    $BranchGroupsOrderingComposer,
    $BranchGroupsAnnotationComposer,
    $BranchGroupsCreateCompanionBuilder,
    $BranchGroupsUpdateCompanionBuilder,
    (BranchGroup, $BranchGroupsReferences),
    BranchGroup,
    PrefetchHooks Function({bool branchesRefs})> {
  $BranchGroupsTableManager(_$AppDatabase db, BranchGroups table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $BranchGroupsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $BranchGroupsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $BranchGroupsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              BranchGroupsCompanion(
            id: id,
            nameAr: nameAr,
            nameEn: nameEn,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String nameAr,
            required String nameEn,
            Value<bool> isActive = const Value.absent(),
          }) =>
              BranchGroupsCompanion.insert(
            id: id,
            nameAr: nameAr,
            nameEn: nameEn,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $BranchGroupsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({branchesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (branchesRefs) db.branches],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (branchesRefs)
                    await $_getPrefetchedData<BranchGroup, BranchGroups,
                            Branche>(
                        currentTable: table,
                        referencedTable:
                            $BranchGroupsReferences._branchesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $BranchGroupsReferences(db, table, p0).branchesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.branchGroupId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $BranchGroupsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    BranchGroups,
    BranchGroup,
    $BranchGroupsFilterComposer,
    $BranchGroupsOrderingComposer,
    $BranchGroupsAnnotationComposer,
    $BranchGroupsCreateCompanionBuilder,
    $BranchGroupsUpdateCompanionBuilder,
    (BranchGroup, $BranchGroupsReferences),
    BranchGroup,
    PrefetchHooks Function({bool branchesRefs})>;
typedef $BranchesCreateCompanionBuilder = BranchesCompanion Function({
  Value<int> id,
  required String branchCode,
  required String nameAr,
  required String nameEn,
  required int companyId,
  Value<int?> branchGroupId,
  Value<String?> address,
  Value<String?> phone,
  Value<String?> defaultWarehouseId,
  Value<bool> isMainBranch,
  Value<bool> branchStatus,
  Value<Uint8List?> logo,
  Value<String?> remarks,
});
typedef $BranchesUpdateCompanionBuilder = BranchesCompanion Function({
  Value<int> id,
  Value<String> branchCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<int> companyId,
  Value<int?> branchGroupId,
  Value<String?> address,
  Value<String?> phone,
  Value<String?> defaultWarehouseId,
  Value<bool> isMainBranch,
  Value<bool> branchStatus,
  Value<Uint8List?> logo,
  Value<String?> remarks,
});

final class $BranchesReferences
    extends BaseReferences<_$AppDatabase, Branches, Branche> {
  $BranchesReferences(super.$_db, super.$_table, super.$_typedResult);

  static CompanyInfo _companyIdTable(_$AppDatabase db) =>
      db.companyInfo.createAlias(
          $_aliasNameGenerator(db.branches.companyId, db.companyInfo.id));

  $CompanyInfoProcessedTableManager get companyId {
    final $_column = $_itemColumn<int>('company_id')!;

    final manager = $CompanyInfoTableManager($_db, $_db.companyInfo)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_companyIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static BranchGroups _branchGroupIdTable(_$AppDatabase db) =>
      db.branchGroups.createAlias(
          $_aliasNameGenerator(db.branches.branchGroupId, db.branchGroups.id));

  $BranchGroupsProcessedTableManager? get branchGroupId {
    final $_column = $_itemColumn<int>('branch_group_id');
    if ($_column == null) return null;
    final manager = $BranchGroupsTableManager($_db, $_db.branchGroups)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchGroupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<Warehouses, List<Warehouse>> _warehousesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.warehouses,
          aliasName:
              $_aliasNameGenerator(db.branches.id, db.warehouses.branchId));

  $WarehousesProcessedTableManager get warehousesRefs {
    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.branchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_warehousesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<Users, List<User>> _usersRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.users,
          aliasName: $_aliasNameGenerator(db.branches.id, db.users.branchId));

  $UsersProcessedTableManager get usersRefs {
    final manager = $UsersTableManager($_db, $_db.users)
        .filter((f) => f.branchId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_usersRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $BranchesFilterComposer extends Composer<_$AppDatabase, Branches> {
  $BranchesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get branchCode => $composableBuilder(
      column: $table.branchCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get defaultWarehouseId => $composableBuilder(
      column: $table.defaultWarehouseId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isMainBranch => $composableBuilder(
      column: $table.isMainBranch, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get branchStatus => $composableBuilder(
      column: $table.branchStatus, builder: (column) => ColumnFilters(column));

  ColumnFilters<Uint8List> get logo => $composableBuilder(
      column: $table.logo, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remarks => $composableBuilder(
      column: $table.remarks, builder: (column) => ColumnFilters(column));

  $CompanyInfoFilterComposer get companyId {
    final $CompanyInfoFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.companyId,
        referencedTable: $db.companyInfo,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CompanyInfoFilterComposer(
              $db: $db,
              $table: $db.companyInfo,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $BranchGroupsFilterComposer get branchGroupId {
    final $BranchGroupsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchGroupId,
        referencedTable: $db.branchGroups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchGroupsFilterComposer(
              $db: $db,
              $table: $db.branchGroups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> warehousesRefs(
      Expression<bool> Function($WarehousesFilterComposer f) f) {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.branchId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> usersRefs(
      Expression<bool> Function($UsersFilterComposer f) f) {
    final $UsersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.branchId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersFilterComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $BranchesOrderingComposer extends Composer<_$AppDatabase, Branches> {
  $BranchesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get branchCode => $composableBuilder(
      column: $table.branchCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get address => $composableBuilder(
      column: $table.address, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get phone => $composableBuilder(
      column: $table.phone, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get defaultWarehouseId => $composableBuilder(
      column: $table.defaultWarehouseId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isMainBranch => $composableBuilder(
      column: $table.isMainBranch,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get branchStatus => $composableBuilder(
      column: $table.branchStatus,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<Uint8List> get logo => $composableBuilder(
      column: $table.logo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remarks => $composableBuilder(
      column: $table.remarks, builder: (column) => ColumnOrderings(column));

  $CompanyInfoOrderingComposer get companyId {
    final $CompanyInfoOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.companyId,
        referencedTable: $db.companyInfo,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CompanyInfoOrderingComposer(
              $db: $db,
              $table: $db.companyInfo,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $BranchGroupsOrderingComposer get branchGroupId {
    final $BranchGroupsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchGroupId,
        referencedTable: $db.branchGroups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchGroupsOrderingComposer(
              $db: $db,
              $table: $db.branchGroups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $BranchesAnnotationComposer extends Composer<_$AppDatabase, Branches> {
  $BranchesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get branchCode => $composableBuilder(
      column: $table.branchCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get defaultWarehouseId => $composableBuilder(
      column: $table.defaultWarehouseId, builder: (column) => column);

  GeneratedColumn<bool> get isMainBranch => $composableBuilder(
      column: $table.isMainBranch, builder: (column) => column);

  GeneratedColumn<bool> get branchStatus => $composableBuilder(
      column: $table.branchStatus, builder: (column) => column);

  GeneratedColumn<Uint8List> get logo =>
      $composableBuilder(column: $table.logo, builder: (column) => column);

  GeneratedColumn<String> get remarks =>
      $composableBuilder(column: $table.remarks, builder: (column) => column);

  $CompanyInfoAnnotationComposer get companyId {
    final $CompanyInfoAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.companyId,
        referencedTable: $db.companyInfo,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CompanyInfoAnnotationComposer(
              $db: $db,
              $table: $db.companyInfo,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $BranchGroupsAnnotationComposer get branchGroupId {
    final $BranchGroupsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchGroupId,
        referencedTable: $db.branchGroups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchGroupsAnnotationComposer(
              $db: $db,
              $table: $db.branchGroups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> warehousesRefs<T extends Object>(
      Expression<T> Function($WarehousesAnnotationComposer a) f) {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.branchId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> usersRefs<T extends Object>(
      Expression<T> Function($UsersAnnotationComposer a) f) {
    final $UsersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.branchId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersAnnotationComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $BranchesTableManager extends RootTableManager<
    _$AppDatabase,
    Branches,
    Branche,
    $BranchesFilterComposer,
    $BranchesOrderingComposer,
    $BranchesAnnotationComposer,
    $BranchesCreateCompanionBuilder,
    $BranchesUpdateCompanionBuilder,
    (Branche, $BranchesReferences),
    Branche,
    PrefetchHooks Function(
        {bool companyId,
        bool branchGroupId,
        bool warehousesRefs,
        bool usersRefs})> {
  $BranchesTableManager(_$AppDatabase db, Branches table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $BranchesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $BranchesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $BranchesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> branchCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<int> companyId = const Value.absent(),
            Value<int?> branchGroupId = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> defaultWarehouseId = const Value.absent(),
            Value<bool> isMainBranch = const Value.absent(),
            Value<bool> branchStatus = const Value.absent(),
            Value<Uint8List?> logo = const Value.absent(),
            Value<String?> remarks = const Value.absent(),
          }) =>
              BranchesCompanion(
            id: id,
            branchCode: branchCode,
            nameAr: nameAr,
            nameEn: nameEn,
            companyId: companyId,
            branchGroupId: branchGroupId,
            address: address,
            phone: phone,
            defaultWarehouseId: defaultWarehouseId,
            isMainBranch: isMainBranch,
            branchStatus: branchStatus,
            logo: logo,
            remarks: remarks,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String branchCode,
            required String nameAr,
            required String nameEn,
            required int companyId,
            Value<int?> branchGroupId = const Value.absent(),
            Value<String?> address = const Value.absent(),
            Value<String?> phone = const Value.absent(),
            Value<String?> defaultWarehouseId = const Value.absent(),
            Value<bool> isMainBranch = const Value.absent(),
            Value<bool> branchStatus = const Value.absent(),
            Value<Uint8List?> logo = const Value.absent(),
            Value<String?> remarks = const Value.absent(),
          }) =>
              BranchesCompanion.insert(
            id: id,
            branchCode: branchCode,
            nameAr: nameAr,
            nameEn: nameEn,
            companyId: companyId,
            branchGroupId: branchGroupId,
            address: address,
            phone: phone,
            defaultWarehouseId: defaultWarehouseId,
            isMainBranch: isMainBranch,
            branchStatus: branchStatus,
            logo: logo,
            remarks: remarks,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $BranchesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {companyId = false,
              branchGroupId = false,
              warehousesRefs = false,
              usersRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (warehousesRefs) db.warehouses,
                if (usersRefs) db.users
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (companyId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.companyId,
                    referencedTable: $BranchesReferences._companyIdTable(db),
                    referencedColumn:
                        $BranchesReferences._companyIdTable(db).id,
                  ) as T;
                }
                if (branchGroupId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.branchGroupId,
                    referencedTable:
                        $BranchesReferences._branchGroupIdTable(db),
                    referencedColumn:
                        $BranchesReferences._branchGroupIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (warehousesRefs)
                    await $_getPrefetchedData<Branche, Branches, Warehouse>(
                        currentTable: table,
                        referencedTable:
                            $BranchesReferences._warehousesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $BranchesReferences(db, table, p0).warehousesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.branchId == item.id),
                        typedResults: items),
                  if (usersRefs)
                    await $_getPrefetchedData<Branche, Branches, User>(
                        currentTable: table,
                        referencedTable:
                            $BranchesReferences._usersRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $BranchesReferences(db, table, p0).usersRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.branchId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $BranchesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Branches,
    Branche,
    $BranchesFilterComposer,
    $BranchesOrderingComposer,
    $BranchesAnnotationComposer,
    $BranchesCreateCompanionBuilder,
    $BranchesUpdateCompanionBuilder,
    (Branche, $BranchesReferences),
    Branche,
    PrefetchHooks Function(
        {bool companyId,
        bool branchGroupId,
        bool warehousesRefs,
        bool usersRefs})>;
typedef $WarehousesCreateCompanionBuilder = WarehousesCompanion Function({
  Value<int> id,
  required String warehouseCode,
  required String nameAr,
  required String nameEn,
  required int branchId,
  required String inventoryAccountId,
  Value<bool> isActive,
  required int createdAt,
  required int updatedAt,
});
typedef $WarehousesUpdateCompanionBuilder = WarehousesCompanion Function({
  Value<int> id,
  Value<String> warehouseCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<int> branchId,
  Value<String> inventoryAccountId,
  Value<bool> isActive,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $WarehousesReferences
    extends BaseReferences<_$AppDatabase, Warehouses, Warehouse> {
  $WarehousesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Branches _branchIdTable(_$AppDatabase db) => db.branches.createAlias(
      $_aliasNameGenerator(db.warehouses.branchId, db.branches.id));

  $BranchesProcessedTableManager get branchId {
    final $_column = $_itemColumn<int>('branch_id')!;

    final manager = $BranchesTableManager($_db, $_db.branches)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<StockBalances, List<StockBalance>>
      _stockBalancesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stockBalances,
              aliasName: $_aliasNameGenerator(
                  db.warehouses.id, db.stockBalances.warehouseId));

  $StockBalancesProcessedTableManager get stockBalancesRefs {
    final manager = $StockBalancesTableManager($_db, $_db.stockBalances)
        .filter((f) => f.warehouseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_stockBalancesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StockTransactions, List<StockTransaction>>
      _stockTransactionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stockTransactions,
              aliasName: $_aliasNameGenerator(
                  db.warehouses.id, db.stockTransactions.warehouseId));

  $StockTransactionsProcessedTableManager get stockTransactionsRefs {
    final manager = $StockTransactionsTableManager($_db, $_db.stockTransactions)
        .filter((f) => f.warehouseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stockTransactionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<IncomingStockOrders, List<IncomingStockOrder>>
      _incomingStockOrdersRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.incomingStockOrders,
              aliasName: $_aliasNameGenerator(
                  db.warehouses.id, db.incomingStockOrders.warehouseId));

  $IncomingStockOrdersProcessedTableManager get incomingStockOrdersRefs {
    final manager = $IncomingStockOrdersTableManager(
            $_db, $_db.incomingStockOrders)
        .filter((f) => f.warehouseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_incomingStockOrdersRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<OutgoingStockOrders, List<OutgoingStockOrder>>
      _outgoingStockOrdersRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.outgoingStockOrders,
              aliasName: $_aliasNameGenerator(
                  db.warehouses.id, db.outgoingStockOrders.warehouseId));

  $OutgoingStockOrdersProcessedTableManager get outgoingStockOrdersRefs {
    final manager = $OutgoingStockOrdersTableManager(
            $_db, $_db.outgoingStockOrders)
        .filter((f) => f.warehouseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_outgoingStockOrdersRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StocktakingSessions, List<StocktakingSession>>
      _stocktakingSessionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stocktakingSessions,
              aliasName: $_aliasNameGenerator(
                  db.warehouses.id, db.stocktakingSessions.warehouseId));

  $StocktakingSessionsProcessedTableManager get stocktakingSessionsRefs {
    final manager = $StocktakingSessionsTableManager(
            $_db, $_db.stocktakingSessions)
        .filter((f) => f.warehouseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stocktakingSessionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StockReservations, List<StockReservation>>
      _stockReservationsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stockReservations,
              aliasName: $_aliasNameGenerator(
                  db.warehouses.id, db.stockReservations.warehouseId));

  $StockReservationsProcessedTableManager get stockReservationsRefs {
    final manager = $StockReservationsTableManager($_db, $_db.stockReservations)
        .filter((f) => f.warehouseId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stockReservationsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $WarehousesFilterComposer extends Composer<_$AppDatabase, Warehouses> {
  $WarehousesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get warehouseCode => $composableBuilder(
      column: $table.warehouseCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $BranchesFilterComposer get branchId {
    final $BranchesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchId,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesFilterComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> stockBalancesRefs(
      Expression<bool> Function($StockBalancesFilterComposer f) f) {
    final $StockBalancesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockBalances,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockBalancesFilterComposer(
              $db: $db,
              $table: $db.stockBalances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stockTransactionsRefs(
      Expression<bool> Function($StockTransactionsFilterComposer f) f) {
    final $StockTransactionsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockTransactions,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockTransactionsFilterComposer(
              $db: $db,
              $table: $db.stockTransactions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> incomingStockOrdersRefs(
      Expression<bool> Function($IncomingStockOrdersFilterComposer f) f) {
    final $IncomingStockOrdersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.incomingStockOrders,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrdersFilterComposer(
              $db: $db,
              $table: $db.incomingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> outgoingStockOrdersRefs(
      Expression<bool> Function($OutgoingStockOrdersFilterComposer f) f) {
    final $OutgoingStockOrdersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.outgoingStockOrders,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrdersFilterComposer(
              $db: $db,
              $table: $db.outgoingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stocktakingSessionsRefs(
      Expression<bool> Function($StocktakingSessionsFilterComposer f) f) {
    final $StocktakingSessionsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stocktakingSessions,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingSessionsFilterComposer(
              $db: $db,
              $table: $db.stocktakingSessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stockReservationsRefs(
      Expression<bool> Function($StockReservationsFilterComposer f) f) {
    final $StockReservationsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockReservations,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockReservationsFilterComposer(
              $db: $db,
              $table: $db.stockReservations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $WarehousesOrderingComposer extends Composer<_$AppDatabase, Warehouses> {
  $WarehousesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get warehouseCode => $composableBuilder(
      column: $table.warehouseCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $BranchesOrderingComposer get branchId {
    final $BranchesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchId,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesOrderingComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $WarehousesAnnotationComposer
    extends Composer<_$AppDatabase, Warehouses> {
  $WarehousesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get warehouseCode => $composableBuilder(
      column: $table.warehouseCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $BranchesAnnotationComposer get branchId {
    final $BranchesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchId,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesAnnotationComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> stockBalancesRefs<T extends Object>(
      Expression<T> Function($StockBalancesAnnotationComposer a) f) {
    final $StockBalancesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockBalances,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockBalancesAnnotationComposer(
              $db: $db,
              $table: $db.stockBalances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stockTransactionsRefs<T extends Object>(
      Expression<T> Function($StockTransactionsAnnotationComposer a) f) {
    final $StockTransactionsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockTransactions,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockTransactionsAnnotationComposer(
              $db: $db,
              $table: $db.stockTransactions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> incomingStockOrdersRefs<T extends Object>(
      Expression<T> Function($IncomingStockOrdersAnnotationComposer a) f) {
    final $IncomingStockOrdersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.incomingStockOrders,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrdersAnnotationComposer(
              $db: $db,
              $table: $db.incomingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> outgoingStockOrdersRefs<T extends Object>(
      Expression<T> Function($OutgoingStockOrdersAnnotationComposer a) f) {
    final $OutgoingStockOrdersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.outgoingStockOrders,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrdersAnnotationComposer(
              $db: $db,
              $table: $db.outgoingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stocktakingSessionsRefs<T extends Object>(
      Expression<T> Function($StocktakingSessionsAnnotationComposer a) f) {
    final $StocktakingSessionsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stocktakingSessions,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingSessionsAnnotationComposer(
              $db: $db,
              $table: $db.stocktakingSessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stockReservationsRefs<T extends Object>(
      Expression<T> Function($StockReservationsAnnotationComposer a) f) {
    final $StockReservationsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockReservations,
        getReferencedColumn: (t) => t.warehouseId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockReservationsAnnotationComposer(
              $db: $db,
              $table: $db.stockReservations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $WarehousesTableManager extends RootTableManager<
    _$AppDatabase,
    Warehouses,
    Warehouse,
    $WarehousesFilterComposer,
    $WarehousesOrderingComposer,
    $WarehousesAnnotationComposer,
    $WarehousesCreateCompanionBuilder,
    $WarehousesUpdateCompanionBuilder,
    (Warehouse, $WarehousesReferences),
    Warehouse,
    PrefetchHooks Function(
        {bool branchId,
        bool stockBalancesRefs,
        bool stockTransactionsRefs,
        bool incomingStockOrdersRefs,
        bool outgoingStockOrdersRefs,
        bool stocktakingSessionsRefs,
        bool stockReservationsRefs})> {
  $WarehousesTableManager(_$AppDatabase db, Warehouses table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $WarehousesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $WarehousesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $WarehousesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> warehouseCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<int> branchId = const Value.absent(),
            Value<String> inventoryAccountId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              WarehousesCompanion(
            id: id,
            warehouseCode: warehouseCode,
            nameAr: nameAr,
            nameEn: nameEn,
            branchId: branchId,
            inventoryAccountId: inventoryAccountId,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String warehouseCode,
            required String nameAr,
            required String nameEn,
            required int branchId,
            required String inventoryAccountId,
            Value<bool> isActive = const Value.absent(),
            required int createdAt,
            required int updatedAt,
          }) =>
              WarehousesCompanion.insert(
            id: id,
            warehouseCode: warehouseCode,
            nameAr: nameAr,
            nameEn: nameEn,
            branchId: branchId,
            inventoryAccountId: inventoryAccountId,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $WarehousesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {branchId = false,
              stockBalancesRefs = false,
              stockTransactionsRefs = false,
              incomingStockOrdersRefs = false,
              outgoingStockOrdersRefs = false,
              stocktakingSessionsRefs = false,
              stockReservationsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (stockBalancesRefs) db.stockBalances,
                if (stockTransactionsRefs) db.stockTransactions,
                if (incomingStockOrdersRefs) db.incomingStockOrders,
                if (outgoingStockOrdersRefs) db.outgoingStockOrders,
                if (stocktakingSessionsRefs) db.stocktakingSessions,
                if (stockReservationsRefs) db.stockReservations
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (branchId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.branchId,
                    referencedTable: $WarehousesReferences._branchIdTable(db),
                    referencedColumn:
                        $WarehousesReferences._branchIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (stockBalancesRefs)
                    await $_getPrefetchedData<Warehouse, Warehouses,
                            StockBalance>(
                        currentTable: table,
                        referencedTable:
                            $WarehousesReferences._stockBalancesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehousesReferences(db, table, p0)
                                .stockBalancesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.warehouseId == item.id),
                        typedResults: items),
                  if (stockTransactionsRefs)
                    await $_getPrefetchedData<Warehouse, Warehouses,
                            StockTransaction>(
                        currentTable: table,
                        referencedTable: $WarehousesReferences
                            ._stockTransactionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehousesReferences(db, table, p0)
                                .stockTransactionsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.warehouseId == item.id),
                        typedResults: items),
                  if (incomingStockOrdersRefs)
                    await $_getPrefetchedData<Warehouse, Warehouses,
                            IncomingStockOrder>(
                        currentTable: table,
                        referencedTable: $WarehousesReferences
                            ._incomingStockOrdersRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehousesReferences(db, table, p0)
                                .incomingStockOrdersRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.warehouseId == item.id),
                        typedResults: items),
                  if (outgoingStockOrdersRefs)
                    await $_getPrefetchedData<Warehouse, Warehouses,
                            OutgoingStockOrder>(
                        currentTable: table,
                        referencedTable: $WarehousesReferences
                            ._outgoingStockOrdersRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehousesReferences(db, table, p0)
                                .outgoingStockOrdersRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.warehouseId == item.id),
                        typedResults: items),
                  if (stocktakingSessionsRefs)
                    await $_getPrefetchedData<Warehouse, Warehouses,
                            StocktakingSession>(
                        currentTable: table,
                        referencedTable: $WarehousesReferences
                            ._stocktakingSessionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehousesReferences(db, table, p0)
                                .stocktakingSessionsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.warehouseId == item.id),
                        typedResults: items),
                  if (stockReservationsRefs)
                    await $_getPrefetchedData<Warehouse, Warehouses,
                            StockReservation>(
                        currentTable: table,
                        referencedTable: $WarehousesReferences
                            ._stockReservationsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehousesReferences(db, table, p0)
                                .stockReservationsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.warehouseId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $WarehousesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Warehouses,
    Warehouse,
    $WarehousesFilterComposer,
    $WarehousesOrderingComposer,
    $WarehousesAnnotationComposer,
    $WarehousesCreateCompanionBuilder,
    $WarehousesUpdateCompanionBuilder,
    (Warehouse, $WarehousesReferences),
    Warehouse,
    PrefetchHooks Function(
        {bool branchId,
        bool stockBalancesRefs,
        bool stockTransactionsRefs,
        bool incomingStockOrdersRefs,
        bool outgoingStockOrdersRefs,
        bool stocktakingSessionsRefs,
        bool stockReservationsRefs})>;
typedef $ItemGroupsCreateCompanionBuilder = ItemGroupsCompanion Function({
  Value<int> id,
  required String groupCode,
  required String nameAr,
  required String nameEn,
  Value<int?> parentGroupId,
  required String inventoryAccountId,
  required String salesRevenueAccountId,
  required String cogsAccountId,
  Value<bool> isActive,
  required int createdAt,
  required int updatedAt,
});
typedef $ItemGroupsUpdateCompanionBuilder = ItemGroupsCompanion Function({
  Value<int> id,
  Value<String> groupCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<int?> parentGroupId,
  Value<String> inventoryAccountId,
  Value<String> salesRevenueAccountId,
  Value<String> cogsAccountId,
  Value<bool> isActive,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $ItemGroupsReferences
    extends BaseReferences<_$AppDatabase, ItemGroups, ItemGroup> {
  $ItemGroupsReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<Items, List<Item>> _itemsRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.items,
          aliasName:
              $_aliasNameGenerator(db.itemGroups.id, db.items.itemGroupId));

  $ItemsProcessedTableManager get itemsRefs {
    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.itemGroupId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_itemsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $ItemGroupsFilterComposer extends Composer<_$AppDatabase, ItemGroups> {
  $ItemGroupsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get groupCode => $composableBuilder(
      column: $table.groupCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get parentGroupId => $composableBuilder(
      column: $table.parentGroupId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get salesRevenueAccountId => $composableBuilder(
      column: $table.salesRevenueAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cogsAccountId => $composableBuilder(
      column: $table.cogsAccountId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  Expression<bool> itemsRefs(
      Expression<bool> Function($ItemsFilterComposer f) f) {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.itemGroupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ItemGroupsOrderingComposer extends Composer<_$AppDatabase, ItemGroups> {
  $ItemGroupsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get groupCode => $composableBuilder(
      column: $table.groupCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get parentGroupId => $composableBuilder(
      column: $table.parentGroupId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get salesRevenueAccountId => $composableBuilder(
      column: $table.salesRevenueAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cogsAccountId => $composableBuilder(
      column: $table.cogsAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $ItemGroupsAnnotationComposer
    extends Composer<_$AppDatabase, ItemGroups> {
  $ItemGroupsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get groupCode =>
      $composableBuilder(column: $table.groupCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<int> get parentGroupId => $composableBuilder(
      column: $table.parentGroupId, builder: (column) => column);

  GeneratedColumn<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId, builder: (column) => column);

  GeneratedColumn<String> get salesRevenueAccountId => $composableBuilder(
      column: $table.salesRevenueAccountId, builder: (column) => column);

  GeneratedColumn<String> get cogsAccountId => $composableBuilder(
      column: $table.cogsAccountId, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> itemsRefs<T extends Object>(
      Expression<T> Function($ItemsAnnotationComposer a) f) {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.itemGroupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ItemGroupsTableManager extends RootTableManager<
    _$AppDatabase,
    ItemGroups,
    ItemGroup,
    $ItemGroupsFilterComposer,
    $ItemGroupsOrderingComposer,
    $ItemGroupsAnnotationComposer,
    $ItemGroupsCreateCompanionBuilder,
    $ItemGroupsUpdateCompanionBuilder,
    (ItemGroup, $ItemGroupsReferences),
    ItemGroup,
    PrefetchHooks Function({bool itemsRefs})> {
  $ItemGroupsTableManager(_$AppDatabase db, ItemGroups table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ItemGroupsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ItemGroupsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ItemGroupsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> groupCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<int?> parentGroupId = const Value.absent(),
            Value<String> inventoryAccountId = const Value.absent(),
            Value<String> salesRevenueAccountId = const Value.absent(),
            Value<String> cogsAccountId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              ItemGroupsCompanion(
            id: id,
            groupCode: groupCode,
            nameAr: nameAr,
            nameEn: nameEn,
            parentGroupId: parentGroupId,
            inventoryAccountId: inventoryAccountId,
            salesRevenueAccountId: salesRevenueAccountId,
            cogsAccountId: cogsAccountId,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String groupCode,
            required String nameAr,
            required String nameEn,
            Value<int?> parentGroupId = const Value.absent(),
            required String inventoryAccountId,
            required String salesRevenueAccountId,
            required String cogsAccountId,
            Value<bool> isActive = const Value.absent(),
            required int createdAt,
            required int updatedAt,
          }) =>
              ItemGroupsCompanion.insert(
            id: id,
            groupCode: groupCode,
            nameAr: nameAr,
            nameEn: nameEn,
            parentGroupId: parentGroupId,
            inventoryAccountId: inventoryAccountId,
            salesRevenueAccountId: salesRevenueAccountId,
            cogsAccountId: cogsAccountId,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $ItemGroupsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({itemsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (itemsRefs) db.items],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (itemsRefs)
                    await $_getPrefetchedData<ItemGroup, ItemGroups, Item>(
                        currentTable: table,
                        referencedTable:
                            $ItemGroupsReferences._itemsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemGroupsReferences(db, table, p0).itemsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.itemGroupId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $ItemGroupsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    ItemGroups,
    ItemGroup,
    $ItemGroupsFilterComposer,
    $ItemGroupsOrderingComposer,
    $ItemGroupsAnnotationComposer,
    $ItemGroupsCreateCompanionBuilder,
    $ItemGroupsUpdateCompanionBuilder,
    (ItemGroup, $ItemGroupsReferences),
    ItemGroup,
    PrefetchHooks Function({bool itemsRefs})>;
typedef $ItemsCreateCompanionBuilder = ItemsCompanion Function({
  Value<int> id,
  required String itemCode,
  required String nameAr,
  required String nameEn,
  Value<String?> barcode,
  Value<String?> description,
  required String itemType,
  required int itemGroupId,
  required String baseUnit,
  Value<String?> costingMethod,
  Value<double> costPrice,
  Value<double?> reorderLevel,
  Value<double?> maxStockLevel,
  Value<double?> minStockLevel,
  Value<bool> trackExpiryDate,
  Value<bool> trackBatchNumber,
  Value<String?> inventoryAccountId,
  Value<String?> salesRevenueAccountId,
  Value<String?> cogsAccountId,
  Value<String?> stockDiscrepancyAccountId,
  Value<bool> isActive,
  required int createdAt,
  required int updatedAt,
});
typedef $ItemsUpdateCompanionBuilder = ItemsCompanion Function({
  Value<int> id,
  Value<String> itemCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String?> barcode,
  Value<String?> description,
  Value<String> itemType,
  Value<int> itemGroupId,
  Value<String> baseUnit,
  Value<String?> costingMethod,
  Value<double> costPrice,
  Value<double?> reorderLevel,
  Value<double?> maxStockLevel,
  Value<double?> minStockLevel,
  Value<bool> trackExpiryDate,
  Value<bool> trackBatchNumber,
  Value<String?> inventoryAccountId,
  Value<String?> salesRevenueAccountId,
  Value<String?> cogsAccountId,
  Value<String?> stockDiscrepancyAccountId,
  Value<bool> isActive,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $ItemsReferences
    extends BaseReferences<_$AppDatabase, Items, Item> {
  $ItemsReferences(super.$_db, super.$_table, super.$_typedResult);

  static ItemGroups _itemGroupIdTable(_$AppDatabase db) =>
      db.itemGroups.createAlias(
          $_aliasNameGenerator(db.items.itemGroupId, db.itemGroups.id));

  $ItemGroupsProcessedTableManager get itemGroupId {
    final $_column = $_itemColumn<int>('item_group_id')!;

    final manager = $ItemGroupsTableManager($_db, $_db.itemGroups)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemGroupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<ItemSubUnits, List<ItemSubUnit>>
      _itemSubUnitsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.itemSubUnits,
          aliasName: $_aliasNameGenerator(db.items.id, db.itemSubUnits.itemId));

  $ItemSubUnitsProcessedTableManager get itemSubUnitsRefs {
    final manager = $ItemSubUnitsTableManager($_db, $_db.itemSubUnits)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_itemSubUnitsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<ItemSellingPrices, List<ItemSellingPrice>>
      _itemSellingPricesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.itemSellingPrices,
              aliasName: $_aliasNameGenerator(
                  db.items.id, db.itemSellingPrices.itemId));

  $ItemSellingPricesProcessedTableManager get itemSellingPricesRefs {
    final manager = $ItemSellingPricesTableManager($_db, $_db.itemSellingPrices)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_itemSellingPricesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<ItemAttachments, List<ItemAttachment>>
      _itemAttachmentsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.itemAttachments,
              aliasName:
                  $_aliasNameGenerator(db.items.id, db.itemAttachments.itemId));

  $ItemAttachmentsProcessedTableManager get itemAttachmentsRefs {
    final manager = $ItemAttachmentsTableManager($_db, $_db.itemAttachments)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_itemAttachmentsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StockBalances, List<StockBalance>>
      _stockBalancesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stockBalances,
              aliasName:
                  $_aliasNameGenerator(db.items.id, db.stockBalances.itemId));

  $StockBalancesProcessedTableManager get stockBalancesRefs {
    final manager = $StockBalancesTableManager($_db, $_db.stockBalances)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_stockBalancesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StockTransactions, List<StockTransaction>>
      _stockTransactionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stockTransactions,
              aliasName: $_aliasNameGenerator(
                  db.items.id, db.stockTransactions.itemId));

  $StockTransactionsProcessedTableManager get stockTransactionsRefs {
    final manager = $StockTransactionsTableManager($_db, $_db.stockTransactions)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stockTransactionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<IncomingStockOrderLines,
      List<IncomingStockOrderLine>> _incomingStockOrderLinesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.incomingStockOrderLines,
          aliasName: $_aliasNameGenerator(
              db.items.id, db.incomingStockOrderLines.itemId));

  $IncomingStockOrderLinesProcessedTableManager
      get incomingStockOrderLinesRefs {
    final manager =
        $IncomingStockOrderLinesTableManager($_db, $_db.incomingStockOrderLines)
            .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_incomingStockOrderLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<OutgoingStockOrderLines,
      List<OutgoingStockOrderLine>> _outgoingStockOrderLinesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.outgoingStockOrderLines,
          aliasName: $_aliasNameGenerator(
              db.items.id, db.outgoingStockOrderLines.itemId));

  $OutgoingStockOrderLinesProcessedTableManager
      get outgoingStockOrderLinesRefs {
    final manager =
        $OutgoingStockOrderLinesTableManager($_db, $_db.outgoingStockOrderLines)
            .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_outgoingStockOrderLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<WarehouseTransferLines,
      List<WarehouseTransferLine>> _warehouseTransferLinesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.warehouseTransferLines,
          aliasName: $_aliasNameGenerator(
              db.items.id, db.warehouseTransferLines.itemId));

  $WarehouseTransferLinesProcessedTableManager get warehouseTransferLinesRefs {
    final manager =
        $WarehouseTransferLinesTableManager($_db, $_db.warehouseTransferLines)
            .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_warehouseTransferLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StocktakingCounts, List<StocktakingCount>>
      _stocktakingCountsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stocktakingCounts,
              aliasName: $_aliasNameGenerator(
                  db.items.id, db.stocktakingCounts.itemId));

  $StocktakingCountsProcessedTableManager get stocktakingCountsRefs {
    final manager = $StocktakingCountsTableManager($_db, $_db.stocktakingCounts)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stocktakingCountsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<StockReservations, List<StockReservation>>
      _stockReservationsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stockReservations,
              aliasName: $_aliasNameGenerator(
                  db.items.id, db.stockReservations.itemId));

  $StockReservationsProcessedTableManager get stockReservationsRefs {
    final manager = $StockReservationsTableManager($_db, $_db.stockReservations)
        .filter((f) => f.itemId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stockReservationsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $ItemsFilterComposer extends Composer<_$AppDatabase, Items> {
  $ItemsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get itemCode => $composableBuilder(
      column: $table.itemCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get itemType => $composableBuilder(
      column: $table.itemType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get baseUnit => $composableBuilder(
      column: $table.baseUnit, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get costingMethod => $composableBuilder(
      column: $table.costingMethod, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get costPrice => $composableBuilder(
      column: $table.costPrice, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get reorderLevel => $composableBuilder(
      column: $table.reorderLevel, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get maxStockLevel => $composableBuilder(
      column: $table.maxStockLevel, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get minStockLevel => $composableBuilder(
      column: $table.minStockLevel, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get trackExpiryDate => $composableBuilder(
      column: $table.trackExpiryDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get trackBatchNumber => $composableBuilder(
      column: $table.trackBatchNumber,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get salesRevenueAccountId => $composableBuilder(
      column: $table.salesRevenueAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cogsAccountId => $composableBuilder(
      column: $table.cogsAccountId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get stockDiscrepancyAccountId => $composableBuilder(
      column: $table.stockDiscrepancyAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $ItemGroupsFilterComposer get itemGroupId {
    final $ItemGroupsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemGroupId,
        referencedTable: $db.itemGroups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemGroupsFilterComposer(
              $db: $db,
              $table: $db.itemGroups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> itemSubUnitsRefs(
      Expression<bool> Function($ItemSubUnitsFilterComposer f) f) {
    final $ItemSubUnitsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemSubUnits,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSubUnitsFilterComposer(
              $db: $db,
              $table: $db.itemSubUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> itemSellingPricesRefs(
      Expression<bool> Function($ItemSellingPricesFilterComposer f) f) {
    final $ItemSellingPricesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemSellingPrices,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSellingPricesFilterComposer(
              $db: $db,
              $table: $db.itemSellingPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> itemAttachmentsRefs(
      Expression<bool> Function($ItemAttachmentsFilterComposer f) f) {
    final $ItemAttachmentsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemAttachments,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemAttachmentsFilterComposer(
              $db: $db,
              $table: $db.itemAttachments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stockBalancesRefs(
      Expression<bool> Function($StockBalancesFilterComposer f) f) {
    final $StockBalancesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockBalances,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockBalancesFilterComposer(
              $db: $db,
              $table: $db.stockBalances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stockTransactionsRefs(
      Expression<bool> Function($StockTransactionsFilterComposer f) f) {
    final $StockTransactionsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockTransactions,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockTransactionsFilterComposer(
              $db: $db,
              $table: $db.stockTransactions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> incomingStockOrderLinesRefs(
      Expression<bool> Function($IncomingStockOrderLinesFilterComposer f) f) {
    final $IncomingStockOrderLinesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.incomingStockOrderLines,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrderLinesFilterComposer(
              $db: $db,
              $table: $db.incomingStockOrderLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> outgoingStockOrderLinesRefs(
      Expression<bool> Function($OutgoingStockOrderLinesFilterComposer f) f) {
    final $OutgoingStockOrderLinesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.outgoingStockOrderLines,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrderLinesFilterComposer(
              $db: $db,
              $table: $db.outgoingStockOrderLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> warehouseTransferLinesRefs(
      Expression<bool> Function($WarehouseTransferLinesFilterComposer f) f) {
    final $WarehouseTransferLinesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.warehouseTransferLines,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransferLinesFilterComposer(
              $db: $db,
              $table: $db.warehouseTransferLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stocktakingCountsRefs(
      Expression<bool> Function($StocktakingCountsFilterComposer f) f) {
    final $StocktakingCountsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stocktakingCounts,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingCountsFilterComposer(
              $db: $db,
              $table: $db.stocktakingCounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> stockReservationsRefs(
      Expression<bool> Function($StockReservationsFilterComposer f) f) {
    final $StockReservationsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockReservations,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockReservationsFilterComposer(
              $db: $db,
              $table: $db.stockReservations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ItemsOrderingComposer extends Composer<_$AppDatabase, Items> {
  $ItemsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get itemCode => $composableBuilder(
      column: $table.itemCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get itemType => $composableBuilder(
      column: $table.itemType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get baseUnit => $composableBuilder(
      column: $table.baseUnit, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get costingMethod => $composableBuilder(
      column: $table.costingMethod,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get costPrice => $composableBuilder(
      column: $table.costPrice, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get reorderLevel => $composableBuilder(
      column: $table.reorderLevel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get maxStockLevel => $composableBuilder(
      column: $table.maxStockLevel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get minStockLevel => $composableBuilder(
      column: $table.minStockLevel,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get trackExpiryDate => $composableBuilder(
      column: $table.trackExpiryDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get trackBatchNumber => $composableBuilder(
      column: $table.trackBatchNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get salesRevenueAccountId => $composableBuilder(
      column: $table.salesRevenueAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cogsAccountId => $composableBuilder(
      column: $table.cogsAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get stockDiscrepancyAccountId => $composableBuilder(
      column: $table.stockDiscrepancyAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $ItemGroupsOrderingComposer get itemGroupId {
    final $ItemGroupsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemGroupId,
        referencedTable: $db.itemGroups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemGroupsOrderingComposer(
              $db: $db,
              $table: $db.itemGroups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemsAnnotationComposer extends Composer<_$AppDatabase, Items> {
  $ItemsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get itemCode =>
      $composableBuilder(column: $table.itemCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<String> get itemType =>
      $composableBuilder(column: $table.itemType, builder: (column) => column);

  GeneratedColumn<String> get baseUnit =>
      $composableBuilder(column: $table.baseUnit, builder: (column) => column);

  GeneratedColumn<String> get costingMethod => $composableBuilder(
      column: $table.costingMethod, builder: (column) => column);

  GeneratedColumn<double> get costPrice =>
      $composableBuilder(column: $table.costPrice, builder: (column) => column);

  GeneratedColumn<double> get reorderLevel => $composableBuilder(
      column: $table.reorderLevel, builder: (column) => column);

  GeneratedColumn<double> get maxStockLevel => $composableBuilder(
      column: $table.maxStockLevel, builder: (column) => column);

  GeneratedColumn<double> get minStockLevel => $composableBuilder(
      column: $table.minStockLevel, builder: (column) => column);

  GeneratedColumn<bool> get trackExpiryDate => $composableBuilder(
      column: $table.trackExpiryDate, builder: (column) => column);

  GeneratedColumn<bool> get trackBatchNumber => $composableBuilder(
      column: $table.trackBatchNumber, builder: (column) => column);

  GeneratedColumn<String> get inventoryAccountId => $composableBuilder(
      column: $table.inventoryAccountId, builder: (column) => column);

  GeneratedColumn<String> get salesRevenueAccountId => $composableBuilder(
      column: $table.salesRevenueAccountId, builder: (column) => column);

  GeneratedColumn<String> get cogsAccountId => $composableBuilder(
      column: $table.cogsAccountId, builder: (column) => column);

  GeneratedColumn<String> get stockDiscrepancyAccountId => $composableBuilder(
      column: $table.stockDiscrepancyAccountId, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $ItemGroupsAnnotationComposer get itemGroupId {
    final $ItemGroupsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemGroupId,
        referencedTable: $db.itemGroups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemGroupsAnnotationComposer(
              $db: $db,
              $table: $db.itemGroups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> itemSubUnitsRefs<T extends Object>(
      Expression<T> Function($ItemSubUnitsAnnotationComposer a) f) {
    final $ItemSubUnitsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemSubUnits,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSubUnitsAnnotationComposer(
              $db: $db,
              $table: $db.itemSubUnits,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> itemSellingPricesRefs<T extends Object>(
      Expression<T> Function($ItemSellingPricesAnnotationComposer a) f) {
    final $ItemSellingPricesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemSellingPrices,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSellingPricesAnnotationComposer(
              $db: $db,
              $table: $db.itemSellingPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> itemAttachmentsRefs<T extends Object>(
      Expression<T> Function($ItemAttachmentsAnnotationComposer a) f) {
    final $ItemAttachmentsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemAttachments,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemAttachmentsAnnotationComposer(
              $db: $db,
              $table: $db.itemAttachments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stockBalancesRefs<T extends Object>(
      Expression<T> Function($StockBalancesAnnotationComposer a) f) {
    final $StockBalancesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockBalances,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockBalancesAnnotationComposer(
              $db: $db,
              $table: $db.stockBalances,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stockTransactionsRefs<T extends Object>(
      Expression<T> Function($StockTransactionsAnnotationComposer a) f) {
    final $StockTransactionsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockTransactions,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockTransactionsAnnotationComposer(
              $db: $db,
              $table: $db.stockTransactions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> incomingStockOrderLinesRefs<T extends Object>(
      Expression<T> Function($IncomingStockOrderLinesAnnotationComposer a) f) {
    final $IncomingStockOrderLinesAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.incomingStockOrderLines,
            getReferencedColumn: (t) => t.itemId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $IncomingStockOrderLinesAnnotationComposer(
                  $db: $db,
                  $table: $db.incomingStockOrderLines,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> outgoingStockOrderLinesRefs<T extends Object>(
      Expression<T> Function($OutgoingStockOrderLinesAnnotationComposer a) f) {
    final $OutgoingStockOrderLinesAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.outgoingStockOrderLines,
            getReferencedColumn: (t) => t.itemId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $OutgoingStockOrderLinesAnnotationComposer(
                  $db: $db,
                  $table: $db.outgoingStockOrderLines,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> warehouseTransferLinesRefs<T extends Object>(
      Expression<T> Function($WarehouseTransferLinesAnnotationComposer a) f) {
    final $WarehouseTransferLinesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.warehouseTransferLines,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransferLinesAnnotationComposer(
              $db: $db,
              $table: $db.warehouseTransferLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stocktakingCountsRefs<T extends Object>(
      Expression<T> Function($StocktakingCountsAnnotationComposer a) f) {
    final $StocktakingCountsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stocktakingCounts,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingCountsAnnotationComposer(
              $db: $db,
              $table: $db.stocktakingCounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> stockReservationsRefs<T extends Object>(
      Expression<T> Function($StockReservationsAnnotationComposer a) f) {
    final $StockReservationsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stockReservations,
        getReferencedColumn: (t) => t.itemId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StockReservationsAnnotationComposer(
              $db: $db,
              $table: $db.stockReservations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ItemsTableManager extends RootTableManager<
    _$AppDatabase,
    Items,
    Item,
    $ItemsFilterComposer,
    $ItemsOrderingComposer,
    $ItemsAnnotationComposer,
    $ItemsCreateCompanionBuilder,
    $ItemsUpdateCompanionBuilder,
    (Item, $ItemsReferences),
    Item,
    PrefetchHooks Function(
        {bool itemGroupId,
        bool itemSubUnitsRefs,
        bool itemSellingPricesRefs,
        bool itemAttachmentsRefs,
        bool stockBalancesRefs,
        bool stockTransactionsRefs,
        bool incomingStockOrderLinesRefs,
        bool outgoingStockOrderLinesRefs,
        bool warehouseTransferLinesRefs,
        bool stocktakingCountsRefs,
        bool stockReservationsRefs})> {
  $ItemsTableManager(_$AppDatabase db, Items table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ItemsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ItemsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ItemsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> itemCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String?> barcode = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<String> itemType = const Value.absent(),
            Value<int> itemGroupId = const Value.absent(),
            Value<String> baseUnit = const Value.absent(),
            Value<String?> costingMethod = const Value.absent(),
            Value<double> costPrice = const Value.absent(),
            Value<double?> reorderLevel = const Value.absent(),
            Value<double?> maxStockLevel = const Value.absent(),
            Value<double?> minStockLevel = const Value.absent(),
            Value<bool> trackExpiryDate = const Value.absent(),
            Value<bool> trackBatchNumber = const Value.absent(),
            Value<String?> inventoryAccountId = const Value.absent(),
            Value<String?> salesRevenueAccountId = const Value.absent(),
            Value<String?> cogsAccountId = const Value.absent(),
            Value<String?> stockDiscrepancyAccountId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              ItemsCompanion(
            id: id,
            itemCode: itemCode,
            nameAr: nameAr,
            nameEn: nameEn,
            barcode: barcode,
            description: description,
            itemType: itemType,
            itemGroupId: itemGroupId,
            baseUnit: baseUnit,
            costingMethod: costingMethod,
            costPrice: costPrice,
            reorderLevel: reorderLevel,
            maxStockLevel: maxStockLevel,
            minStockLevel: minStockLevel,
            trackExpiryDate: trackExpiryDate,
            trackBatchNumber: trackBatchNumber,
            inventoryAccountId: inventoryAccountId,
            salesRevenueAccountId: salesRevenueAccountId,
            cogsAccountId: cogsAccountId,
            stockDiscrepancyAccountId: stockDiscrepancyAccountId,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String itemCode,
            required String nameAr,
            required String nameEn,
            Value<String?> barcode = const Value.absent(),
            Value<String?> description = const Value.absent(),
            required String itemType,
            required int itemGroupId,
            required String baseUnit,
            Value<String?> costingMethod = const Value.absent(),
            Value<double> costPrice = const Value.absent(),
            Value<double?> reorderLevel = const Value.absent(),
            Value<double?> maxStockLevel = const Value.absent(),
            Value<double?> minStockLevel = const Value.absent(),
            Value<bool> trackExpiryDate = const Value.absent(),
            Value<bool> trackBatchNumber = const Value.absent(),
            Value<String?> inventoryAccountId = const Value.absent(),
            Value<String?> salesRevenueAccountId = const Value.absent(),
            Value<String?> cogsAccountId = const Value.absent(),
            Value<String?> stockDiscrepancyAccountId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            required int createdAt,
            required int updatedAt,
          }) =>
              ItemsCompanion.insert(
            id: id,
            itemCode: itemCode,
            nameAr: nameAr,
            nameEn: nameEn,
            barcode: barcode,
            description: description,
            itemType: itemType,
            itemGroupId: itemGroupId,
            baseUnit: baseUnit,
            costingMethod: costingMethod,
            costPrice: costPrice,
            reorderLevel: reorderLevel,
            maxStockLevel: maxStockLevel,
            minStockLevel: minStockLevel,
            trackExpiryDate: trackExpiryDate,
            trackBatchNumber: trackBatchNumber,
            inventoryAccountId: inventoryAccountId,
            salesRevenueAccountId: salesRevenueAccountId,
            cogsAccountId: cogsAccountId,
            stockDiscrepancyAccountId: stockDiscrepancyAccountId,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), $ItemsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {itemGroupId = false,
              itemSubUnitsRefs = false,
              itemSellingPricesRefs = false,
              itemAttachmentsRefs = false,
              stockBalancesRefs = false,
              stockTransactionsRefs = false,
              incomingStockOrderLinesRefs = false,
              outgoingStockOrderLinesRefs = false,
              warehouseTransferLinesRefs = false,
              stocktakingCountsRefs = false,
              stockReservationsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (itemSubUnitsRefs) db.itemSubUnits,
                if (itemSellingPricesRefs) db.itemSellingPrices,
                if (itemAttachmentsRefs) db.itemAttachments,
                if (stockBalancesRefs) db.stockBalances,
                if (stockTransactionsRefs) db.stockTransactions,
                if (incomingStockOrderLinesRefs) db.incomingStockOrderLines,
                if (outgoingStockOrderLinesRefs) db.outgoingStockOrderLines,
                if (warehouseTransferLinesRefs) db.warehouseTransferLines,
                if (stocktakingCountsRefs) db.stocktakingCounts,
                if (stockReservationsRefs) db.stockReservations
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemGroupId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemGroupId,
                    referencedTable: $ItemsReferences._itemGroupIdTable(db),
                    referencedColumn: $ItemsReferences._itemGroupIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (itemSubUnitsRefs)
                    await $_getPrefetchedData<Item, Items, ItemSubUnit>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._itemSubUnitsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0).itemSubUnitsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (itemSellingPricesRefs)
                    await $_getPrefetchedData<Item, Items, ItemSellingPrice>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._itemSellingPricesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .itemSellingPricesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (itemAttachmentsRefs)
                    await $_getPrefetchedData<Item, Items, ItemAttachment>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._itemAttachmentsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0).itemAttachmentsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (stockBalancesRefs)
                    await $_getPrefetchedData<Item, Items, StockBalance>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._stockBalancesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0).stockBalancesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (stockTransactionsRefs)
                    await $_getPrefetchedData<Item, Items, StockTransaction>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._stockTransactionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .stockTransactionsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (incomingStockOrderLinesRefs)
                    await $_getPrefetchedData<Item, Items,
                            IncomingStockOrderLine>(
                        currentTable: table,
                        referencedTable: $ItemsReferences
                            ._incomingStockOrderLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .incomingStockOrderLinesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (outgoingStockOrderLinesRefs)
                    await $_getPrefetchedData<Item, Items,
                            OutgoingStockOrderLine>(
                        currentTable: table,
                        referencedTable: $ItemsReferences
                            ._outgoingStockOrderLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .outgoingStockOrderLinesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (warehouseTransferLinesRefs)
                    await $_getPrefetchedData<Item, Items,
                            WarehouseTransferLine>(
                        currentTable: table,
                        referencedTable: $ItemsReferences
                            ._warehouseTransferLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .warehouseTransferLinesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (stocktakingCountsRefs)
                    await $_getPrefetchedData<Item, Items, StocktakingCount>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._stocktakingCountsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .stocktakingCountsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items),
                  if (stockReservationsRefs)
                    await $_getPrefetchedData<Item, Items, StockReservation>(
                        currentTable: table,
                        referencedTable:
                            $ItemsReferences._stockReservationsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemsReferences(db, table, p0)
                                .stockReservationsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.itemId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $ItemsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Items,
    Item,
    $ItemsFilterComposer,
    $ItemsOrderingComposer,
    $ItemsAnnotationComposer,
    $ItemsCreateCompanionBuilder,
    $ItemsUpdateCompanionBuilder,
    (Item, $ItemsReferences),
    Item,
    PrefetchHooks Function(
        {bool itemGroupId,
        bool itemSubUnitsRefs,
        bool itemSellingPricesRefs,
        bool itemAttachmentsRefs,
        bool stockBalancesRefs,
        bool stockTransactionsRefs,
        bool incomingStockOrderLinesRefs,
        bool outgoingStockOrderLinesRefs,
        bool warehouseTransferLinesRefs,
        bool stocktakingCountsRefs,
        bool stockReservationsRefs})>;
typedef $ItemSubUnitsCreateCompanionBuilder = ItemSubUnitsCompanion Function({
  Value<int> id,
  required int itemId,
  required String unitName,
  required double conversionFactor,
  required int createdAt,
});
typedef $ItemSubUnitsUpdateCompanionBuilder = ItemSubUnitsCompanion Function({
  Value<int> id,
  Value<int> itemId,
  Value<String> unitName,
  Value<double> conversionFactor,
  Value<int> createdAt,
});

final class $ItemSubUnitsReferences
    extends BaseReferences<_$AppDatabase, ItemSubUnits, ItemSubUnit> {
  $ItemSubUnitsReferences(super.$_db, super.$_table, super.$_typedResult);

  static Items _itemIdTable(_$AppDatabase db) => db.items
      .createAlias($_aliasNameGenerator(db.itemSubUnits.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $ItemSubUnitsFilterComposer
    extends Composer<_$AppDatabase, ItemSubUnits> {
  $ItemSubUnitsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get unitName => $composableBuilder(
      column: $table.unitName, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get conversionFactor => $composableBuilder(
      column: $table.conversionFactor,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemSubUnitsOrderingComposer
    extends Composer<_$AppDatabase, ItemSubUnits> {
  $ItemSubUnitsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get unitName => $composableBuilder(
      column: $table.unitName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get conversionFactor => $composableBuilder(
      column: $table.conversionFactor,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemSubUnitsAnnotationComposer
    extends Composer<_$AppDatabase, ItemSubUnits> {
  $ItemSubUnitsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get unitName =>
      $composableBuilder(column: $table.unitName, builder: (column) => column);

  GeneratedColumn<double> get conversionFactor => $composableBuilder(
      column: $table.conversionFactor, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemSubUnitsTableManager extends RootTableManager<
    _$AppDatabase,
    ItemSubUnits,
    ItemSubUnit,
    $ItemSubUnitsFilterComposer,
    $ItemSubUnitsOrderingComposer,
    $ItemSubUnitsAnnotationComposer,
    $ItemSubUnitsCreateCompanionBuilder,
    $ItemSubUnitsUpdateCompanionBuilder,
    (ItemSubUnit, $ItemSubUnitsReferences),
    ItemSubUnit,
    PrefetchHooks Function({bool itemId})> {
  $ItemSubUnitsTableManager(_$AppDatabase db, ItemSubUnits table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ItemSubUnitsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ItemSubUnitsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ItemSubUnitsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<String> unitName = const Value.absent(),
            Value<double> conversionFactor = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              ItemSubUnitsCompanion(
            id: id,
            itemId: itemId,
            unitName: unitName,
            conversionFactor: conversionFactor,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int itemId,
            required String unitName,
            required double conversionFactor,
            required int createdAt,
          }) =>
              ItemSubUnitsCompanion.insert(
            id: id,
            itemId: itemId,
            unitName: unitName,
            conversionFactor: conversionFactor,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $ItemSubUnitsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable: $ItemSubUnitsReferences._itemIdTable(db),
                    referencedColumn:
                        $ItemSubUnitsReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $ItemSubUnitsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    ItemSubUnits,
    ItemSubUnit,
    $ItemSubUnitsFilterComposer,
    $ItemSubUnitsOrderingComposer,
    $ItemSubUnitsAnnotationComposer,
    $ItemSubUnitsCreateCompanionBuilder,
    $ItemSubUnitsUpdateCompanionBuilder,
    (ItemSubUnit, $ItemSubUnitsReferences),
    ItemSubUnit,
    PrefetchHooks Function({bool itemId})>;
typedef $ItemSellingPricesCreateCompanionBuilder = ItemSellingPricesCompanion
    Function({
  Value<int> id,
  required int itemId,
  required String priceLevelName,
  required double price,
  required int createdAt,
  required int updatedAt,
});
typedef $ItemSellingPricesUpdateCompanionBuilder = ItemSellingPricesCompanion
    Function({
  Value<int> id,
  Value<int> itemId,
  Value<String> priceLevelName,
  Value<double> price,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $ItemSellingPricesReferences
    extends BaseReferences<_$AppDatabase, ItemSellingPrices, ItemSellingPrice> {
  $ItemSellingPricesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.itemSellingPrices.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<ItemPromotionalPrices, List<ItemPromotionalPrice>>
      _itemPromotionalPricesRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.itemPromotionalPrices,
              aliasName: $_aliasNameGenerator(db.itemSellingPrices.id,
                  db.itemPromotionalPrices.itemSellingPriceId));

  $ItemPromotionalPricesProcessedTableManager get itemPromotionalPricesRefs {
    final manager = $ItemPromotionalPricesTableManager(
            $_db, $_db.itemPromotionalPrices)
        .filter(
            (f) => f.itemSellingPriceId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_itemPromotionalPricesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $ItemSellingPricesFilterComposer
    extends Composer<_$AppDatabase, ItemSellingPrices> {
  $ItemSellingPricesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get priceLevelName => $composableBuilder(
      column: $table.priceLevelName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> itemPromotionalPricesRefs(
      Expression<bool> Function($ItemPromotionalPricesFilterComposer f) f) {
    final $ItemPromotionalPricesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemPromotionalPrices,
        getReferencedColumn: (t) => t.itemSellingPriceId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemPromotionalPricesFilterComposer(
              $db: $db,
              $table: $db.itemPromotionalPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ItemSellingPricesOrderingComposer
    extends Composer<_$AppDatabase, ItemSellingPrices> {
  $ItemSellingPricesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get priceLevelName => $composableBuilder(
      column: $table.priceLevelName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get price => $composableBuilder(
      column: $table.price, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemSellingPricesAnnotationComposer
    extends Composer<_$AppDatabase, ItemSellingPrices> {
  $ItemSellingPricesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get priceLevelName => $composableBuilder(
      column: $table.priceLevelName, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> itemPromotionalPricesRefs<T extends Object>(
      Expression<T> Function($ItemPromotionalPricesAnnotationComposer a) f) {
    final $ItemPromotionalPricesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.itemPromotionalPrices,
        getReferencedColumn: (t) => t.itemSellingPriceId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemPromotionalPricesAnnotationComposer(
              $db: $db,
              $table: $db.itemPromotionalPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ItemSellingPricesTableManager extends RootTableManager<
    _$AppDatabase,
    ItemSellingPrices,
    ItemSellingPrice,
    $ItemSellingPricesFilterComposer,
    $ItemSellingPricesOrderingComposer,
    $ItemSellingPricesAnnotationComposer,
    $ItemSellingPricesCreateCompanionBuilder,
    $ItemSellingPricesUpdateCompanionBuilder,
    (ItemSellingPrice, $ItemSellingPricesReferences),
    ItemSellingPrice,
    PrefetchHooks Function({bool itemId, bool itemPromotionalPricesRefs})> {
  $ItemSellingPricesTableManager(_$AppDatabase db, ItemSellingPrices table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ItemSellingPricesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ItemSellingPricesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ItemSellingPricesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<String> priceLevelName = const Value.absent(),
            Value<double> price = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              ItemSellingPricesCompanion(
            id: id,
            itemId: itemId,
            priceLevelName: priceLevelName,
            price: price,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int itemId,
            required String priceLevelName,
            required double price,
            required int createdAt,
            required int updatedAt,
          }) =>
              ItemSellingPricesCompanion.insert(
            id: id,
            itemId: itemId,
            priceLevelName: priceLevelName,
            price: price,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $ItemSellingPricesReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {itemId = false, itemPromotionalPricesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (itemPromotionalPricesRefs) db.itemPromotionalPrices
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $ItemSellingPricesReferences._itemIdTable(db),
                    referencedColumn:
                        $ItemSellingPricesReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (itemPromotionalPricesRefs)
                    await $_getPrefetchedData<ItemSellingPrice,
                            ItemSellingPrices, ItemPromotionalPrice>(
                        currentTable: table,
                        referencedTable: $ItemSellingPricesReferences
                            ._itemPromotionalPricesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ItemSellingPricesReferences(db, table, p0)
                                .itemPromotionalPricesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.itemSellingPriceId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $ItemSellingPricesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    ItemSellingPrices,
    ItemSellingPrice,
    $ItemSellingPricesFilterComposer,
    $ItemSellingPricesOrderingComposer,
    $ItemSellingPricesAnnotationComposer,
    $ItemSellingPricesCreateCompanionBuilder,
    $ItemSellingPricesUpdateCompanionBuilder,
    (ItemSellingPrice, $ItemSellingPricesReferences),
    ItemSellingPrice,
    PrefetchHooks Function({bool itemId, bool itemPromotionalPricesRefs})>;
typedef $ItemPromotionalPricesCreateCompanionBuilder
    = ItemPromotionalPricesCompanion Function({
  Value<int> id,
  required int itemSellingPriceId,
  required double promoPrice,
  required int startDate,
  required int endDate,
  required int createdAt,
});
typedef $ItemPromotionalPricesUpdateCompanionBuilder
    = ItemPromotionalPricesCompanion Function({
  Value<int> id,
  Value<int> itemSellingPriceId,
  Value<double> promoPrice,
  Value<int> startDate,
  Value<int> endDate,
  Value<int> createdAt,
});

final class $ItemPromotionalPricesReferences extends BaseReferences<
    _$AppDatabase, ItemPromotionalPrices, ItemPromotionalPrice> {
  $ItemPromotionalPricesReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static ItemSellingPrices _itemSellingPriceIdTable(_$AppDatabase db) =>
      db.itemSellingPrices.createAlias($_aliasNameGenerator(
          db.itemPromotionalPrices.itemSellingPriceId,
          db.itemSellingPrices.id));

  $ItemSellingPricesProcessedTableManager get itemSellingPriceId {
    final $_column = $_itemColumn<int>('item_selling_price_id')!;

    final manager = $ItemSellingPricesTableManager($_db, $_db.itemSellingPrices)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemSellingPriceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $ItemPromotionalPricesFilterComposer
    extends Composer<_$AppDatabase, ItemPromotionalPrices> {
  $ItemPromotionalPricesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get promoPrice => $composableBuilder(
      column: $table.promoPrice, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $ItemSellingPricesFilterComposer get itemSellingPriceId {
    final $ItemSellingPricesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemSellingPriceId,
        referencedTable: $db.itemSellingPrices,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSellingPricesFilterComposer(
              $db: $db,
              $table: $db.itemSellingPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemPromotionalPricesOrderingComposer
    extends Composer<_$AppDatabase, ItemPromotionalPrices> {
  $ItemPromotionalPricesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get promoPrice => $composableBuilder(
      column: $table.promoPrice, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $ItemSellingPricesOrderingComposer get itemSellingPriceId {
    final $ItemSellingPricesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemSellingPriceId,
        referencedTable: $db.itemSellingPrices,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSellingPricesOrderingComposer(
              $db: $db,
              $table: $db.itemSellingPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemPromotionalPricesAnnotationComposer
    extends Composer<_$AppDatabase, ItemPromotionalPrices> {
  $ItemPromotionalPricesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get promoPrice => $composableBuilder(
      column: $table.promoPrice, builder: (column) => column);

  GeneratedColumn<int> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<int> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $ItemSellingPricesAnnotationComposer get itemSellingPriceId {
    final $ItemSellingPricesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemSellingPriceId,
        referencedTable: $db.itemSellingPrices,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemSellingPricesAnnotationComposer(
              $db: $db,
              $table: $db.itemSellingPrices,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemPromotionalPricesTableManager extends RootTableManager<
    _$AppDatabase,
    ItemPromotionalPrices,
    ItemPromotionalPrice,
    $ItemPromotionalPricesFilterComposer,
    $ItemPromotionalPricesOrderingComposer,
    $ItemPromotionalPricesAnnotationComposer,
    $ItemPromotionalPricesCreateCompanionBuilder,
    $ItemPromotionalPricesUpdateCompanionBuilder,
    (ItemPromotionalPrice, $ItemPromotionalPricesReferences),
    ItemPromotionalPrice,
    PrefetchHooks Function({bool itemSellingPriceId})> {
  $ItemPromotionalPricesTableManager(
      _$AppDatabase db, ItemPromotionalPrices table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ItemPromotionalPricesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ItemPromotionalPricesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ItemPromotionalPricesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> itemSellingPriceId = const Value.absent(),
            Value<double> promoPrice = const Value.absent(),
            Value<int> startDate = const Value.absent(),
            Value<int> endDate = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              ItemPromotionalPricesCompanion(
            id: id,
            itemSellingPriceId: itemSellingPriceId,
            promoPrice: promoPrice,
            startDate: startDate,
            endDate: endDate,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int itemSellingPriceId,
            required double promoPrice,
            required int startDate,
            required int endDate,
            required int createdAt,
          }) =>
              ItemPromotionalPricesCompanion.insert(
            id: id,
            itemSellingPriceId: itemSellingPriceId,
            promoPrice: promoPrice,
            startDate: startDate,
            endDate: endDate,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $ItemPromotionalPricesReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({itemSellingPriceId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemSellingPriceId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemSellingPriceId,
                    referencedTable: $ItemPromotionalPricesReferences
                        ._itemSellingPriceIdTable(db),
                    referencedColumn: $ItemPromotionalPricesReferences
                        ._itemSellingPriceIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $ItemPromotionalPricesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    ItemPromotionalPrices,
    ItemPromotionalPrice,
    $ItemPromotionalPricesFilterComposer,
    $ItemPromotionalPricesOrderingComposer,
    $ItemPromotionalPricesAnnotationComposer,
    $ItemPromotionalPricesCreateCompanionBuilder,
    $ItemPromotionalPricesUpdateCompanionBuilder,
    (ItemPromotionalPrice, $ItemPromotionalPricesReferences),
    ItemPromotionalPrice,
    PrefetchHooks Function({bool itemSellingPriceId})>;
typedef $ItemAttachmentsCreateCompanionBuilder = ItemAttachmentsCompanion
    Function({
  Value<int> id,
  required int itemId,
  required String fileName,
  required String filePath,
  required String fileType,
  required int createdAt,
});
typedef $ItemAttachmentsUpdateCompanionBuilder = ItemAttachmentsCompanion
    Function({
  Value<int> id,
  Value<int> itemId,
  Value<String> fileName,
  Value<String> filePath,
  Value<String> fileType,
  Value<int> createdAt,
});

final class $ItemAttachmentsReferences
    extends BaseReferences<_$AppDatabase, ItemAttachments, ItemAttachment> {
  $ItemAttachmentsReferences(super.$_db, super.$_table, super.$_typedResult);

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.itemAttachments.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $ItemAttachmentsFilterComposer
    extends Composer<_$AppDatabase, ItemAttachments> {
  $ItemAttachmentsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fileName => $composableBuilder(
      column: $table.fileName, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get filePath => $composableBuilder(
      column: $table.filePath, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fileType => $composableBuilder(
      column: $table.fileType, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemAttachmentsOrderingComposer
    extends Composer<_$AppDatabase, ItemAttachments> {
  $ItemAttachmentsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fileName => $composableBuilder(
      column: $table.fileName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get filePath => $composableBuilder(
      column: $table.filePath, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fileType => $composableBuilder(
      column: $table.fileType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemAttachmentsAnnotationComposer
    extends Composer<_$AppDatabase, ItemAttachments> {
  $ItemAttachmentsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get fileName =>
      $composableBuilder(column: $table.fileName, builder: (column) => column);

  GeneratedColumn<String> get filePath =>
      $composableBuilder(column: $table.filePath, builder: (column) => column);

  GeneratedColumn<String> get fileType =>
      $composableBuilder(column: $table.fileType, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $ItemAttachmentsTableManager extends RootTableManager<
    _$AppDatabase,
    ItemAttachments,
    ItemAttachment,
    $ItemAttachmentsFilterComposer,
    $ItemAttachmentsOrderingComposer,
    $ItemAttachmentsAnnotationComposer,
    $ItemAttachmentsCreateCompanionBuilder,
    $ItemAttachmentsUpdateCompanionBuilder,
    (ItemAttachment, $ItemAttachmentsReferences),
    ItemAttachment,
    PrefetchHooks Function({bool itemId})> {
  $ItemAttachmentsTableManager(_$AppDatabase db, ItemAttachments table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ItemAttachmentsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ItemAttachmentsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ItemAttachmentsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<String> fileName = const Value.absent(),
            Value<String> filePath = const Value.absent(),
            Value<String> fileType = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              ItemAttachmentsCompanion(
            id: id,
            itemId: itemId,
            fileName: fileName,
            filePath: filePath,
            fileType: fileType,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int itemId,
            required String fileName,
            required String filePath,
            required String fileType,
            required int createdAt,
          }) =>
              ItemAttachmentsCompanion.insert(
            id: id,
            itemId: itemId,
            fileName: fileName,
            filePath: filePath,
            fileType: fileType,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $ItemAttachmentsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $ItemAttachmentsReferences._itemIdTable(db),
                    referencedColumn:
                        $ItemAttachmentsReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $ItemAttachmentsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    ItemAttachments,
    ItemAttachment,
    $ItemAttachmentsFilterComposer,
    $ItemAttachmentsOrderingComposer,
    $ItemAttachmentsAnnotationComposer,
    $ItemAttachmentsCreateCompanionBuilder,
    $ItemAttachmentsUpdateCompanionBuilder,
    (ItemAttachment, $ItemAttachmentsReferences),
    ItemAttachment,
    PrefetchHooks Function({bool itemId})>;
typedef $StockBalancesCreateCompanionBuilder = StockBalancesCompanion Function({
  Value<int> id,
  required int itemId,
  required int warehouseId,
  Value<double> quantity,
  Value<double> reservedQuantity,
  required int updatedAt,
});
typedef $StockBalancesUpdateCompanionBuilder = StockBalancesCompanion Function({
  Value<int> id,
  Value<int> itemId,
  Value<int> warehouseId,
  Value<double> quantity,
  Value<double> reservedQuantity,
  Value<int> updatedAt,
});

final class $StockBalancesReferences
    extends BaseReferences<_$AppDatabase, StockBalances, StockBalance> {
  $StockBalancesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Items _itemIdTable(_$AppDatabase db) => db.items
      .createAlias($_aliasNameGenerator(db.stockBalances.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Warehouses _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias(
          $_aliasNameGenerator(db.stockBalances.warehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<int>('warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $StockBalancesFilterComposer
    extends Composer<_$AppDatabase, StockBalances> {
  $StockBalancesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesFilterComposer get warehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockBalancesOrderingComposer
    extends Composer<_$AppDatabase, StockBalances> {
  $StockBalancesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesOrderingComposer get warehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockBalancesAnnotationComposer
    extends Composer<_$AppDatabase, StockBalances> {
  $StockBalancesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesAnnotationComposer get warehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockBalancesTableManager extends RootTableManager<
    _$AppDatabase,
    StockBalances,
    StockBalance,
    $StockBalancesFilterComposer,
    $StockBalancesOrderingComposer,
    $StockBalancesAnnotationComposer,
    $StockBalancesCreateCompanionBuilder,
    $StockBalancesUpdateCompanionBuilder,
    (StockBalance, $StockBalancesReferences),
    StockBalance,
    PrefetchHooks Function({bool itemId, bool warehouseId})> {
  $StockBalancesTableManager(_$AppDatabase db, StockBalances table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $StockBalancesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $StockBalancesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $StockBalancesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<int> warehouseId = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> reservedQuantity = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              StockBalancesCompanion(
            id: id,
            itemId: itemId,
            warehouseId: warehouseId,
            quantity: quantity,
            reservedQuantity: reservedQuantity,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int itemId,
            required int warehouseId,
            Value<double> quantity = const Value.absent(),
            Value<double> reservedQuantity = const Value.absent(),
            required int updatedAt,
          }) =>
              StockBalancesCompanion.insert(
            id: id,
            itemId: itemId,
            warehouseId: warehouseId,
            quantity: quantity,
            reservedQuantity: reservedQuantity,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $StockBalancesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({itemId = false, warehouseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable: $StockBalancesReferences._itemIdTable(db),
                    referencedColumn:
                        $StockBalancesReferences._itemIdTable(db).id,
                  ) as T;
                }
                if (warehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.warehouseId,
                    referencedTable:
                        $StockBalancesReferences._warehouseIdTable(db),
                    referencedColumn:
                        $StockBalancesReferences._warehouseIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $StockBalancesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    StockBalances,
    StockBalance,
    $StockBalancesFilterComposer,
    $StockBalancesOrderingComposer,
    $StockBalancesAnnotationComposer,
    $StockBalancesCreateCompanionBuilder,
    $StockBalancesUpdateCompanionBuilder,
    (StockBalance, $StockBalancesReferences),
    StockBalance,
    PrefetchHooks Function({bool itemId, bool warehouseId})>;
typedef $StockTransactionsCreateCompanionBuilder = StockTransactionsCompanion
    Function({
  Value<int> id,
  required String transactionType,
  required String docNo,
  required int docDate,
  required int warehouseId,
  required int itemId,
  required double quantity,
  required double unitCost,
  required double totalCost,
  Value<int?> expiryDate,
  Value<String?> batchNumber,
  Value<String?> referenceDocNo,
  Value<String?> notes,
  Value<String> status,
  Value<int?> postedAt,
  Value<String?> postedBy,
  required String createdBy,
  required int createdAt,
  required int updatedAt,
});
typedef $StockTransactionsUpdateCompanionBuilder = StockTransactionsCompanion
    Function({
  Value<int> id,
  Value<String> transactionType,
  Value<String> docNo,
  Value<int> docDate,
  Value<int> warehouseId,
  Value<int> itemId,
  Value<double> quantity,
  Value<double> unitCost,
  Value<double> totalCost,
  Value<int?> expiryDate,
  Value<String?> batchNumber,
  Value<String?> referenceDocNo,
  Value<String?> notes,
  Value<String> status,
  Value<int?> postedAt,
  Value<String?> postedBy,
  Value<String> createdBy,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $StockTransactionsReferences
    extends BaseReferences<_$AppDatabase, StockTransactions, StockTransaction> {
  $StockTransactionsReferences(super.$_db, super.$_table, super.$_typedResult);

  static Warehouses _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.stockTransactions.warehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<int>('warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.stockTransactions.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $StockTransactionsFilterComposer
    extends Composer<_$AppDatabase, StockTransactions> {
  $StockTransactionsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get transactionType => $composableBuilder(
      column: $table.transactionType,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get docDate => $composableBuilder(
      column: $table.docDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get referenceDocNo => $composableBuilder(
      column: $table.referenceDocNo,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $WarehousesFilterComposer get warehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockTransactionsOrderingComposer
    extends Composer<_$AppDatabase, StockTransactions> {
  $StockTransactionsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get transactionType => $composableBuilder(
      column: $table.transactionType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get docDate => $composableBuilder(
      column: $table.docDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get referenceDocNo => $composableBuilder(
      column: $table.referenceDocNo,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $WarehousesOrderingComposer get warehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockTransactionsAnnotationComposer
    extends Composer<_$AppDatabase, StockTransactions> {
  $StockTransactionsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get transactionType => $composableBuilder(
      column: $table.transactionType, builder: (column) => column);

  GeneratedColumn<String> get docNo =>
      $composableBuilder(column: $table.docNo, builder: (column) => column);

  GeneratedColumn<int> get docDate =>
      $composableBuilder(column: $table.docDate, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<double> get totalCost =>
      $composableBuilder(column: $table.totalCost, builder: (column) => column);

  GeneratedColumn<int> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => column);

  GeneratedColumn<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => column);

  GeneratedColumn<String> get referenceDocNo => $composableBuilder(
      column: $table.referenceDocNo, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get postedAt =>
      $composableBuilder(column: $table.postedAt, builder: (column) => column);

  GeneratedColumn<String> get postedBy =>
      $composableBuilder(column: $table.postedBy, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $WarehousesAnnotationComposer get warehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockTransactionsTableManager extends RootTableManager<
    _$AppDatabase,
    StockTransactions,
    StockTransaction,
    $StockTransactionsFilterComposer,
    $StockTransactionsOrderingComposer,
    $StockTransactionsAnnotationComposer,
    $StockTransactionsCreateCompanionBuilder,
    $StockTransactionsUpdateCompanionBuilder,
    (StockTransaction, $StockTransactionsReferences),
    StockTransaction,
    PrefetchHooks Function({bool warehouseId, bool itemId})> {
  $StockTransactionsTableManager(_$AppDatabase db, StockTransactions table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $StockTransactionsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $StockTransactionsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $StockTransactionsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> transactionType = const Value.absent(),
            Value<String> docNo = const Value.absent(),
            Value<int> docDate = const Value.absent(),
            Value<int> warehouseId = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
            Value<double> totalCost = const Value.absent(),
            Value<int?> expiryDate = const Value.absent(),
            Value<String?> batchNumber = const Value.absent(),
            Value<String?> referenceDocNo = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              StockTransactionsCompanion(
            id: id,
            transactionType: transactionType,
            docNo: docNo,
            docDate: docDate,
            warehouseId: warehouseId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            expiryDate: expiryDate,
            batchNumber: batchNumber,
            referenceDocNo: referenceDocNo,
            notes: notes,
            status: status,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String transactionType,
            required String docNo,
            required int docDate,
            required int warehouseId,
            required int itemId,
            required double quantity,
            required double unitCost,
            required double totalCost,
            Value<int?> expiryDate = const Value.absent(),
            Value<String?> batchNumber = const Value.absent(),
            Value<String?> referenceDocNo = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            required String createdBy,
            required int createdAt,
            required int updatedAt,
          }) =>
              StockTransactionsCompanion.insert(
            id: id,
            transactionType: transactionType,
            docNo: docNo,
            docDate: docDate,
            warehouseId: warehouseId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            expiryDate: expiryDate,
            batchNumber: batchNumber,
            referenceDocNo: referenceDocNo,
            notes: notes,
            status: status,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $StockTransactionsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({warehouseId = false, itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (warehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.warehouseId,
                    referencedTable:
                        $StockTransactionsReferences._warehouseIdTable(db),
                    referencedColumn:
                        $StockTransactionsReferences._warehouseIdTable(db).id,
                  ) as T;
                }
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $StockTransactionsReferences._itemIdTable(db),
                    referencedColumn:
                        $StockTransactionsReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $StockTransactionsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    StockTransactions,
    StockTransaction,
    $StockTransactionsFilterComposer,
    $StockTransactionsOrderingComposer,
    $StockTransactionsAnnotationComposer,
    $StockTransactionsCreateCompanionBuilder,
    $StockTransactionsUpdateCompanionBuilder,
    (StockTransaction, $StockTransactionsReferences),
    StockTransaction,
    PrefetchHooks Function({bool warehouseId, bool itemId})>;
typedef $IncomingStockOrdersCreateCompanionBuilder
    = IncomingStockOrdersCompanion Function({
  Value<int> id,
  required String docNo,
  required int docDate,
  required int warehouseId,
  Value<String?> supplierId,
  Value<String?> refNo,
  Value<String?> notes,
  Value<String> status,
  Value<int?> postedAt,
  Value<String?> postedBy,
  required String createdBy,
  required int createdAt,
  required int updatedAt,
});
typedef $IncomingStockOrdersUpdateCompanionBuilder
    = IncomingStockOrdersCompanion Function({
  Value<int> id,
  Value<String> docNo,
  Value<int> docDate,
  Value<int> warehouseId,
  Value<String?> supplierId,
  Value<String?> refNo,
  Value<String?> notes,
  Value<String> status,
  Value<int?> postedAt,
  Value<String?> postedBy,
  Value<String> createdBy,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $IncomingStockOrdersReferences extends BaseReferences<_$AppDatabase,
    IncomingStockOrders, IncomingStockOrder> {
  $IncomingStockOrdersReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static Warehouses _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.incomingStockOrders.warehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<int>('warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<IncomingStockOrderLines,
      List<IncomingStockOrderLine>> _incomingStockOrderLinesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.incomingStockOrderLines,
          aliasName: $_aliasNameGenerator(
              db.incomingStockOrders.id, db.incomingStockOrderLines.orderId));

  $IncomingStockOrderLinesProcessedTableManager
      get incomingStockOrderLinesRefs {
    final manager =
        $IncomingStockOrderLinesTableManager($_db, $_db.incomingStockOrderLines)
            .filter((f) => f.orderId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_incomingStockOrderLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $IncomingStockOrdersFilterComposer
    extends Composer<_$AppDatabase, IncomingStockOrders> {
  $IncomingStockOrdersFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get docDate => $composableBuilder(
      column: $table.docDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get supplierId => $composableBuilder(
      column: $table.supplierId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get refNo => $composableBuilder(
      column: $table.refNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $WarehousesFilterComposer get warehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> incomingStockOrderLinesRefs(
      Expression<bool> Function($IncomingStockOrderLinesFilterComposer f) f) {
    final $IncomingStockOrderLinesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.incomingStockOrderLines,
        getReferencedColumn: (t) => t.orderId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrderLinesFilterComposer(
              $db: $db,
              $table: $db.incomingStockOrderLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $IncomingStockOrdersOrderingComposer
    extends Composer<_$AppDatabase, IncomingStockOrders> {
  $IncomingStockOrdersOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get docDate => $composableBuilder(
      column: $table.docDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get supplierId => $composableBuilder(
      column: $table.supplierId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get refNo => $composableBuilder(
      column: $table.refNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $WarehousesOrderingComposer get warehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $IncomingStockOrdersAnnotationComposer
    extends Composer<_$AppDatabase, IncomingStockOrders> {
  $IncomingStockOrdersAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get docNo =>
      $composableBuilder(column: $table.docNo, builder: (column) => column);

  GeneratedColumn<int> get docDate =>
      $composableBuilder(column: $table.docDate, builder: (column) => column);

  GeneratedColumn<String> get supplierId => $composableBuilder(
      column: $table.supplierId, builder: (column) => column);

  GeneratedColumn<String> get refNo =>
      $composableBuilder(column: $table.refNo, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get postedAt =>
      $composableBuilder(column: $table.postedAt, builder: (column) => column);

  GeneratedColumn<String> get postedBy =>
      $composableBuilder(column: $table.postedBy, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $WarehousesAnnotationComposer get warehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> incomingStockOrderLinesRefs<T extends Object>(
      Expression<T> Function($IncomingStockOrderLinesAnnotationComposer a) f) {
    final $IncomingStockOrderLinesAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.incomingStockOrderLines,
            getReferencedColumn: (t) => t.orderId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $IncomingStockOrderLinesAnnotationComposer(
                  $db: $db,
                  $table: $db.incomingStockOrderLines,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $IncomingStockOrdersTableManager extends RootTableManager<
    _$AppDatabase,
    IncomingStockOrders,
    IncomingStockOrder,
    $IncomingStockOrdersFilterComposer,
    $IncomingStockOrdersOrderingComposer,
    $IncomingStockOrdersAnnotationComposer,
    $IncomingStockOrdersCreateCompanionBuilder,
    $IncomingStockOrdersUpdateCompanionBuilder,
    (IncomingStockOrder, $IncomingStockOrdersReferences),
    IncomingStockOrder,
    PrefetchHooks Function(
        {bool warehouseId, bool incomingStockOrderLinesRefs})> {
  $IncomingStockOrdersTableManager(_$AppDatabase db, IncomingStockOrders table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $IncomingStockOrdersFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $IncomingStockOrdersOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $IncomingStockOrdersAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> docNo = const Value.absent(),
            Value<int> docDate = const Value.absent(),
            Value<int> warehouseId = const Value.absent(),
            Value<String?> supplierId = const Value.absent(),
            Value<String?> refNo = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              IncomingStockOrdersCompanion(
            id: id,
            docNo: docNo,
            docDate: docDate,
            warehouseId: warehouseId,
            supplierId: supplierId,
            refNo: refNo,
            notes: notes,
            status: status,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String docNo,
            required int docDate,
            required int warehouseId,
            Value<String?> supplierId = const Value.absent(),
            Value<String?> refNo = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            required String createdBy,
            required int createdAt,
            required int updatedAt,
          }) =>
              IncomingStockOrdersCompanion.insert(
            id: id,
            docNo: docNo,
            docDate: docDate,
            warehouseId: warehouseId,
            supplierId: supplierId,
            refNo: refNo,
            notes: notes,
            status: status,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $IncomingStockOrdersReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {warehouseId = false, incomingStockOrderLinesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (incomingStockOrderLinesRefs) db.incomingStockOrderLines
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (warehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.warehouseId,
                    referencedTable:
                        $IncomingStockOrdersReferences._warehouseIdTable(db),
                    referencedColumn:
                        $IncomingStockOrdersReferences._warehouseIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (incomingStockOrderLinesRefs)
                    await $_getPrefetchedData<IncomingStockOrder,
                            IncomingStockOrders, IncomingStockOrderLine>(
                        currentTable: table,
                        referencedTable: $IncomingStockOrdersReferences
                            ._incomingStockOrderLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $IncomingStockOrdersReferences(db, table, p0)
                                .incomingStockOrderLinesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.orderId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $IncomingStockOrdersProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    IncomingStockOrders,
    IncomingStockOrder,
    $IncomingStockOrdersFilterComposer,
    $IncomingStockOrdersOrderingComposer,
    $IncomingStockOrdersAnnotationComposer,
    $IncomingStockOrdersCreateCompanionBuilder,
    $IncomingStockOrdersUpdateCompanionBuilder,
    (IncomingStockOrder, $IncomingStockOrdersReferences),
    IncomingStockOrder,
    PrefetchHooks Function(
        {bool warehouseId, bool incomingStockOrderLinesRefs})>;
typedef $IncomingStockOrderLinesCreateCompanionBuilder
    = IncomingStockOrderLinesCompanion Function({
  Value<int> id,
  required int orderId,
  required int itemId,
  required double quantity,
  required double unitCost,
  required double totalCost,
  Value<int?> expiryDate,
  Value<String?> batchNumber,
  required int createdAt,
});
typedef $IncomingStockOrderLinesUpdateCompanionBuilder
    = IncomingStockOrderLinesCompanion Function({
  Value<int> id,
  Value<int> orderId,
  Value<int> itemId,
  Value<double> quantity,
  Value<double> unitCost,
  Value<double> totalCost,
  Value<int?> expiryDate,
  Value<String?> batchNumber,
  Value<int> createdAt,
});

final class $IncomingStockOrderLinesReferences extends BaseReferences<
    _$AppDatabase, IncomingStockOrderLines, IncomingStockOrderLine> {
  $IncomingStockOrderLinesReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static IncomingStockOrders _orderIdTable(_$AppDatabase db) =>
      db.incomingStockOrders.createAlias($_aliasNameGenerator(
          db.incomingStockOrderLines.orderId, db.incomingStockOrders.id));

  $IncomingStockOrdersProcessedTableManager get orderId {
    final $_column = $_itemColumn<int>('order_id')!;

    final manager =
        $IncomingStockOrdersTableManager($_db, $_db.incomingStockOrders)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.incomingStockOrderLines.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $IncomingStockOrderLinesFilterComposer
    extends Composer<_$AppDatabase, IncomingStockOrderLines> {
  $IncomingStockOrderLinesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $IncomingStockOrdersFilterComposer get orderId {
    final $IncomingStockOrdersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderId,
        referencedTable: $db.incomingStockOrders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrdersFilterComposer(
              $db: $db,
              $table: $db.incomingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $IncomingStockOrderLinesOrderingComposer
    extends Composer<_$AppDatabase, IncomingStockOrderLines> {
  $IncomingStockOrderLinesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $IncomingStockOrdersOrderingComposer get orderId {
    final $IncomingStockOrdersOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderId,
        referencedTable: $db.incomingStockOrders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrdersOrderingComposer(
              $db: $db,
              $table: $db.incomingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $IncomingStockOrderLinesAnnotationComposer
    extends Composer<_$AppDatabase, IncomingStockOrderLines> {
  $IncomingStockOrderLinesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<double> get totalCost =>
      $composableBuilder(column: $table.totalCost, builder: (column) => column);

  GeneratedColumn<int> get expiryDate => $composableBuilder(
      column: $table.expiryDate, builder: (column) => column);

  GeneratedColumn<String> get batchNumber => $composableBuilder(
      column: $table.batchNumber, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $IncomingStockOrdersAnnotationComposer get orderId {
    final $IncomingStockOrdersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderId,
        referencedTable: $db.incomingStockOrders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $IncomingStockOrdersAnnotationComposer(
              $db: $db,
              $table: $db.incomingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $IncomingStockOrderLinesTableManager extends RootTableManager<
    _$AppDatabase,
    IncomingStockOrderLines,
    IncomingStockOrderLine,
    $IncomingStockOrderLinesFilterComposer,
    $IncomingStockOrderLinesOrderingComposer,
    $IncomingStockOrderLinesAnnotationComposer,
    $IncomingStockOrderLinesCreateCompanionBuilder,
    $IncomingStockOrderLinesUpdateCompanionBuilder,
    (IncomingStockOrderLine, $IncomingStockOrderLinesReferences),
    IncomingStockOrderLine,
    PrefetchHooks Function({bool orderId, bool itemId})> {
  $IncomingStockOrderLinesTableManager(
      _$AppDatabase db, IncomingStockOrderLines table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $IncomingStockOrderLinesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $IncomingStockOrderLinesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $IncomingStockOrderLinesAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> orderId = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
            Value<double> totalCost = const Value.absent(),
            Value<int?> expiryDate = const Value.absent(),
            Value<String?> batchNumber = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              IncomingStockOrderLinesCompanion(
            id: id,
            orderId: orderId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            expiryDate: expiryDate,
            batchNumber: batchNumber,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int orderId,
            required int itemId,
            required double quantity,
            required double unitCost,
            required double totalCost,
            Value<int?> expiryDate = const Value.absent(),
            Value<String?> batchNumber = const Value.absent(),
            required int createdAt,
          }) =>
              IncomingStockOrderLinesCompanion.insert(
            id: id,
            orderId: orderId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            expiryDate: expiryDate,
            batchNumber: batchNumber,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $IncomingStockOrderLinesReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderId = false, itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderId,
                    referencedTable:
                        $IncomingStockOrderLinesReferences._orderIdTable(db),
                    referencedColumn:
                        $IncomingStockOrderLinesReferences._orderIdTable(db).id,
                  ) as T;
                }
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $IncomingStockOrderLinesReferences._itemIdTable(db),
                    referencedColumn:
                        $IncomingStockOrderLinesReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $IncomingStockOrderLinesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    IncomingStockOrderLines,
    IncomingStockOrderLine,
    $IncomingStockOrderLinesFilterComposer,
    $IncomingStockOrderLinesOrderingComposer,
    $IncomingStockOrderLinesAnnotationComposer,
    $IncomingStockOrderLinesCreateCompanionBuilder,
    $IncomingStockOrderLinesUpdateCompanionBuilder,
    (IncomingStockOrderLine, $IncomingStockOrderLinesReferences),
    IncomingStockOrderLine,
    PrefetchHooks Function({bool orderId, bool itemId})>;
typedef $OutgoingStockOrdersCreateCompanionBuilder
    = OutgoingStockOrdersCompanion Function({
  Value<int> id,
  required String docNo,
  required int docDate,
  required int warehouseId,
  required String reason,
  required String beneficiaryAccountId,
  Value<String?> notes,
  Value<String> status,
  Value<int?> postedAt,
  Value<String?> postedBy,
  required String createdBy,
  required int createdAt,
  required int updatedAt,
});
typedef $OutgoingStockOrdersUpdateCompanionBuilder
    = OutgoingStockOrdersCompanion Function({
  Value<int> id,
  Value<String> docNo,
  Value<int> docDate,
  Value<int> warehouseId,
  Value<String> reason,
  Value<String> beneficiaryAccountId,
  Value<String?> notes,
  Value<String> status,
  Value<int?> postedAt,
  Value<String?> postedBy,
  Value<String> createdBy,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $OutgoingStockOrdersReferences extends BaseReferences<_$AppDatabase,
    OutgoingStockOrders, OutgoingStockOrder> {
  $OutgoingStockOrdersReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static Warehouses _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.outgoingStockOrders.warehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<int>('warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<OutgoingStockOrderLines,
      List<OutgoingStockOrderLine>> _outgoingStockOrderLinesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.outgoingStockOrderLines,
          aliasName: $_aliasNameGenerator(
              db.outgoingStockOrders.id, db.outgoingStockOrderLines.orderId));

  $OutgoingStockOrderLinesProcessedTableManager
      get outgoingStockOrderLinesRefs {
    final manager =
        $OutgoingStockOrderLinesTableManager($_db, $_db.outgoingStockOrderLines)
            .filter((f) => f.orderId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_outgoingStockOrderLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $OutgoingStockOrdersFilterComposer
    extends Composer<_$AppDatabase, OutgoingStockOrders> {
  $OutgoingStockOrdersFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get docDate => $composableBuilder(
      column: $table.docDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get beneficiaryAccountId => $composableBuilder(
      column: $table.beneficiaryAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $WarehousesFilterComposer get warehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> outgoingStockOrderLinesRefs(
      Expression<bool> Function($OutgoingStockOrderLinesFilterComposer f) f) {
    final $OutgoingStockOrderLinesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.outgoingStockOrderLines,
        getReferencedColumn: (t) => t.orderId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrderLinesFilterComposer(
              $db: $db,
              $table: $db.outgoingStockOrderLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $OutgoingStockOrdersOrderingComposer
    extends Composer<_$AppDatabase, OutgoingStockOrders> {
  $OutgoingStockOrdersOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get docDate => $composableBuilder(
      column: $table.docDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get beneficiaryAccountId => $composableBuilder(
      column: $table.beneficiaryAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $WarehousesOrderingComposer get warehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $OutgoingStockOrdersAnnotationComposer
    extends Composer<_$AppDatabase, OutgoingStockOrders> {
  $OutgoingStockOrdersAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get docNo =>
      $composableBuilder(column: $table.docNo, builder: (column) => column);

  GeneratedColumn<int> get docDate =>
      $composableBuilder(column: $table.docDate, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get beneficiaryAccountId => $composableBuilder(
      column: $table.beneficiaryAccountId, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get postedAt =>
      $composableBuilder(column: $table.postedAt, builder: (column) => column);

  GeneratedColumn<String> get postedBy =>
      $composableBuilder(column: $table.postedBy, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $WarehousesAnnotationComposer get warehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> outgoingStockOrderLinesRefs<T extends Object>(
      Expression<T> Function($OutgoingStockOrderLinesAnnotationComposer a) f) {
    final $OutgoingStockOrderLinesAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.outgoingStockOrderLines,
            getReferencedColumn: (t) => t.orderId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $OutgoingStockOrderLinesAnnotationComposer(
                  $db: $db,
                  $table: $db.outgoingStockOrderLines,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $OutgoingStockOrdersTableManager extends RootTableManager<
    _$AppDatabase,
    OutgoingStockOrders,
    OutgoingStockOrder,
    $OutgoingStockOrdersFilterComposer,
    $OutgoingStockOrdersOrderingComposer,
    $OutgoingStockOrdersAnnotationComposer,
    $OutgoingStockOrdersCreateCompanionBuilder,
    $OutgoingStockOrdersUpdateCompanionBuilder,
    (OutgoingStockOrder, $OutgoingStockOrdersReferences),
    OutgoingStockOrder,
    PrefetchHooks Function(
        {bool warehouseId, bool outgoingStockOrderLinesRefs})> {
  $OutgoingStockOrdersTableManager(_$AppDatabase db, OutgoingStockOrders table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $OutgoingStockOrdersFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $OutgoingStockOrdersOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $OutgoingStockOrdersAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> docNo = const Value.absent(),
            Value<int> docDate = const Value.absent(),
            Value<int> warehouseId = const Value.absent(),
            Value<String> reason = const Value.absent(),
            Value<String> beneficiaryAccountId = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              OutgoingStockOrdersCompanion(
            id: id,
            docNo: docNo,
            docDate: docDate,
            warehouseId: warehouseId,
            reason: reason,
            beneficiaryAccountId: beneficiaryAccountId,
            notes: notes,
            status: status,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String docNo,
            required int docDate,
            required int warehouseId,
            required String reason,
            required String beneficiaryAccountId,
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            required String createdBy,
            required int createdAt,
            required int updatedAt,
          }) =>
              OutgoingStockOrdersCompanion.insert(
            id: id,
            docNo: docNo,
            docDate: docDate,
            warehouseId: warehouseId,
            reason: reason,
            beneficiaryAccountId: beneficiaryAccountId,
            notes: notes,
            status: status,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $OutgoingStockOrdersReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {warehouseId = false, outgoingStockOrderLinesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (outgoingStockOrderLinesRefs) db.outgoingStockOrderLines
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (warehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.warehouseId,
                    referencedTable:
                        $OutgoingStockOrdersReferences._warehouseIdTable(db),
                    referencedColumn:
                        $OutgoingStockOrdersReferences._warehouseIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (outgoingStockOrderLinesRefs)
                    await $_getPrefetchedData<OutgoingStockOrder,
                            OutgoingStockOrders, OutgoingStockOrderLine>(
                        currentTable: table,
                        referencedTable: $OutgoingStockOrdersReferences
                            ._outgoingStockOrderLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $OutgoingStockOrdersReferences(db, table, p0)
                                .outgoingStockOrderLinesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.orderId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $OutgoingStockOrdersProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    OutgoingStockOrders,
    OutgoingStockOrder,
    $OutgoingStockOrdersFilterComposer,
    $OutgoingStockOrdersOrderingComposer,
    $OutgoingStockOrdersAnnotationComposer,
    $OutgoingStockOrdersCreateCompanionBuilder,
    $OutgoingStockOrdersUpdateCompanionBuilder,
    (OutgoingStockOrder, $OutgoingStockOrdersReferences),
    OutgoingStockOrder,
    PrefetchHooks Function(
        {bool warehouseId, bool outgoingStockOrderLinesRefs})>;
typedef $OutgoingStockOrderLinesCreateCompanionBuilder
    = OutgoingStockOrderLinesCompanion Function({
  Value<int> id,
  required int orderId,
  required int itemId,
  required double quantity,
  required double unitCost,
  required double totalCost,
  required int createdAt,
});
typedef $OutgoingStockOrderLinesUpdateCompanionBuilder
    = OutgoingStockOrderLinesCompanion Function({
  Value<int> id,
  Value<int> orderId,
  Value<int> itemId,
  Value<double> quantity,
  Value<double> unitCost,
  Value<double> totalCost,
  Value<int> createdAt,
});

final class $OutgoingStockOrderLinesReferences extends BaseReferences<
    _$AppDatabase, OutgoingStockOrderLines, OutgoingStockOrderLine> {
  $OutgoingStockOrderLinesReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static OutgoingStockOrders _orderIdTable(_$AppDatabase db) =>
      db.outgoingStockOrders.createAlias($_aliasNameGenerator(
          db.outgoingStockOrderLines.orderId, db.outgoingStockOrders.id));

  $OutgoingStockOrdersProcessedTableManager get orderId {
    final $_column = $_itemColumn<int>('order_id')!;

    final manager =
        $OutgoingStockOrdersTableManager($_db, $_db.outgoingStockOrders)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_orderIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.outgoingStockOrderLines.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $OutgoingStockOrderLinesFilterComposer
    extends Composer<_$AppDatabase, OutgoingStockOrderLines> {
  $OutgoingStockOrderLinesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $OutgoingStockOrdersFilterComposer get orderId {
    final $OutgoingStockOrdersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderId,
        referencedTable: $db.outgoingStockOrders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrdersFilterComposer(
              $db: $db,
              $table: $db.outgoingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $OutgoingStockOrderLinesOrderingComposer
    extends Composer<_$AppDatabase, OutgoingStockOrderLines> {
  $OutgoingStockOrderLinesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $OutgoingStockOrdersOrderingComposer get orderId {
    final $OutgoingStockOrdersOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderId,
        referencedTable: $db.outgoingStockOrders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrdersOrderingComposer(
              $db: $db,
              $table: $db.outgoingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $OutgoingStockOrderLinesAnnotationComposer
    extends Composer<_$AppDatabase, OutgoingStockOrderLines> {
  $OutgoingStockOrderLinesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<double> get totalCost =>
      $composableBuilder(column: $table.totalCost, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $OutgoingStockOrdersAnnotationComposer get orderId {
    final $OutgoingStockOrdersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.orderId,
        referencedTable: $db.outgoingStockOrders,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $OutgoingStockOrdersAnnotationComposer(
              $db: $db,
              $table: $db.outgoingStockOrders,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $OutgoingStockOrderLinesTableManager extends RootTableManager<
    _$AppDatabase,
    OutgoingStockOrderLines,
    OutgoingStockOrderLine,
    $OutgoingStockOrderLinesFilterComposer,
    $OutgoingStockOrderLinesOrderingComposer,
    $OutgoingStockOrderLinesAnnotationComposer,
    $OutgoingStockOrderLinesCreateCompanionBuilder,
    $OutgoingStockOrderLinesUpdateCompanionBuilder,
    (OutgoingStockOrderLine, $OutgoingStockOrderLinesReferences),
    OutgoingStockOrderLine,
    PrefetchHooks Function({bool orderId, bool itemId})> {
  $OutgoingStockOrderLinesTableManager(
      _$AppDatabase db, OutgoingStockOrderLines table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $OutgoingStockOrderLinesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $OutgoingStockOrderLinesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $OutgoingStockOrderLinesAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> orderId = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
            Value<double> totalCost = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              OutgoingStockOrderLinesCompanion(
            id: id,
            orderId: orderId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int orderId,
            required int itemId,
            required double quantity,
            required double unitCost,
            required double totalCost,
            required int createdAt,
          }) =>
              OutgoingStockOrderLinesCompanion.insert(
            id: id,
            orderId: orderId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $OutgoingStockOrderLinesReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({orderId = false, itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (orderId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.orderId,
                    referencedTable:
                        $OutgoingStockOrderLinesReferences._orderIdTable(db),
                    referencedColumn:
                        $OutgoingStockOrderLinesReferences._orderIdTable(db).id,
                  ) as T;
                }
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $OutgoingStockOrderLinesReferences._itemIdTable(db),
                    referencedColumn:
                        $OutgoingStockOrderLinesReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $OutgoingStockOrderLinesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    OutgoingStockOrderLines,
    OutgoingStockOrderLine,
    $OutgoingStockOrderLinesFilterComposer,
    $OutgoingStockOrderLinesOrderingComposer,
    $OutgoingStockOrderLinesAnnotationComposer,
    $OutgoingStockOrderLinesCreateCompanionBuilder,
    $OutgoingStockOrderLinesUpdateCompanionBuilder,
    (OutgoingStockOrderLine, $OutgoingStockOrderLinesReferences),
    OutgoingStockOrderLine,
    PrefetchHooks Function({bool orderId, bool itemId})>;
typedef $WarehouseTransfersCreateCompanionBuilder = WarehouseTransfersCompanion
    Function({
  Value<int> id,
  required String docNo,
  required int transferDate,
  required int sourceWarehouseId,
  required int destinationWarehouseId,
  Value<String?> refNo,
  Value<String?> notes,
  Value<String> status,
  Value<int?> dispatchedAt,
  Value<String?> dispatchedBy,
  Value<int?> receivedAt,
  Value<String?> receivedBy,
  required String createdBy,
  required int createdAt,
  required int updatedAt,
});
typedef $WarehouseTransfersUpdateCompanionBuilder = WarehouseTransfersCompanion
    Function({
  Value<int> id,
  Value<String> docNo,
  Value<int> transferDate,
  Value<int> sourceWarehouseId,
  Value<int> destinationWarehouseId,
  Value<String?> refNo,
  Value<String?> notes,
  Value<String> status,
  Value<int?> dispatchedAt,
  Value<String?> dispatchedBy,
  Value<int?> receivedAt,
  Value<String?> receivedBy,
  Value<String> createdBy,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $WarehouseTransfersReferences extends BaseReferences<_$AppDatabase,
    WarehouseTransfers, WarehouseTransfer> {
  $WarehouseTransfersReferences(super.$_db, super.$_table, super.$_typedResult);

  static Warehouses _sourceWarehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.warehouseTransfers.sourceWarehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get sourceWarehouseId {
    final $_column = $_itemColumn<int>('source_warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sourceWarehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Warehouses _destinationWarehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.warehouseTransfers.destinationWarehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get destinationWarehouseId {
    final $_column = $_itemColumn<int>('destination_warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item =
        $_typedResult.readTableOrNull(_destinationWarehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<WarehouseTransferLines,
      List<WarehouseTransferLine>> _warehouseTransferLinesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.warehouseTransferLines,
          aliasName: $_aliasNameGenerator(
              db.warehouseTransfers.id, db.warehouseTransferLines.transferId));

  $WarehouseTransferLinesProcessedTableManager get warehouseTransferLinesRefs {
    final manager =
        $WarehouseTransferLinesTableManager($_db, $_db.warehouseTransferLines)
            .filter((f) => f.transferId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_warehouseTransferLinesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $WarehouseTransfersFilterComposer
    extends Composer<_$AppDatabase, WarehouseTransfers> {
  $WarehouseTransfersFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get transferDate => $composableBuilder(
      column: $table.transferDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get refNo => $composableBuilder(
      column: $table.refNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get dispatchedAt => $composableBuilder(
      column: $table.dispatchedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get dispatchedBy => $composableBuilder(
      column: $table.dispatchedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get receivedBy => $composableBuilder(
      column: $table.receivedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $WarehousesFilterComposer get sourceWarehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sourceWarehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesFilterComposer get destinationWarehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.destinationWarehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> warehouseTransferLinesRefs(
      Expression<bool> Function($WarehouseTransferLinesFilterComposer f) f) {
    final $WarehouseTransferLinesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.warehouseTransferLines,
        getReferencedColumn: (t) => t.transferId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransferLinesFilterComposer(
              $db: $db,
              $table: $db.warehouseTransferLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $WarehouseTransfersOrderingComposer
    extends Composer<_$AppDatabase, WarehouseTransfers> {
  $WarehouseTransfersOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get docNo => $composableBuilder(
      column: $table.docNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get transferDate => $composableBuilder(
      column: $table.transferDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get refNo => $composableBuilder(
      column: $table.refNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get dispatchedAt => $composableBuilder(
      column: $table.dispatchedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get dispatchedBy => $composableBuilder(
      column: $table.dispatchedBy,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get receivedBy => $composableBuilder(
      column: $table.receivedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $WarehousesOrderingComposer get sourceWarehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sourceWarehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesOrderingComposer get destinationWarehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.destinationWarehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $WarehouseTransfersAnnotationComposer
    extends Composer<_$AppDatabase, WarehouseTransfers> {
  $WarehouseTransfersAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get docNo =>
      $composableBuilder(column: $table.docNo, builder: (column) => column);

  GeneratedColumn<int> get transferDate => $composableBuilder(
      column: $table.transferDate, builder: (column) => column);

  GeneratedColumn<String> get refNo =>
      $composableBuilder(column: $table.refNo, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get dispatchedAt => $composableBuilder(
      column: $table.dispatchedAt, builder: (column) => column);

  GeneratedColumn<String> get dispatchedBy => $composableBuilder(
      column: $table.dispatchedBy, builder: (column) => column);

  GeneratedColumn<int> get receivedAt => $composableBuilder(
      column: $table.receivedAt, builder: (column) => column);

  GeneratedColumn<String> get receivedBy => $composableBuilder(
      column: $table.receivedBy, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $WarehousesAnnotationComposer get sourceWarehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sourceWarehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesAnnotationComposer get destinationWarehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.destinationWarehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> warehouseTransferLinesRefs<T extends Object>(
      Expression<T> Function($WarehouseTransferLinesAnnotationComposer a) f) {
    final $WarehouseTransferLinesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.warehouseTransferLines,
        getReferencedColumn: (t) => t.transferId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransferLinesAnnotationComposer(
              $db: $db,
              $table: $db.warehouseTransferLines,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $WarehouseTransfersTableManager extends RootTableManager<
    _$AppDatabase,
    WarehouseTransfers,
    WarehouseTransfer,
    $WarehouseTransfersFilterComposer,
    $WarehouseTransfersOrderingComposer,
    $WarehouseTransfersAnnotationComposer,
    $WarehouseTransfersCreateCompanionBuilder,
    $WarehouseTransfersUpdateCompanionBuilder,
    (WarehouseTransfer, $WarehouseTransfersReferences),
    WarehouseTransfer,
    PrefetchHooks Function(
        {bool sourceWarehouseId,
        bool destinationWarehouseId,
        bool warehouseTransferLinesRefs})> {
  $WarehouseTransfersTableManager(_$AppDatabase db, WarehouseTransfers table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $WarehouseTransfersFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $WarehouseTransfersOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $WarehouseTransfersAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> docNo = const Value.absent(),
            Value<int> transferDate = const Value.absent(),
            Value<int> sourceWarehouseId = const Value.absent(),
            Value<int> destinationWarehouseId = const Value.absent(),
            Value<String?> refNo = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> dispatchedAt = const Value.absent(),
            Value<String?> dispatchedBy = const Value.absent(),
            Value<int?> receivedAt = const Value.absent(),
            Value<String?> receivedBy = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              WarehouseTransfersCompanion(
            id: id,
            docNo: docNo,
            transferDate: transferDate,
            sourceWarehouseId: sourceWarehouseId,
            destinationWarehouseId: destinationWarehouseId,
            refNo: refNo,
            notes: notes,
            status: status,
            dispatchedAt: dispatchedAt,
            dispatchedBy: dispatchedBy,
            receivedAt: receivedAt,
            receivedBy: receivedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String docNo,
            required int transferDate,
            required int sourceWarehouseId,
            required int destinationWarehouseId,
            Value<String?> refNo = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int?> dispatchedAt = const Value.absent(),
            Value<String?> dispatchedBy = const Value.absent(),
            Value<int?> receivedAt = const Value.absent(),
            Value<String?> receivedBy = const Value.absent(),
            required String createdBy,
            required int createdAt,
            required int updatedAt,
          }) =>
              WarehouseTransfersCompanion.insert(
            id: id,
            docNo: docNo,
            transferDate: transferDate,
            sourceWarehouseId: sourceWarehouseId,
            destinationWarehouseId: destinationWarehouseId,
            refNo: refNo,
            notes: notes,
            status: status,
            dispatchedAt: dispatchedAt,
            dispatchedBy: dispatchedBy,
            receivedAt: receivedAt,
            receivedBy: receivedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $WarehouseTransfersReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {sourceWarehouseId = false,
              destinationWarehouseId = false,
              warehouseTransferLinesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (warehouseTransferLinesRefs) db.warehouseTransferLines
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (sourceWarehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.sourceWarehouseId,
                    referencedTable: $WarehouseTransfersReferences
                        ._sourceWarehouseIdTable(db),
                    referencedColumn: $WarehouseTransfersReferences
                        ._sourceWarehouseIdTable(db)
                        .id,
                  ) as T;
                }
                if (destinationWarehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.destinationWarehouseId,
                    referencedTable: $WarehouseTransfersReferences
                        ._destinationWarehouseIdTable(db),
                    referencedColumn: $WarehouseTransfersReferences
                        ._destinationWarehouseIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (warehouseTransferLinesRefs)
                    await $_getPrefetchedData<WarehouseTransfer,
                            WarehouseTransfers, WarehouseTransferLine>(
                        currentTable: table,
                        referencedTable: $WarehouseTransfersReferences
                            ._warehouseTransferLinesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $WarehouseTransfersReferences(db, table, p0)
                                .warehouseTransferLinesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.transferId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $WarehouseTransfersProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    WarehouseTransfers,
    WarehouseTransfer,
    $WarehouseTransfersFilterComposer,
    $WarehouseTransfersOrderingComposer,
    $WarehouseTransfersAnnotationComposer,
    $WarehouseTransfersCreateCompanionBuilder,
    $WarehouseTransfersUpdateCompanionBuilder,
    (WarehouseTransfer, $WarehouseTransfersReferences),
    WarehouseTransfer,
    PrefetchHooks Function(
        {bool sourceWarehouseId,
        bool destinationWarehouseId,
        bool warehouseTransferLinesRefs})>;
typedef $WarehouseTransferLinesCreateCompanionBuilder
    = WarehouseTransferLinesCompanion Function({
  Value<int> id,
  required int transferId,
  required int itemId,
  required double quantity,
  required double unitCost,
  required double totalCost,
  required int createdAt,
});
typedef $WarehouseTransferLinesUpdateCompanionBuilder
    = WarehouseTransferLinesCompanion Function({
  Value<int> id,
  Value<int> transferId,
  Value<int> itemId,
  Value<double> quantity,
  Value<double> unitCost,
  Value<double> totalCost,
  Value<int> createdAt,
});

final class $WarehouseTransferLinesReferences extends BaseReferences<
    _$AppDatabase, WarehouseTransferLines, WarehouseTransferLine> {
  $WarehouseTransferLinesReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static WarehouseTransfers _transferIdTable(_$AppDatabase db) =>
      db.warehouseTransfers.createAlias($_aliasNameGenerator(
          db.warehouseTransferLines.transferId, db.warehouseTransfers.id));

  $WarehouseTransfersProcessedTableManager get transferId {
    final $_column = $_itemColumn<int>('transfer_id')!;

    final manager =
        $WarehouseTransfersTableManager($_db, $_db.warehouseTransfers)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_transferIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.warehouseTransferLines.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $WarehouseTransferLinesFilterComposer
    extends Composer<_$AppDatabase, WarehouseTransferLines> {
  $WarehouseTransferLinesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $WarehouseTransfersFilterComposer get transferId {
    final $WarehouseTransfersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.transferId,
        referencedTable: $db.warehouseTransfers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransfersFilterComposer(
              $db: $db,
              $table: $db.warehouseTransfers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $WarehouseTransferLinesOrderingComposer
    extends Composer<_$AppDatabase, WarehouseTransferLines> {
  $WarehouseTransferLinesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get quantity => $composableBuilder(
      column: $table.quantity, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get unitCost => $composableBuilder(
      column: $table.unitCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get totalCost => $composableBuilder(
      column: $table.totalCost, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $WarehouseTransfersOrderingComposer get transferId {
    final $WarehouseTransfersOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.transferId,
        referencedTable: $db.warehouseTransfers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransfersOrderingComposer(
              $db: $db,
              $table: $db.warehouseTransfers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $WarehouseTransferLinesAnnotationComposer
    extends Composer<_$AppDatabase, WarehouseTransferLines> {
  $WarehouseTransferLinesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<double> get unitCost =>
      $composableBuilder(column: $table.unitCost, builder: (column) => column);

  GeneratedColumn<double> get totalCost =>
      $composableBuilder(column: $table.totalCost, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $WarehouseTransfersAnnotationComposer get transferId {
    final $WarehouseTransfersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.transferId,
        referencedTable: $db.warehouseTransfers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehouseTransfersAnnotationComposer(
              $db: $db,
              $table: $db.warehouseTransfers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $WarehouseTransferLinesTableManager extends RootTableManager<
    _$AppDatabase,
    WarehouseTransferLines,
    WarehouseTransferLine,
    $WarehouseTransferLinesFilterComposer,
    $WarehouseTransferLinesOrderingComposer,
    $WarehouseTransferLinesAnnotationComposer,
    $WarehouseTransferLinesCreateCompanionBuilder,
    $WarehouseTransferLinesUpdateCompanionBuilder,
    (WarehouseTransferLine, $WarehouseTransferLinesReferences),
    WarehouseTransferLine,
    PrefetchHooks Function({bool transferId, bool itemId})> {
  $WarehouseTransferLinesTableManager(
      _$AppDatabase db, WarehouseTransferLines table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $WarehouseTransferLinesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $WarehouseTransferLinesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $WarehouseTransferLinesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> transferId = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<double> quantity = const Value.absent(),
            Value<double> unitCost = const Value.absent(),
            Value<double> totalCost = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              WarehouseTransferLinesCompanion(
            id: id,
            transferId: transferId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int transferId,
            required int itemId,
            required double quantity,
            required double unitCost,
            required double totalCost,
            required int createdAt,
          }) =>
              WarehouseTransferLinesCompanion.insert(
            id: id,
            transferId: transferId,
            itemId: itemId,
            quantity: quantity,
            unitCost: unitCost,
            totalCost: totalCost,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $WarehouseTransferLinesReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({transferId = false, itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (transferId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.transferId,
                    referencedTable:
                        $WarehouseTransferLinesReferences._transferIdTable(db),
                    referencedColumn: $WarehouseTransferLinesReferences
                        ._transferIdTable(db)
                        .id,
                  ) as T;
                }
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $WarehouseTransferLinesReferences._itemIdTable(db),
                    referencedColumn:
                        $WarehouseTransferLinesReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $WarehouseTransferLinesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    WarehouseTransferLines,
    WarehouseTransferLine,
    $WarehouseTransferLinesFilterComposer,
    $WarehouseTransferLinesOrderingComposer,
    $WarehouseTransferLinesAnnotationComposer,
    $WarehouseTransferLinesCreateCompanionBuilder,
    $WarehouseTransferLinesUpdateCompanionBuilder,
    (WarehouseTransferLine, $WarehouseTransferLinesReferences),
    WarehouseTransferLine,
    PrefetchHooks Function({bool transferId, bool itemId})>;
typedef $StocktakingSessionsCreateCompanionBuilder
    = StocktakingSessionsCompanion Function({
  Value<int> id,
  required String sessionNo,
  required int warehouseId,
  required int sessionDate,
  Value<String> status,
  Value<String?> notes,
  Value<int?> postedAt,
  Value<String?> postedBy,
  required String createdBy,
  required int createdAt,
  required int updatedAt,
});
typedef $StocktakingSessionsUpdateCompanionBuilder
    = StocktakingSessionsCompanion Function({
  Value<int> id,
  Value<String> sessionNo,
  Value<int> warehouseId,
  Value<int> sessionDate,
  Value<String> status,
  Value<String?> notes,
  Value<int?> postedAt,
  Value<String?> postedBy,
  Value<String> createdBy,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $StocktakingSessionsReferences extends BaseReferences<_$AppDatabase,
    StocktakingSessions, StocktakingSession> {
  $StocktakingSessionsReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static Warehouses _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.stocktakingSessions.warehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<int>('warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<StocktakingCounts, List<StocktakingCount>>
      _stocktakingCountsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.stocktakingCounts,
              aliasName: $_aliasNameGenerator(
                  db.stocktakingSessions.id, db.stocktakingCounts.sessionId));

  $StocktakingCountsProcessedTableManager get stocktakingCountsRefs {
    final manager = $StocktakingCountsTableManager($_db, $_db.stocktakingCounts)
        .filter((f) => f.sessionId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_stocktakingCountsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $StocktakingSessionsFilterComposer
    extends Composer<_$AppDatabase, StocktakingSessions> {
  $StocktakingSessionsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sessionNo => $composableBuilder(
      column: $table.sessionNo, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get sessionDate => $composableBuilder(
      column: $table.sessionDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $WarehousesFilterComposer get warehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> stocktakingCountsRefs(
      Expression<bool> Function($StocktakingCountsFilterComposer f) f) {
    final $StocktakingCountsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stocktakingCounts,
        getReferencedColumn: (t) => t.sessionId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingCountsFilterComposer(
              $db: $db,
              $table: $db.stocktakingCounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $StocktakingSessionsOrderingComposer
    extends Composer<_$AppDatabase, StocktakingSessions> {
  $StocktakingSessionsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sessionNo => $composableBuilder(
      column: $table.sessionNo, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get sessionDate => $composableBuilder(
      column: $table.sessionDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get postedAt => $composableBuilder(
      column: $table.postedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get postedBy => $composableBuilder(
      column: $table.postedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $WarehousesOrderingComposer get warehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StocktakingSessionsAnnotationComposer
    extends Composer<_$AppDatabase, StocktakingSessions> {
  $StocktakingSessionsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get sessionNo =>
      $composableBuilder(column: $table.sessionNo, builder: (column) => column);

  GeneratedColumn<int> get sessionDate => $composableBuilder(
      column: $table.sessionDate, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<int> get postedAt =>
      $composableBuilder(column: $table.postedAt, builder: (column) => column);

  GeneratedColumn<String> get postedBy =>
      $composableBuilder(column: $table.postedBy, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $WarehousesAnnotationComposer get warehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> stocktakingCountsRefs<T extends Object>(
      Expression<T> Function($StocktakingCountsAnnotationComposer a) f) {
    final $StocktakingCountsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.stocktakingCounts,
        getReferencedColumn: (t) => t.sessionId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingCountsAnnotationComposer(
              $db: $db,
              $table: $db.stocktakingCounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $StocktakingSessionsTableManager extends RootTableManager<
    _$AppDatabase,
    StocktakingSessions,
    StocktakingSession,
    $StocktakingSessionsFilterComposer,
    $StocktakingSessionsOrderingComposer,
    $StocktakingSessionsAnnotationComposer,
    $StocktakingSessionsCreateCompanionBuilder,
    $StocktakingSessionsUpdateCompanionBuilder,
    (StocktakingSession, $StocktakingSessionsReferences),
    StocktakingSession,
    PrefetchHooks Function({bool warehouseId, bool stocktakingCountsRefs})> {
  $StocktakingSessionsTableManager(_$AppDatabase db, StocktakingSessions table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $StocktakingSessionsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $StocktakingSessionsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $StocktakingSessionsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> sessionNo = const Value.absent(),
            Value<int> warehouseId = const Value.absent(),
            Value<int> sessionDate = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              StocktakingSessionsCompanion(
            id: id,
            sessionNo: sessionNo,
            warehouseId: warehouseId,
            sessionDate: sessionDate,
            status: status,
            notes: notes,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String sessionNo,
            required int warehouseId,
            required int sessionDate,
            Value<String> status = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<int?> postedAt = const Value.absent(),
            Value<String?> postedBy = const Value.absent(),
            required String createdBy,
            required int createdAt,
            required int updatedAt,
          }) =>
              StocktakingSessionsCompanion.insert(
            id: id,
            sessionNo: sessionNo,
            warehouseId: warehouseId,
            sessionDate: sessionDate,
            status: status,
            notes: notes,
            postedAt: postedAt,
            postedBy: postedBy,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $StocktakingSessionsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {warehouseId = false, stocktakingCountsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (stocktakingCountsRefs) db.stocktakingCounts
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (warehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.warehouseId,
                    referencedTable:
                        $StocktakingSessionsReferences._warehouseIdTable(db),
                    referencedColumn:
                        $StocktakingSessionsReferences._warehouseIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (stocktakingCountsRefs)
                    await $_getPrefetchedData<StocktakingSession,
                            StocktakingSessions, StocktakingCount>(
                        currentTable: table,
                        referencedTable: $StocktakingSessionsReferences
                            ._stocktakingCountsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $StocktakingSessionsReferences(db, table, p0)
                                .stocktakingCountsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.sessionId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $StocktakingSessionsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    StocktakingSessions,
    StocktakingSession,
    $StocktakingSessionsFilterComposer,
    $StocktakingSessionsOrderingComposer,
    $StocktakingSessionsAnnotationComposer,
    $StocktakingSessionsCreateCompanionBuilder,
    $StocktakingSessionsUpdateCompanionBuilder,
    (StocktakingSession, $StocktakingSessionsReferences),
    StocktakingSession,
    PrefetchHooks Function({bool warehouseId, bool stocktakingCountsRefs})>;
typedef $StocktakingCountsCreateCompanionBuilder = StocktakingCountsCompanion
    Function({
  Value<int> id,
  required int sessionId,
  required int itemId,
  required double bookQuantity,
  Value<double?> physicalQuantity,
  Value<double?> discrepancy,
  Value<double?> discrepancyValue,
  Value<int?> countedAt,
  Value<String?> countedBy,
  required int createdAt,
});
typedef $StocktakingCountsUpdateCompanionBuilder = StocktakingCountsCompanion
    Function({
  Value<int> id,
  Value<int> sessionId,
  Value<int> itemId,
  Value<double> bookQuantity,
  Value<double?> physicalQuantity,
  Value<double?> discrepancy,
  Value<double?> discrepancyValue,
  Value<int?> countedAt,
  Value<String?> countedBy,
  Value<int> createdAt,
});

final class $StocktakingCountsReferences
    extends BaseReferences<_$AppDatabase, StocktakingCounts, StocktakingCount> {
  $StocktakingCountsReferences(super.$_db, super.$_table, super.$_typedResult);

  static StocktakingSessions _sessionIdTable(_$AppDatabase db) =>
      db.stocktakingSessions.createAlias($_aliasNameGenerator(
          db.stocktakingCounts.sessionId, db.stocktakingSessions.id));

  $StocktakingSessionsProcessedTableManager get sessionId {
    final $_column = $_itemColumn<int>('session_id')!;

    final manager =
        $StocktakingSessionsTableManager($_db, $_db.stocktakingSessions)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sessionIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.stocktakingCounts.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $StocktakingCountsFilterComposer
    extends Composer<_$AppDatabase, StocktakingCounts> {
  $StocktakingCountsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get bookQuantity => $composableBuilder(
      column: $table.bookQuantity, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get physicalQuantity => $composableBuilder(
      column: $table.physicalQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discrepancy => $composableBuilder(
      column: $table.discrepancy, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get discrepancyValue => $composableBuilder(
      column: $table.discrepancyValue,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get countedAt => $composableBuilder(
      column: $table.countedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get countedBy => $composableBuilder(
      column: $table.countedBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $StocktakingSessionsFilterComposer get sessionId {
    final $StocktakingSessionsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.stocktakingSessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingSessionsFilterComposer(
              $db: $db,
              $table: $db.stocktakingSessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StocktakingCountsOrderingComposer
    extends Composer<_$AppDatabase, StocktakingCounts> {
  $StocktakingCountsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get bookQuantity => $composableBuilder(
      column: $table.bookQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get physicalQuantity => $composableBuilder(
      column: $table.physicalQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discrepancy => $composableBuilder(
      column: $table.discrepancy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get discrepancyValue => $composableBuilder(
      column: $table.discrepancyValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get countedAt => $composableBuilder(
      column: $table.countedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get countedBy => $composableBuilder(
      column: $table.countedBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $StocktakingSessionsOrderingComposer get sessionId {
    final $StocktakingSessionsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.stocktakingSessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingSessionsOrderingComposer(
              $db: $db,
              $table: $db.stocktakingSessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StocktakingCountsAnnotationComposer
    extends Composer<_$AppDatabase, StocktakingCounts> {
  $StocktakingCountsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get bookQuantity => $composableBuilder(
      column: $table.bookQuantity, builder: (column) => column);

  GeneratedColumn<double> get physicalQuantity => $composableBuilder(
      column: $table.physicalQuantity, builder: (column) => column);

  GeneratedColumn<double> get discrepancy => $composableBuilder(
      column: $table.discrepancy, builder: (column) => column);

  GeneratedColumn<double> get discrepancyValue => $composableBuilder(
      column: $table.discrepancyValue, builder: (column) => column);

  GeneratedColumn<int> get countedAt =>
      $composableBuilder(column: $table.countedAt, builder: (column) => column);

  GeneratedColumn<String> get countedBy =>
      $composableBuilder(column: $table.countedBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $StocktakingSessionsAnnotationComposer get sessionId {
    final $StocktakingSessionsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sessionId,
        referencedTable: $db.stocktakingSessions,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $StocktakingSessionsAnnotationComposer(
              $db: $db,
              $table: $db.stocktakingSessions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StocktakingCountsTableManager extends RootTableManager<
    _$AppDatabase,
    StocktakingCounts,
    StocktakingCount,
    $StocktakingCountsFilterComposer,
    $StocktakingCountsOrderingComposer,
    $StocktakingCountsAnnotationComposer,
    $StocktakingCountsCreateCompanionBuilder,
    $StocktakingCountsUpdateCompanionBuilder,
    (StocktakingCount, $StocktakingCountsReferences),
    StocktakingCount,
    PrefetchHooks Function({bool sessionId, bool itemId})> {
  $StocktakingCountsTableManager(_$AppDatabase db, StocktakingCounts table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $StocktakingCountsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $StocktakingCountsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $StocktakingCountsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> sessionId = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<double> bookQuantity = const Value.absent(),
            Value<double?> physicalQuantity = const Value.absent(),
            Value<double?> discrepancy = const Value.absent(),
            Value<double?> discrepancyValue = const Value.absent(),
            Value<int?> countedAt = const Value.absent(),
            Value<String?> countedBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
          }) =>
              StocktakingCountsCompanion(
            id: id,
            sessionId: sessionId,
            itemId: itemId,
            bookQuantity: bookQuantity,
            physicalQuantity: physicalQuantity,
            discrepancy: discrepancy,
            discrepancyValue: discrepancyValue,
            countedAt: countedAt,
            countedBy: countedBy,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int sessionId,
            required int itemId,
            required double bookQuantity,
            Value<double?> physicalQuantity = const Value.absent(),
            Value<double?> discrepancy = const Value.absent(),
            Value<double?> discrepancyValue = const Value.absent(),
            Value<int?> countedAt = const Value.absent(),
            Value<String?> countedBy = const Value.absent(),
            required int createdAt,
          }) =>
              StocktakingCountsCompanion.insert(
            id: id,
            sessionId: sessionId,
            itemId: itemId,
            bookQuantity: bookQuantity,
            physicalQuantity: physicalQuantity,
            discrepancy: discrepancy,
            discrepancyValue: discrepancyValue,
            countedAt: countedAt,
            countedBy: countedBy,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $StocktakingCountsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({sessionId = false, itemId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (sessionId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.sessionId,
                    referencedTable:
                        $StocktakingCountsReferences._sessionIdTable(db),
                    referencedColumn:
                        $StocktakingCountsReferences._sessionIdTable(db).id,
                  ) as T;
                }
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $StocktakingCountsReferences._itemIdTable(db),
                    referencedColumn:
                        $StocktakingCountsReferences._itemIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $StocktakingCountsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    StocktakingCounts,
    StocktakingCount,
    $StocktakingCountsFilterComposer,
    $StocktakingCountsOrderingComposer,
    $StocktakingCountsAnnotationComposer,
    $StocktakingCountsCreateCompanionBuilder,
    $StocktakingCountsUpdateCompanionBuilder,
    (StocktakingCount, $StocktakingCountsReferences),
    StocktakingCount,
    PrefetchHooks Function({bool sessionId, bool itemId})>;
typedef $StockReservationsCreateCompanionBuilder = StockReservationsCompanion
    Function({
  Value<int> id,
  required int itemId,
  required int warehouseId,
  required double reservedQuantity,
  required int reservationEndDate,
  Value<String?> notes,
  Value<String> status,
  required String createdBy,
  required int createdAt,
  required int updatedAt,
});
typedef $StockReservationsUpdateCompanionBuilder = StockReservationsCompanion
    Function({
  Value<int> id,
  Value<int> itemId,
  Value<int> warehouseId,
  Value<double> reservedQuantity,
  Value<int> reservationEndDate,
  Value<String?> notes,
  Value<String> status,
  Value<String> createdBy,
  Value<int> createdAt,
  Value<int> updatedAt,
});

final class $StockReservationsReferences
    extends BaseReferences<_$AppDatabase, StockReservations, StockReservation> {
  $StockReservationsReferences(super.$_db, super.$_table, super.$_typedResult);

  static Items _itemIdTable(_$AppDatabase db) => db.items.createAlias(
      $_aliasNameGenerator(db.stockReservations.itemId, db.items.id));

  $ItemsProcessedTableManager get itemId {
    final $_column = $_itemColumn<int>('item_id')!;

    final manager = $ItemsTableManager($_db, $_db.items)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_itemIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Warehouses _warehouseIdTable(_$AppDatabase db) =>
      db.warehouses.createAlias($_aliasNameGenerator(
          db.stockReservations.warehouseId, db.warehouses.id));

  $WarehousesProcessedTableManager get warehouseId {
    final $_column = $_itemColumn<int>('warehouse_id')!;

    final manager = $WarehousesTableManager($_db, $_db.warehouses)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_warehouseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $StockReservationsFilterComposer
    extends Composer<_$AppDatabase, StockReservations> {
  $StockReservationsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get reservationEndDate => $composableBuilder(
      column: $table.reservationEndDate,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $ItemsFilterComposer get itemId {
    final $ItemsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsFilterComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesFilterComposer get warehouseId {
    final $WarehousesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesFilterComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockReservationsOrderingComposer
    extends Composer<_$AppDatabase, StockReservations> {
  $StockReservationsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get reservationEndDate => $composableBuilder(
      column: $table.reservationEndDate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get createdBy => $composableBuilder(
      column: $table.createdBy, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $ItemsOrderingComposer get itemId {
    final $ItemsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsOrderingComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesOrderingComposer get warehouseId {
    final $WarehousesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesOrderingComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockReservationsAnnotationComposer
    extends Composer<_$AppDatabase, StockReservations> {
  $StockReservationsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get reservedQuantity => $composableBuilder(
      column: $table.reservedQuantity, builder: (column) => column);

  GeneratedColumn<int> get reservationEndDate => $composableBuilder(
      column: $table.reservationEndDate, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get createdBy =>
      $composableBuilder(column: $table.createdBy, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $ItemsAnnotationComposer get itemId {
    final $ItemsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.itemId,
        referencedTable: $db.items,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ItemsAnnotationComposer(
              $db: $db,
              $table: $db.items,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $WarehousesAnnotationComposer get warehouseId {
    final $WarehousesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.warehouseId,
        referencedTable: $db.warehouses,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $WarehousesAnnotationComposer(
              $db: $db,
              $table: $db.warehouses,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $StockReservationsTableManager extends RootTableManager<
    _$AppDatabase,
    StockReservations,
    StockReservation,
    $StockReservationsFilterComposer,
    $StockReservationsOrderingComposer,
    $StockReservationsAnnotationComposer,
    $StockReservationsCreateCompanionBuilder,
    $StockReservationsUpdateCompanionBuilder,
    (StockReservation, $StockReservationsReferences),
    StockReservation,
    PrefetchHooks Function({bool itemId, bool warehouseId})> {
  $StockReservationsTableManager(_$AppDatabase db, StockReservations table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $StockReservationsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $StockReservationsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $StockReservationsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> itemId = const Value.absent(),
            Value<int> warehouseId = const Value.absent(),
            Value<double> reservedQuantity = const Value.absent(),
            Value<int> reservationEndDate = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> createdBy = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
          }) =>
              StockReservationsCompanion(
            id: id,
            itemId: itemId,
            warehouseId: warehouseId,
            reservedQuantity: reservedQuantity,
            reservationEndDate: reservationEndDate,
            notes: notes,
            status: status,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int itemId,
            required int warehouseId,
            required double reservedQuantity,
            required int reservationEndDate,
            Value<String?> notes = const Value.absent(),
            Value<String> status = const Value.absent(),
            required String createdBy,
            required int createdAt,
            required int updatedAt,
          }) =>
              StockReservationsCompanion.insert(
            id: id,
            itemId: itemId,
            warehouseId: warehouseId,
            reservedQuantity: reservedQuantity,
            reservationEndDate: reservationEndDate,
            notes: notes,
            status: status,
            createdBy: createdBy,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $StockReservationsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({itemId = false, warehouseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (itemId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.itemId,
                    referencedTable:
                        $StockReservationsReferences._itemIdTable(db),
                    referencedColumn:
                        $StockReservationsReferences._itemIdTable(db).id,
                  ) as T;
                }
                if (warehouseId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.warehouseId,
                    referencedTable:
                        $StockReservationsReferences._warehouseIdTable(db),
                    referencedColumn:
                        $StockReservationsReferences._warehouseIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $StockReservationsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    StockReservations,
    StockReservation,
    $StockReservationsFilterComposer,
    $StockReservationsOrderingComposer,
    $StockReservationsAnnotationComposer,
    $StockReservationsCreateCompanionBuilder,
    $StockReservationsUpdateCompanionBuilder,
    (StockReservation, $StockReservationsReferences),
    StockReservation,
    PrefetchHooks Function({bool itemId, bool warehouseId})>;
typedef $FinancialPeriodsCreateCompanionBuilder = FinancialPeriodsCompanion
    Function({
  Value<int> id,
  required String periodCode,
  Value<String?> periodName,
  required int fiscalYear,
  required String periodType,
  Value<int?> periodNumber,
  required int startDate,
  required int endDate,
  Value<bool> isLocked,
});
typedef $FinancialPeriodsUpdateCompanionBuilder = FinancialPeriodsCompanion
    Function({
  Value<int> id,
  Value<String> periodCode,
  Value<String?> periodName,
  Value<int> fiscalYear,
  Value<String> periodType,
  Value<int?> periodNumber,
  Value<int> startDate,
  Value<int> endDate,
  Value<bool> isLocked,
});

class $FinancialPeriodsFilterComposer
    extends Composer<_$AppDatabase, FinancialPeriods> {
  $FinancialPeriodsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get periodCode => $composableBuilder(
      column: $table.periodCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get periodName => $composableBuilder(
      column: $table.periodName, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get fiscalYear => $composableBuilder(
      column: $table.fiscalYear, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get periodType => $composableBuilder(
      column: $table.periodType, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get periodNumber => $composableBuilder(
      column: $table.periodNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isLocked => $composableBuilder(
      column: $table.isLocked, builder: (column) => ColumnFilters(column));
}

class $FinancialPeriodsOrderingComposer
    extends Composer<_$AppDatabase, FinancialPeriods> {
  $FinancialPeriodsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get periodCode => $composableBuilder(
      column: $table.periodCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get periodName => $composableBuilder(
      column: $table.periodName, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get fiscalYear => $composableBuilder(
      column: $table.fiscalYear, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get periodType => $composableBuilder(
      column: $table.periodType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get periodNumber => $composableBuilder(
      column: $table.periodNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isLocked => $composableBuilder(
      column: $table.isLocked, builder: (column) => ColumnOrderings(column));
}

class $FinancialPeriodsAnnotationComposer
    extends Composer<_$AppDatabase, FinancialPeriods> {
  $FinancialPeriodsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get periodCode => $composableBuilder(
      column: $table.periodCode, builder: (column) => column);

  GeneratedColumn<String> get periodName => $composableBuilder(
      column: $table.periodName, builder: (column) => column);

  GeneratedColumn<int> get fiscalYear => $composableBuilder(
      column: $table.fiscalYear, builder: (column) => column);

  GeneratedColumn<String> get periodType => $composableBuilder(
      column: $table.periodType, builder: (column) => column);

  GeneratedColumn<int> get periodNumber => $composableBuilder(
      column: $table.periodNumber, builder: (column) => column);

  GeneratedColumn<int> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<int> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<bool> get isLocked =>
      $composableBuilder(column: $table.isLocked, builder: (column) => column);
}

class $FinancialPeriodsTableManager extends RootTableManager<
    _$AppDatabase,
    FinancialPeriods,
    FinancialPeriod,
    $FinancialPeriodsFilterComposer,
    $FinancialPeriodsOrderingComposer,
    $FinancialPeriodsAnnotationComposer,
    $FinancialPeriodsCreateCompanionBuilder,
    $FinancialPeriodsUpdateCompanionBuilder,
    (
      FinancialPeriod,
      BaseReferences<_$AppDatabase, FinancialPeriods, FinancialPeriod>
    ),
    FinancialPeriod,
    PrefetchHooks Function()> {
  $FinancialPeriodsTableManager(_$AppDatabase db, FinancialPeriods table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $FinancialPeriodsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $FinancialPeriodsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $FinancialPeriodsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> periodCode = const Value.absent(),
            Value<String?> periodName = const Value.absent(),
            Value<int> fiscalYear = const Value.absent(),
            Value<String> periodType = const Value.absent(),
            Value<int?> periodNumber = const Value.absent(),
            Value<int> startDate = const Value.absent(),
            Value<int> endDate = const Value.absent(),
            Value<bool> isLocked = const Value.absent(),
          }) =>
              FinancialPeriodsCompanion(
            id: id,
            periodCode: periodCode,
            periodName: periodName,
            fiscalYear: fiscalYear,
            periodType: periodType,
            periodNumber: periodNumber,
            startDate: startDate,
            endDate: endDate,
            isLocked: isLocked,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String periodCode,
            Value<String?> periodName = const Value.absent(),
            required int fiscalYear,
            required String periodType,
            Value<int?> periodNumber = const Value.absent(),
            required int startDate,
            required int endDate,
            Value<bool> isLocked = const Value.absent(),
          }) =>
              FinancialPeriodsCompanion.insert(
            id: id,
            periodCode: periodCode,
            periodName: periodName,
            fiscalYear: fiscalYear,
            periodType: periodType,
            periodNumber: periodNumber,
            startDate: startDate,
            endDate: endDate,
            isLocked: isLocked,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $FinancialPeriodsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    FinancialPeriods,
    FinancialPeriod,
    $FinancialPeriodsFilterComposer,
    $FinancialPeriodsOrderingComposer,
    $FinancialPeriodsAnnotationComposer,
    $FinancialPeriodsCreateCompanionBuilder,
    $FinancialPeriodsUpdateCompanionBuilder,
    (
      FinancialPeriod,
      BaseReferences<_$AppDatabase, FinancialPeriods, FinancialPeriod>
    ),
    FinancialPeriod,
    PrefetchHooks Function()>;
typedef $CurrenciesCreateCompanionBuilder = CurrenciesCompanion Function({
  required String currencyCode,
  required String nameAr,
  required String nameEn,
  required String symbol,
  required String fractionNameAr,
  required String fractionNameEn,
  required double exchangeRate,
  Value<bool> isBaseCurrency,
  required int decimalPlaces,
  Value<double?> minRateLimit,
  Value<double?> maxRateLimit,
  required bool isActive,
  Value<int> rowid,
});
typedef $CurrenciesUpdateCompanionBuilder = CurrenciesCompanion Function({
  Value<String> currencyCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String> symbol,
  Value<String> fractionNameAr,
  Value<String> fractionNameEn,
  Value<double> exchangeRate,
  Value<bool> isBaseCurrency,
  Value<int> decimalPlaces,
  Value<double?> minRateLimit,
  Value<double?> maxRateLimit,
  Value<bool> isActive,
  Value<int> rowid,
});

final class $CurrenciesReferences
    extends BaseReferences<_$AppDatabase, Currencies, Currency> {
  $CurrenciesReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<CurrencyDenominations, List<CurrencyDenomination>>
      _currencyDenominationsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.currencyDenominations,
              aliasName: $_aliasNameGenerator(db.currencies.currencyCode,
                  db.currencyDenominations.currencyCode));

  $CurrencyDenominationsProcessedTableManager get currencyDenominationsRefs {
    final manager =
        $CurrencyDenominationsTableManager($_db, $_db.currencyDenominations)
            .filter((f) => f.currencyCode.currencyCode
                .sqlEquals($_itemColumn<String>('currency_code')!));

    final cache =
        $_typedResult.readTableOrNull(_currencyDenominationsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $CurrenciesFilterComposer extends Composer<_$AppDatabase, Currencies> {
  $CurrenciesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get currencyCode => $composableBuilder(
      column: $table.currencyCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get symbol => $composableBuilder(
      column: $table.symbol, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fractionNameAr => $composableBuilder(
      column: $table.fractionNameAr,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fractionNameEn => $composableBuilder(
      column: $table.fractionNameEn,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get exchangeRate => $composableBuilder(
      column: $table.exchangeRate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isBaseCurrency => $composableBuilder(
      column: $table.isBaseCurrency,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get decimalPlaces => $composableBuilder(
      column: $table.decimalPlaces, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get minRateLimit => $composableBuilder(
      column: $table.minRateLimit, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get maxRateLimit => $composableBuilder(
      column: $table.maxRateLimit, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  Expression<bool> currencyDenominationsRefs(
      Expression<bool> Function($CurrencyDenominationsFilterComposer f) f) {
    final $CurrencyDenominationsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.currencyCode,
        referencedTable: $db.currencyDenominations,
        getReferencedColumn: (t) => t.currencyCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CurrencyDenominationsFilterComposer(
              $db: $db,
              $table: $db.currencyDenominations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CurrenciesOrderingComposer extends Composer<_$AppDatabase, Currencies> {
  $CurrenciesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get currencyCode => $composableBuilder(
      column: $table.currencyCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get symbol => $composableBuilder(
      column: $table.symbol, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fractionNameAr => $composableBuilder(
      column: $table.fractionNameAr,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fractionNameEn => $composableBuilder(
      column: $table.fractionNameEn,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get exchangeRate => $composableBuilder(
      column: $table.exchangeRate,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isBaseCurrency => $composableBuilder(
      column: $table.isBaseCurrency,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get decimalPlaces => $composableBuilder(
      column: $table.decimalPlaces,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get minRateLimit => $composableBuilder(
      column: $table.minRateLimit,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get maxRateLimit => $composableBuilder(
      column: $table.maxRateLimit,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));
}

class $CurrenciesAnnotationComposer
    extends Composer<_$AppDatabase, Currencies> {
  $CurrenciesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get currencyCode => $composableBuilder(
      column: $table.currencyCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get symbol =>
      $composableBuilder(column: $table.symbol, builder: (column) => column);

  GeneratedColumn<String> get fractionNameAr => $composableBuilder(
      column: $table.fractionNameAr, builder: (column) => column);

  GeneratedColumn<String> get fractionNameEn => $composableBuilder(
      column: $table.fractionNameEn, builder: (column) => column);

  GeneratedColumn<double> get exchangeRate => $composableBuilder(
      column: $table.exchangeRate, builder: (column) => column);

  GeneratedColumn<bool> get isBaseCurrency => $composableBuilder(
      column: $table.isBaseCurrency, builder: (column) => column);

  GeneratedColumn<int> get decimalPlaces => $composableBuilder(
      column: $table.decimalPlaces, builder: (column) => column);

  GeneratedColumn<double> get minRateLimit => $composableBuilder(
      column: $table.minRateLimit, builder: (column) => column);

  GeneratedColumn<double> get maxRateLimit => $composableBuilder(
      column: $table.maxRateLimit, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> currencyDenominationsRefs<T extends Object>(
      Expression<T> Function($CurrencyDenominationsAnnotationComposer a) f) {
    final $CurrencyDenominationsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.currencyCode,
        referencedTable: $db.currencyDenominations,
        getReferencedColumn: (t) => t.currencyCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CurrencyDenominationsAnnotationComposer(
              $db: $db,
              $table: $db.currencyDenominations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CurrenciesTableManager extends RootTableManager<
    _$AppDatabase,
    Currencies,
    Currency,
    $CurrenciesFilterComposer,
    $CurrenciesOrderingComposer,
    $CurrenciesAnnotationComposer,
    $CurrenciesCreateCompanionBuilder,
    $CurrenciesUpdateCompanionBuilder,
    (Currency, $CurrenciesReferences),
    Currency,
    PrefetchHooks Function({bool currencyDenominationsRefs})> {
  $CurrenciesTableManager(_$AppDatabase db, Currencies table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $CurrenciesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $CurrenciesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $CurrenciesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> currencyCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String> symbol = const Value.absent(),
            Value<String> fractionNameAr = const Value.absent(),
            Value<String> fractionNameEn = const Value.absent(),
            Value<double> exchangeRate = const Value.absent(),
            Value<bool> isBaseCurrency = const Value.absent(),
            Value<int> decimalPlaces = const Value.absent(),
            Value<double?> minRateLimit = const Value.absent(),
            Value<double?> maxRateLimit = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              CurrenciesCompanion(
            currencyCode: currencyCode,
            nameAr: nameAr,
            nameEn: nameEn,
            symbol: symbol,
            fractionNameAr: fractionNameAr,
            fractionNameEn: fractionNameEn,
            exchangeRate: exchangeRate,
            isBaseCurrency: isBaseCurrency,
            decimalPlaces: decimalPlaces,
            minRateLimit: minRateLimit,
            maxRateLimit: maxRateLimit,
            isActive: isActive,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String currencyCode,
            required String nameAr,
            required String nameEn,
            required String symbol,
            required String fractionNameAr,
            required String fractionNameEn,
            required double exchangeRate,
            Value<bool> isBaseCurrency = const Value.absent(),
            required int decimalPlaces,
            Value<double?> minRateLimit = const Value.absent(),
            Value<double?> maxRateLimit = const Value.absent(),
            required bool isActive,
            Value<int> rowid = const Value.absent(),
          }) =>
              CurrenciesCompanion.insert(
            currencyCode: currencyCode,
            nameAr: nameAr,
            nameEn: nameEn,
            symbol: symbol,
            fractionNameAr: fractionNameAr,
            fractionNameEn: fractionNameEn,
            exchangeRate: exchangeRate,
            isBaseCurrency: isBaseCurrency,
            decimalPlaces: decimalPlaces,
            minRateLimit: minRateLimit,
            maxRateLimit: maxRateLimit,
            isActive: isActive,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $CurrenciesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({currencyDenominationsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (currencyDenominationsRefs) db.currencyDenominations
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (currencyDenominationsRefs)
                    await $_getPrefetchedData<Currency, Currencies,
                            CurrencyDenomination>(
                        currentTable: table,
                        referencedTable: $CurrenciesReferences
                            ._currencyDenominationsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $CurrenciesReferences(db, table, p0)
                                .currencyDenominationsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems.where(
                                (e) => e.currencyCode == item.currencyCode),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $CurrenciesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Currencies,
    Currency,
    $CurrenciesFilterComposer,
    $CurrenciesOrderingComposer,
    $CurrenciesAnnotationComposer,
    $CurrenciesCreateCompanionBuilder,
    $CurrenciesUpdateCompanionBuilder,
    (Currency, $CurrenciesReferences),
    Currency,
    PrefetchHooks Function({bool currencyDenominationsRefs})>;
typedef $CurrencyDenominationsCreateCompanionBuilder
    = CurrencyDenominationsCompanion Function({
  Value<int> id,
  required String currencyCode,
  required double denominationValue,
  required String denominationNameAr,
  required String denominationNameEn,
  required String denominationType,
});
typedef $CurrencyDenominationsUpdateCompanionBuilder
    = CurrencyDenominationsCompanion Function({
  Value<int> id,
  Value<String> currencyCode,
  Value<double> denominationValue,
  Value<String> denominationNameAr,
  Value<String> denominationNameEn,
  Value<String> denominationType,
});

final class $CurrencyDenominationsReferences extends BaseReferences<
    _$AppDatabase, CurrencyDenominations, CurrencyDenomination> {
  $CurrencyDenominationsReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static Currencies _currencyCodeTable(_$AppDatabase db) =>
      db.currencies.createAlias($_aliasNameGenerator(
          db.currencyDenominations.currencyCode, db.currencies.currencyCode));

  $CurrenciesProcessedTableManager get currencyCode {
    final $_column = $_itemColumn<String>('currency_code')!;

    final manager = $CurrenciesTableManager($_db, $_db.currencies)
        .filter((f) => f.currencyCode.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_currencyCodeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $CurrencyDenominationsFilterComposer
    extends Composer<_$AppDatabase, CurrencyDenominations> {
  $CurrencyDenominationsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get denominationValue => $composableBuilder(
      column: $table.denominationValue,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get denominationNameAr => $composableBuilder(
      column: $table.denominationNameAr,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get denominationNameEn => $composableBuilder(
      column: $table.denominationNameEn,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get denominationType => $composableBuilder(
      column: $table.denominationType,
      builder: (column) => ColumnFilters(column));

  $CurrenciesFilterComposer get currencyCode {
    final $CurrenciesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.currencyCode,
        referencedTable: $db.currencies,
        getReferencedColumn: (t) => t.currencyCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CurrenciesFilterComposer(
              $db: $db,
              $table: $db.currencies,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $CurrencyDenominationsOrderingComposer
    extends Composer<_$AppDatabase, CurrencyDenominations> {
  $CurrencyDenominationsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get denominationValue => $composableBuilder(
      column: $table.denominationValue,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get denominationNameAr => $composableBuilder(
      column: $table.denominationNameAr,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get denominationNameEn => $composableBuilder(
      column: $table.denominationNameEn,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get denominationType => $composableBuilder(
      column: $table.denominationType,
      builder: (column) => ColumnOrderings(column));

  $CurrenciesOrderingComposer get currencyCode {
    final $CurrenciesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.currencyCode,
        referencedTable: $db.currencies,
        getReferencedColumn: (t) => t.currencyCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CurrenciesOrderingComposer(
              $db: $db,
              $table: $db.currencies,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $CurrencyDenominationsAnnotationComposer
    extends Composer<_$AppDatabase, CurrencyDenominations> {
  $CurrencyDenominationsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get denominationValue => $composableBuilder(
      column: $table.denominationValue, builder: (column) => column);

  GeneratedColumn<String> get denominationNameAr => $composableBuilder(
      column: $table.denominationNameAr, builder: (column) => column);

  GeneratedColumn<String> get denominationNameEn => $composableBuilder(
      column: $table.denominationNameEn, builder: (column) => column);

  GeneratedColumn<String> get denominationType => $composableBuilder(
      column: $table.denominationType, builder: (column) => column);

  $CurrenciesAnnotationComposer get currencyCode {
    final $CurrenciesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.currencyCode,
        referencedTable: $db.currencies,
        getReferencedColumn: (t) => t.currencyCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CurrenciesAnnotationComposer(
              $db: $db,
              $table: $db.currencies,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $CurrencyDenominationsTableManager extends RootTableManager<
    _$AppDatabase,
    CurrencyDenominations,
    CurrencyDenomination,
    $CurrencyDenominationsFilterComposer,
    $CurrencyDenominationsOrderingComposer,
    $CurrencyDenominationsAnnotationComposer,
    $CurrencyDenominationsCreateCompanionBuilder,
    $CurrencyDenominationsUpdateCompanionBuilder,
    (CurrencyDenomination, $CurrencyDenominationsReferences),
    CurrencyDenomination,
    PrefetchHooks Function({bool currencyCode})> {
  $CurrencyDenominationsTableManager(
      _$AppDatabase db, CurrencyDenominations table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $CurrencyDenominationsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $CurrencyDenominationsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $CurrencyDenominationsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> currencyCode = const Value.absent(),
            Value<double> denominationValue = const Value.absent(),
            Value<String> denominationNameAr = const Value.absent(),
            Value<String> denominationNameEn = const Value.absent(),
            Value<String> denominationType = const Value.absent(),
          }) =>
              CurrencyDenominationsCompanion(
            id: id,
            currencyCode: currencyCode,
            denominationValue: denominationValue,
            denominationNameAr: denominationNameAr,
            denominationNameEn: denominationNameEn,
            denominationType: denominationType,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String currencyCode,
            required double denominationValue,
            required String denominationNameAr,
            required String denominationNameEn,
            required String denominationType,
          }) =>
              CurrencyDenominationsCompanion.insert(
            id: id,
            currencyCode: currencyCode,
            denominationValue: denominationValue,
            denominationNameAr: denominationNameAr,
            denominationNameEn: denominationNameEn,
            denominationType: denominationType,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $CurrencyDenominationsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({currencyCode = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (currencyCode) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.currencyCode,
                    referencedTable:
                        $CurrencyDenominationsReferences._currencyCodeTable(db),
                    referencedColumn: $CurrencyDenominationsReferences
                        ._currencyCodeTable(db)
                        .currencyCode,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $CurrencyDenominationsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    CurrencyDenominations,
    CurrencyDenomination,
    $CurrencyDenominationsFilterComposer,
    $CurrencyDenominationsOrderingComposer,
    $CurrencyDenominationsAnnotationComposer,
    $CurrencyDenominationsCreateCompanionBuilder,
    $CurrencyDenominationsUpdateCompanionBuilder,
    (CurrencyDenomination, $CurrencyDenominationsReferences),
    CurrencyDenomination,
    PrefetchHooks Function({bool currencyCode})>;
typedef $TaxBracketCreateCompanionBuilder = TaxBracketCompanion Function({
  required String bracketCode,
  required String nameAr,
  required String nameEn,
  required double taxRate,
  Value<bool> isCompound,
  Value<bool> isDefault,
  Value<int> rowid,
});
typedef $TaxBracketUpdateCompanionBuilder = TaxBracketCompanion Function({
  Value<String> bracketCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<double> taxRate,
  Value<bool> isCompound,
  Value<bool> isDefault,
  Value<int> rowid,
});

class $TaxBracketFilterComposer extends Composer<_$AppDatabase, TaxBracket> {
  $TaxBracketFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get bracketCode => $composableBuilder(
      column: $table.bracketCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get taxRate => $composableBuilder(
      column: $table.taxRate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isCompound => $composableBuilder(
      column: $table.isCompound, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDefault => $composableBuilder(
      column: $table.isDefault, builder: (column) => ColumnFilters(column));
}

class $TaxBracketOrderingComposer extends Composer<_$AppDatabase, TaxBracket> {
  $TaxBracketOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get bracketCode => $composableBuilder(
      column: $table.bracketCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get taxRate => $composableBuilder(
      column: $table.taxRate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isCompound => $composableBuilder(
      column: $table.isCompound, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDefault => $composableBuilder(
      column: $table.isDefault, builder: (column) => ColumnOrderings(column));
}

class $TaxBracketAnnotationComposer
    extends Composer<_$AppDatabase, TaxBracket> {
  $TaxBracketAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get bracketCode => $composableBuilder(
      column: $table.bracketCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<double> get taxRate =>
      $composableBuilder(column: $table.taxRate, builder: (column) => column);

  GeneratedColumn<bool> get isCompound => $composableBuilder(
      column: $table.isCompound, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);
}

class $TaxBracketTableManager extends RootTableManager<
    _$AppDatabase,
    TaxBracket,
    TaxBracketData,
    $TaxBracketFilterComposer,
    $TaxBracketOrderingComposer,
    $TaxBracketAnnotationComposer,
    $TaxBracketCreateCompanionBuilder,
    $TaxBracketUpdateCompanionBuilder,
    (TaxBracketData, BaseReferences<_$AppDatabase, TaxBracket, TaxBracketData>),
    TaxBracketData,
    PrefetchHooks Function()> {
  $TaxBracketTableManager(_$AppDatabase db, TaxBracket table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $TaxBracketFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $TaxBracketOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $TaxBracketAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> bracketCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<double> taxRate = const Value.absent(),
            Value<bool> isCompound = const Value.absent(),
            Value<bool> isDefault = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaxBracketCompanion(
            bracketCode: bracketCode,
            nameAr: nameAr,
            nameEn: nameEn,
            taxRate: taxRate,
            isCompound: isCompound,
            isDefault: isDefault,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String bracketCode,
            required String nameAr,
            required String nameEn,
            required double taxRate,
            Value<bool> isCompound = const Value.absent(),
            Value<bool> isDefault = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaxBracketCompanion.insert(
            bracketCode: bracketCode,
            nameAr: nameAr,
            nameEn: nameEn,
            taxRate: taxRate,
            isCompound: isCompound,
            isDefault: isDefault,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $TaxBracketProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    TaxBracket,
    TaxBracketData,
    $TaxBracketFilterComposer,
    $TaxBracketOrderingComposer,
    $TaxBracketAnnotationComposer,
    $TaxBracketCreateCompanionBuilder,
    $TaxBracketUpdateCompanionBuilder,
    (TaxBracketData, BaseReferences<_$AppDatabase, TaxBracket, TaxBracketData>),
    TaxBracketData,
    PrefetchHooks Function()>;
typedef $TaxCalcMethodsCreateCompanionBuilder = TaxCalcMethodsCompanion
    Function({
  required String methodCode,
  required String nameAr,
  required String nameEn,
  required String category,
  Value<int> rowid,
});
typedef $TaxCalcMethodsUpdateCompanionBuilder = TaxCalcMethodsCompanion
    Function({
  Value<String> methodCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String> category,
  Value<int> rowid,
});

final class $TaxCalcMethodsReferences
    extends BaseReferences<_$AppDatabase, TaxCalcMethods, TaxCalcMethod> {
  $TaxCalcMethodsReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<TaxTypes, List<TaxType>> _taxTypesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.taxTypes,
          aliasName: $_aliasNameGenerator(
              db.taxCalcMethods.methodCode, db.taxTypes.calcMethodCode));

  $TaxTypesProcessedTableManager get taxTypesRefs {
    final manager = $TaxTypesTableManager($_db, $_db.taxTypes).filter((f) => f
        .calcMethodCode.methodCode
        .sqlEquals($_itemColumn<String>('method_code')!));

    final cache = $_typedResult.readTableOrNull(_taxTypesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $TaxCalcMethodsFilterComposer
    extends Composer<_$AppDatabase, TaxCalcMethods> {
  $TaxCalcMethodsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get methodCode => $composableBuilder(
      column: $table.methodCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get category => $composableBuilder(
      column: $table.category, builder: (column) => ColumnFilters(column));

  Expression<bool> taxTypesRefs(
      Expression<bool> Function($TaxTypesFilterComposer f) f) {
    final $TaxTypesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.methodCode,
        referencedTable: $db.taxTypes,
        getReferencedColumn: (t) => t.calcMethodCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $TaxTypesFilterComposer(
              $db: $db,
              $table: $db.taxTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $TaxCalcMethodsOrderingComposer
    extends Composer<_$AppDatabase, TaxCalcMethods> {
  $TaxCalcMethodsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get methodCode => $composableBuilder(
      column: $table.methodCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get category => $composableBuilder(
      column: $table.category, builder: (column) => ColumnOrderings(column));
}

class $TaxCalcMethodsAnnotationComposer
    extends Composer<_$AppDatabase, TaxCalcMethods> {
  $TaxCalcMethodsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get methodCode => $composableBuilder(
      column: $table.methodCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  Expression<T> taxTypesRefs<T extends Object>(
      Expression<T> Function($TaxTypesAnnotationComposer a) f) {
    final $TaxTypesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.methodCode,
        referencedTable: $db.taxTypes,
        getReferencedColumn: (t) => t.calcMethodCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $TaxTypesAnnotationComposer(
              $db: $db,
              $table: $db.taxTypes,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $TaxCalcMethodsTableManager extends RootTableManager<
    _$AppDatabase,
    TaxCalcMethods,
    TaxCalcMethod,
    $TaxCalcMethodsFilterComposer,
    $TaxCalcMethodsOrderingComposer,
    $TaxCalcMethodsAnnotationComposer,
    $TaxCalcMethodsCreateCompanionBuilder,
    $TaxCalcMethodsUpdateCompanionBuilder,
    (TaxCalcMethod, $TaxCalcMethodsReferences),
    TaxCalcMethod,
    PrefetchHooks Function({bool taxTypesRefs})> {
  $TaxCalcMethodsTableManager(_$AppDatabase db, TaxCalcMethods table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $TaxCalcMethodsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $TaxCalcMethodsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $TaxCalcMethodsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> methodCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String> category = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaxCalcMethodsCompanion(
            methodCode: methodCode,
            nameAr: nameAr,
            nameEn: nameEn,
            category: category,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String methodCode,
            required String nameAr,
            required String nameEn,
            required String category,
            Value<int> rowid = const Value.absent(),
          }) =>
              TaxCalcMethodsCompanion.insert(
            methodCode: methodCode,
            nameAr: nameAr,
            nameEn: nameEn,
            category: category,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $TaxCalcMethodsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({taxTypesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (taxTypesRefs) db.taxTypes],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (taxTypesRefs)
                    await $_getPrefetchedData<TaxCalcMethod, TaxCalcMethods,
                            TaxType>(
                        currentTable: table,
                        referencedTable:
                            $TaxCalcMethodsReferences._taxTypesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $TaxCalcMethodsReferences(db, table, p0)
                                .taxTypesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems.where(
                                (e) => e.calcMethodCode == item.methodCode),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $TaxCalcMethodsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    TaxCalcMethods,
    TaxCalcMethod,
    $TaxCalcMethodsFilterComposer,
    $TaxCalcMethodsOrderingComposer,
    $TaxCalcMethodsAnnotationComposer,
    $TaxCalcMethodsCreateCompanionBuilder,
    $TaxCalcMethodsUpdateCompanionBuilder,
    (TaxCalcMethod, $TaxCalcMethodsReferences),
    TaxCalcMethod,
    PrefetchHooks Function({bool taxTypesRefs})>;
typedef $TaxTypesCreateCompanionBuilder = TaxTypesCompanion Function({
  required String typeCode,
  required String nameAr,
  required String nameEn,
  required String calcMethodCode,
  Value<String?> salesAccountId,
  Value<String?> purchasesAccountId,
  Value<int> rowid,
});
typedef $TaxTypesUpdateCompanionBuilder = TaxTypesCompanion Function({
  Value<String> typeCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String> calcMethodCode,
  Value<String?> salesAccountId,
  Value<String?> purchasesAccountId,
  Value<int> rowid,
});

final class $TaxTypesReferences
    extends BaseReferences<_$AppDatabase, TaxTypes, TaxType> {
  $TaxTypesReferences(super.$_db, super.$_table, super.$_typedResult);

  static TaxCalcMethods _calcMethodCodeTable(_$AppDatabase db) =>
      db.taxCalcMethods.createAlias($_aliasNameGenerator(
          db.taxTypes.calcMethodCode, db.taxCalcMethods.methodCode));

  $TaxCalcMethodsProcessedTableManager get calcMethodCode {
    final $_column = $_itemColumn<String>('calc_method_code')!;

    final manager = $TaxCalcMethodsTableManager($_db, $_db.taxCalcMethods)
        .filter((f) => f.methodCode.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_calcMethodCodeTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $TaxTypesFilterComposer extends Composer<_$AppDatabase, TaxTypes> {
  $TaxTypesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get typeCode => $composableBuilder(
      column: $table.typeCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get salesAccountId => $composableBuilder(
      column: $table.salesAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get purchasesAccountId => $composableBuilder(
      column: $table.purchasesAccountId,
      builder: (column) => ColumnFilters(column));

  $TaxCalcMethodsFilterComposer get calcMethodCode {
    final $TaxCalcMethodsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.calcMethodCode,
        referencedTable: $db.taxCalcMethods,
        getReferencedColumn: (t) => t.methodCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $TaxCalcMethodsFilterComposer(
              $db: $db,
              $table: $db.taxCalcMethods,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $TaxTypesOrderingComposer extends Composer<_$AppDatabase, TaxTypes> {
  $TaxTypesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get typeCode => $composableBuilder(
      column: $table.typeCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get salesAccountId => $composableBuilder(
      column: $table.salesAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get purchasesAccountId => $composableBuilder(
      column: $table.purchasesAccountId,
      builder: (column) => ColumnOrderings(column));

  $TaxCalcMethodsOrderingComposer get calcMethodCode {
    final $TaxCalcMethodsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.calcMethodCode,
        referencedTable: $db.taxCalcMethods,
        getReferencedColumn: (t) => t.methodCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $TaxCalcMethodsOrderingComposer(
              $db: $db,
              $table: $db.taxCalcMethods,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $TaxTypesAnnotationComposer extends Composer<_$AppDatabase, TaxTypes> {
  $TaxTypesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get typeCode =>
      $composableBuilder(column: $table.typeCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get salesAccountId => $composableBuilder(
      column: $table.salesAccountId, builder: (column) => column);

  GeneratedColumn<String> get purchasesAccountId => $composableBuilder(
      column: $table.purchasesAccountId, builder: (column) => column);

  $TaxCalcMethodsAnnotationComposer get calcMethodCode {
    final $TaxCalcMethodsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.calcMethodCode,
        referencedTable: $db.taxCalcMethods,
        getReferencedColumn: (t) => t.methodCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $TaxCalcMethodsAnnotationComposer(
              $db: $db,
              $table: $db.taxCalcMethods,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $TaxTypesTableManager extends RootTableManager<
    _$AppDatabase,
    TaxTypes,
    TaxType,
    $TaxTypesFilterComposer,
    $TaxTypesOrderingComposer,
    $TaxTypesAnnotationComposer,
    $TaxTypesCreateCompanionBuilder,
    $TaxTypesUpdateCompanionBuilder,
    (TaxType, $TaxTypesReferences),
    TaxType,
    PrefetchHooks Function({bool calcMethodCode})> {
  $TaxTypesTableManager(_$AppDatabase db, TaxTypes table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $TaxTypesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $TaxTypesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $TaxTypesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> typeCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String> calcMethodCode = const Value.absent(),
            Value<String?> salesAccountId = const Value.absent(),
            Value<String?> purchasesAccountId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaxTypesCompanion(
            typeCode: typeCode,
            nameAr: nameAr,
            nameEn: nameEn,
            calcMethodCode: calcMethodCode,
            salesAccountId: salesAccountId,
            purchasesAccountId: purchasesAccountId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String typeCode,
            required String nameAr,
            required String nameEn,
            required String calcMethodCode,
            Value<String?> salesAccountId = const Value.absent(),
            Value<String?> purchasesAccountId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              TaxTypesCompanion.insert(
            typeCode: typeCode,
            nameAr: nameAr,
            nameEn: nameEn,
            calcMethodCode: calcMethodCode,
            salesAccountId: salesAccountId,
            purchasesAccountId: purchasesAccountId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $TaxTypesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({calcMethodCode = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (calcMethodCode) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.calcMethodCode,
                    referencedTable:
                        $TaxTypesReferences._calcMethodCodeTable(db),
                    referencedColumn:
                        $TaxTypesReferences._calcMethodCodeTable(db).methodCode,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $TaxTypesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    TaxTypes,
    TaxType,
    $TaxTypesFilterComposer,
    $TaxTypesOrderingComposer,
    $TaxTypesAnnotationComposer,
    $TaxTypesCreateCompanionBuilder,
    $TaxTypesUpdateCompanionBuilder,
    (TaxType, $TaxTypesReferences),
    TaxType,
    PrefetchHooks Function({bool calcMethodCode})>;
typedef $AccountsCreateCompanionBuilder = AccountsCompanion Function({
  Value<int> id,
  required String accountCode,
  required String accountNameAr,
  required String accountNameEn,
  required String accountTypeCode,
  Value<String?> accountGroupCode,
  Value<String?> classificationCode,
  Value<String?> reportTypeCode,
  Value<int?> parentAccountId,
  Value<bool> isParent,
  Value<bool> isActive,
  required String nature,
  required String reportType,
  Value<String?> cashFlowType,
  Value<String?> detailAccountType,
});
typedef $AccountsUpdateCompanionBuilder = AccountsCompanion Function({
  Value<int> id,
  Value<String> accountCode,
  Value<String> accountNameAr,
  Value<String> accountNameEn,
  Value<String> accountTypeCode,
  Value<String?> accountGroupCode,
  Value<String?> classificationCode,
  Value<String?> reportTypeCode,
  Value<int?> parentAccountId,
  Value<bool> isParent,
  Value<bool> isActive,
  Value<String> nature,
  Value<String> reportType,
  Value<String?> cashFlowType,
  Value<String?> detailAccountType,
});

final class $AccountsReferences
    extends BaseReferences<_$AppDatabase, Accounts, Account> {
  $AccountsReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<DescriptionCoding, List<DescriptionCodingData>>
      _descriptionCodingRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.descriptionCoding,
              aliasName: $_aliasNameGenerator(db.accounts.accountCode,
                  db.descriptionCoding.linkedAccountId));

  $DescriptionCodingProcessedTableManager get descriptionCodingRefs {
    final manager = $DescriptionCodingTableManager($_db, $_db.descriptionCoding)
        .filter((f) => f.linkedAccountId.accountCode
            .sqlEquals($_itemColumn<String>('account_code')!));

    final cache =
        $_typedResult.readTableOrNull(_descriptionCodingRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $AccountsFilterComposer extends Composer<_$AppDatabase, Accounts> {
  $AccountsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get accountCode => $composableBuilder(
      column: $table.accountCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get accountNameAr => $composableBuilder(
      column: $table.accountNameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get accountNameEn => $composableBuilder(
      column: $table.accountNameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get accountTypeCode => $composableBuilder(
      column: $table.accountTypeCode,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get accountGroupCode => $composableBuilder(
      column: $table.accountGroupCode,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get classificationCode => $composableBuilder(
      column: $table.classificationCode,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reportTypeCode => $composableBuilder(
      column: $table.reportTypeCode,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get parentAccountId => $composableBuilder(
      column: $table.parentAccountId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isParent => $composableBuilder(
      column: $table.isParent, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nature => $composableBuilder(
      column: $table.nature, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reportType => $composableBuilder(
      column: $table.reportType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cashFlowType => $composableBuilder(
      column: $table.cashFlowType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get detailAccountType => $composableBuilder(
      column: $table.detailAccountType,
      builder: (column) => ColumnFilters(column));

  Expression<bool> descriptionCodingRefs(
      Expression<bool> Function($DescriptionCodingFilterComposer f) f) {
    final $DescriptionCodingFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.accountCode,
        referencedTable: $db.descriptionCoding,
        getReferencedColumn: (t) => t.linkedAccountId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $DescriptionCodingFilterComposer(
              $db: $db,
              $table: $db.descriptionCoding,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $AccountsOrderingComposer extends Composer<_$AppDatabase, Accounts> {
  $AccountsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get accountCode => $composableBuilder(
      column: $table.accountCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get accountNameAr => $composableBuilder(
      column: $table.accountNameAr,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get accountNameEn => $composableBuilder(
      column: $table.accountNameEn,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get accountTypeCode => $composableBuilder(
      column: $table.accountTypeCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get accountGroupCode => $composableBuilder(
      column: $table.accountGroupCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get classificationCode => $composableBuilder(
      column: $table.classificationCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reportTypeCode => $composableBuilder(
      column: $table.reportTypeCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get parentAccountId => $composableBuilder(
      column: $table.parentAccountId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isParent => $composableBuilder(
      column: $table.isParent, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nature => $composableBuilder(
      column: $table.nature, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reportType => $composableBuilder(
      column: $table.reportType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cashFlowType => $composableBuilder(
      column: $table.cashFlowType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get detailAccountType => $composableBuilder(
      column: $table.detailAccountType,
      builder: (column) => ColumnOrderings(column));
}

class $AccountsAnnotationComposer extends Composer<_$AppDatabase, Accounts> {
  $AccountsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get accountCode => $composableBuilder(
      column: $table.accountCode, builder: (column) => column);

  GeneratedColumn<String> get accountNameAr => $composableBuilder(
      column: $table.accountNameAr, builder: (column) => column);

  GeneratedColumn<String> get accountNameEn => $composableBuilder(
      column: $table.accountNameEn, builder: (column) => column);

  GeneratedColumn<String> get accountTypeCode => $composableBuilder(
      column: $table.accountTypeCode, builder: (column) => column);

  GeneratedColumn<String> get accountGroupCode => $composableBuilder(
      column: $table.accountGroupCode, builder: (column) => column);

  GeneratedColumn<String> get classificationCode => $composableBuilder(
      column: $table.classificationCode, builder: (column) => column);

  GeneratedColumn<String> get reportTypeCode => $composableBuilder(
      column: $table.reportTypeCode, builder: (column) => column);

  GeneratedColumn<int> get parentAccountId => $composableBuilder(
      column: $table.parentAccountId, builder: (column) => column);

  GeneratedColumn<bool> get isParent =>
      $composableBuilder(column: $table.isParent, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<String> get nature =>
      $composableBuilder(column: $table.nature, builder: (column) => column);

  GeneratedColumn<String> get reportType => $composableBuilder(
      column: $table.reportType, builder: (column) => column);

  GeneratedColumn<String> get cashFlowType => $composableBuilder(
      column: $table.cashFlowType, builder: (column) => column);

  GeneratedColumn<String> get detailAccountType => $composableBuilder(
      column: $table.detailAccountType, builder: (column) => column);

  Expression<T> descriptionCodingRefs<T extends Object>(
      Expression<T> Function($DescriptionCodingAnnotationComposer a) f) {
    final $DescriptionCodingAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.accountCode,
        referencedTable: $db.descriptionCoding,
        getReferencedColumn: (t) => t.linkedAccountId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $DescriptionCodingAnnotationComposer(
              $db: $db,
              $table: $db.descriptionCoding,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $AccountsTableManager extends RootTableManager<
    _$AppDatabase,
    Accounts,
    Account,
    $AccountsFilterComposer,
    $AccountsOrderingComposer,
    $AccountsAnnotationComposer,
    $AccountsCreateCompanionBuilder,
    $AccountsUpdateCompanionBuilder,
    (Account, $AccountsReferences),
    Account,
    PrefetchHooks Function({bool descriptionCodingRefs})> {
  $AccountsTableManager(_$AppDatabase db, Accounts table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $AccountsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $AccountsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $AccountsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> accountCode = const Value.absent(),
            Value<String> accountNameAr = const Value.absent(),
            Value<String> accountNameEn = const Value.absent(),
            Value<String> accountTypeCode = const Value.absent(),
            Value<String?> accountGroupCode = const Value.absent(),
            Value<String?> classificationCode = const Value.absent(),
            Value<String?> reportTypeCode = const Value.absent(),
            Value<int?> parentAccountId = const Value.absent(),
            Value<bool> isParent = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<String> nature = const Value.absent(),
            Value<String> reportType = const Value.absent(),
            Value<String?> cashFlowType = const Value.absent(),
            Value<String?> detailAccountType = const Value.absent(),
          }) =>
              AccountsCompanion(
            id: id,
            accountCode: accountCode,
            accountNameAr: accountNameAr,
            accountNameEn: accountNameEn,
            accountTypeCode: accountTypeCode,
            accountGroupCode: accountGroupCode,
            classificationCode: classificationCode,
            reportTypeCode: reportTypeCode,
            parentAccountId: parentAccountId,
            isParent: isParent,
            isActive: isActive,
            nature: nature,
            reportType: reportType,
            cashFlowType: cashFlowType,
            detailAccountType: detailAccountType,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String accountCode,
            required String accountNameAr,
            required String accountNameEn,
            required String accountTypeCode,
            Value<String?> accountGroupCode = const Value.absent(),
            Value<String?> classificationCode = const Value.absent(),
            Value<String?> reportTypeCode = const Value.absent(),
            Value<int?> parentAccountId = const Value.absent(),
            Value<bool> isParent = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            required String nature,
            required String reportType,
            Value<String?> cashFlowType = const Value.absent(),
            Value<String?> detailAccountType = const Value.absent(),
          }) =>
              AccountsCompanion.insert(
            id: id,
            accountCode: accountCode,
            accountNameAr: accountNameAr,
            accountNameEn: accountNameEn,
            accountTypeCode: accountTypeCode,
            accountGroupCode: accountGroupCode,
            classificationCode: classificationCode,
            reportTypeCode: reportTypeCode,
            parentAccountId: parentAccountId,
            isParent: isParent,
            isActive: isActive,
            nature: nature,
            reportType: reportType,
            cashFlowType: cashFlowType,
            detailAccountType: detailAccountType,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $AccountsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({descriptionCodingRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (descriptionCodingRefs) db.descriptionCoding
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (descriptionCodingRefs)
                    await $_getPrefetchedData<Account, Accounts,
                            DescriptionCodingData>(
                        currentTable: table,
                        referencedTable:
                            $AccountsReferences._descriptionCodingRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $AccountsReferences(db, table, p0)
                                .descriptionCodingRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems.where(
                                (e) => e.linkedAccountId == item.accountCode),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $AccountsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Accounts,
    Account,
    $AccountsFilterComposer,
    $AccountsOrderingComposer,
    $AccountsAnnotationComposer,
    $AccountsCreateCompanionBuilder,
    $AccountsUpdateCompanionBuilder,
    (Account, $AccountsReferences),
    Account,
    PrefetchHooks Function({bool descriptionCodingRefs})>;
typedef $DocumentTypesCreateCompanionBuilder = DocumentTypesCompanion Function({
  required String docTypeCode,
  required String nameAr,
  required String nameEn,
  required String sequenceMethod,
  required String sequenceBehavior,
  Value<int> isActive,
  Value<int> createdAt,
  Value<int> updatedAt,
  Value<int> rowid,
});
typedef $DocumentTypesUpdateCompanionBuilder = DocumentTypesCompanion Function({
  Value<String> docTypeCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String> sequenceMethod,
  Value<String> sequenceBehavior,
  Value<int> isActive,
  Value<int> createdAt,
  Value<int> updatedAt,
  Value<int> rowid,
});

class $DocumentTypesFilterComposer
    extends Composer<_$AppDatabase, DocumentTypes> {
  $DocumentTypesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get docTypeCode => $composableBuilder(
      column: $table.docTypeCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sequenceMethod => $composableBuilder(
      column: $table.sequenceMethod,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sequenceBehavior => $composableBuilder(
      column: $table.sequenceBehavior,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));
}

class $DocumentTypesOrderingComposer
    extends Composer<_$AppDatabase, DocumentTypes> {
  $DocumentTypesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get docTypeCode => $composableBuilder(
      column: $table.docTypeCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sequenceMethod => $composableBuilder(
      column: $table.sequenceMethod,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sequenceBehavior => $composableBuilder(
      column: $table.sequenceBehavior,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $DocumentTypesAnnotationComposer
    extends Composer<_$AppDatabase, DocumentTypes> {
  $DocumentTypesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get docTypeCode => $composableBuilder(
      column: $table.docTypeCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get sequenceMethod => $composableBuilder(
      column: $table.sequenceMethod, builder: (column) => column);

  GeneratedColumn<String> get sequenceBehavior => $composableBuilder(
      column: $table.sequenceBehavior, builder: (column) => column);

  GeneratedColumn<int> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $DocumentTypesTableManager extends RootTableManager<
    _$AppDatabase,
    DocumentTypes,
    DocumentType,
    $DocumentTypesFilterComposer,
    $DocumentTypesOrderingComposer,
    $DocumentTypesAnnotationComposer,
    $DocumentTypesCreateCompanionBuilder,
    $DocumentTypesUpdateCompanionBuilder,
    (DocumentType, BaseReferences<_$AppDatabase, DocumentTypes, DocumentType>),
    DocumentType,
    PrefetchHooks Function()> {
  $DocumentTypesTableManager(_$AppDatabase db, DocumentTypes table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $DocumentTypesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $DocumentTypesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $DocumentTypesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> docTypeCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String> sequenceMethod = const Value.absent(),
            Value<String> sequenceBehavior = const Value.absent(),
            Value<int> isActive = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DocumentTypesCompanion(
            docTypeCode: docTypeCode,
            nameAr: nameAr,
            nameEn: nameEn,
            sequenceMethod: sequenceMethod,
            sequenceBehavior: sequenceBehavior,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String docTypeCode,
            required String nameAr,
            required String nameEn,
            required String sequenceMethod,
            required String sequenceBehavior,
            Value<int> isActive = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DocumentTypesCompanion.insert(
            docTypeCode: docTypeCode,
            nameAr: nameAr,
            nameEn: nameEn,
            sequenceMethod: sequenceMethod,
            sequenceBehavior: sequenceBehavior,
            isActive: isActive,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $DocumentTypesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    DocumentTypes,
    DocumentType,
    $DocumentTypesFilterComposer,
    $DocumentTypesOrderingComposer,
    $DocumentTypesAnnotationComposer,
    $DocumentTypesCreateCompanionBuilder,
    $DocumentTypesUpdateCompanionBuilder,
    (DocumentType, BaseReferences<_$AppDatabase, DocumentTypes, DocumentType>),
    DocumentType,
    PrefetchHooks Function()>;
typedef $DescriptionCodingCreateCompanionBuilder = DescriptionCodingCompanion
    Function({
  required String descCode,
  required String descriptionAr,
  required String descriptionEn,
  Value<String?> linkedAccountId,
  Value<int> createdAt,
  Value<int> updatedAt,
  Value<int> rowid,
});
typedef $DescriptionCodingUpdateCompanionBuilder = DescriptionCodingCompanion
    Function({
  Value<String> descCode,
  Value<String> descriptionAr,
  Value<String> descriptionEn,
  Value<String?> linkedAccountId,
  Value<int> createdAt,
  Value<int> updatedAt,
  Value<int> rowid,
});

final class $DescriptionCodingReferences extends BaseReferences<_$AppDatabase,
    DescriptionCoding, DescriptionCodingData> {
  $DescriptionCodingReferences(super.$_db, super.$_table, super.$_typedResult);

  static Accounts _linkedAccountIdTable(_$AppDatabase db) =>
      db.accounts.createAlias($_aliasNameGenerator(
          db.descriptionCoding.linkedAccountId, db.accounts.accountCode));

  $AccountsProcessedTableManager? get linkedAccountId {
    final $_column = $_itemColumn<String>('linked_account_id');
    if ($_column == null) return null;
    final manager = $AccountsTableManager($_db, $_db.accounts)
        .filter((f) => f.accountCode.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_linkedAccountIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $DescriptionCodingFilterComposer
    extends Composer<_$AppDatabase, DescriptionCoding> {
  $DescriptionCodingFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get descCode => $composableBuilder(
      column: $table.descCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get descriptionAr => $composableBuilder(
      column: $table.descriptionAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get descriptionEn => $composableBuilder(
      column: $table.descriptionEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $AccountsFilterComposer get linkedAccountId {
    final $AccountsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.linkedAccountId,
        referencedTable: $db.accounts,
        getReferencedColumn: (t) => t.accountCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $AccountsFilterComposer(
              $db: $db,
              $table: $db.accounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $DescriptionCodingOrderingComposer
    extends Composer<_$AppDatabase, DescriptionCoding> {
  $DescriptionCodingOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get descCode => $composableBuilder(
      column: $table.descCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get descriptionAr => $composableBuilder(
      column: $table.descriptionAr,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get descriptionEn => $composableBuilder(
      column: $table.descriptionEn,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $AccountsOrderingComposer get linkedAccountId {
    final $AccountsOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.linkedAccountId,
        referencedTable: $db.accounts,
        getReferencedColumn: (t) => t.accountCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $AccountsOrderingComposer(
              $db: $db,
              $table: $db.accounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $DescriptionCodingAnnotationComposer
    extends Composer<_$AppDatabase, DescriptionCoding> {
  $DescriptionCodingAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get descCode =>
      $composableBuilder(column: $table.descCode, builder: (column) => column);

  GeneratedColumn<String> get descriptionAr => $composableBuilder(
      column: $table.descriptionAr, builder: (column) => column);

  GeneratedColumn<String> get descriptionEn => $composableBuilder(
      column: $table.descriptionEn, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $AccountsAnnotationComposer get linkedAccountId {
    final $AccountsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.linkedAccountId,
        referencedTable: $db.accounts,
        getReferencedColumn: (t) => t.accountCode,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $AccountsAnnotationComposer(
              $db: $db,
              $table: $db.accounts,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $DescriptionCodingTableManager extends RootTableManager<
    _$AppDatabase,
    DescriptionCoding,
    DescriptionCodingData,
    $DescriptionCodingFilterComposer,
    $DescriptionCodingOrderingComposer,
    $DescriptionCodingAnnotationComposer,
    $DescriptionCodingCreateCompanionBuilder,
    $DescriptionCodingUpdateCompanionBuilder,
    (DescriptionCodingData, $DescriptionCodingReferences),
    DescriptionCodingData,
    PrefetchHooks Function({bool linkedAccountId})> {
  $DescriptionCodingTableManager(_$AppDatabase db, DescriptionCoding table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $DescriptionCodingFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $DescriptionCodingOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $DescriptionCodingAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<String> descCode = const Value.absent(),
            Value<String> descriptionAr = const Value.absent(),
            Value<String> descriptionEn = const Value.absent(),
            Value<String?> linkedAccountId = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DescriptionCodingCompanion(
            descCode: descCode,
            descriptionAr: descriptionAr,
            descriptionEn: descriptionEn,
            linkedAccountId: linkedAccountId,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required String descCode,
            required String descriptionAr,
            required String descriptionEn,
            Value<String?> linkedAccountId = const Value.absent(),
            Value<int> createdAt = const Value.absent(),
            Value<int> updatedAt = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              DescriptionCodingCompanion.insert(
            descCode: descCode,
            descriptionAr: descriptionAr,
            descriptionEn: descriptionEn,
            linkedAccountId: linkedAccountId,
            createdAt: createdAt,
            updatedAt: updatedAt,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $DescriptionCodingReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({linkedAccountId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (linkedAccountId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.linkedAccountId,
                    referencedTable:
                        $DescriptionCodingReferences._linkedAccountIdTable(db),
                    referencedColumn: $DescriptionCodingReferences
                        ._linkedAccountIdTable(db)
                        .accountCode,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $DescriptionCodingProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    DescriptionCoding,
    DescriptionCodingData,
    $DescriptionCodingFilterComposer,
    $DescriptionCodingOrderingComposer,
    $DescriptionCodingAnnotationComposer,
    $DescriptionCodingCreateCompanionBuilder,
    $DescriptionCodingUpdateCompanionBuilder,
    (DescriptionCodingData, $DescriptionCodingReferences),
    DescriptionCodingData,
    PrefetchHooks Function({bool linkedAccountId})>;
typedef $ZonesCreateCompanionBuilder = ZonesCompanion Function({
  Value<int> id,
  required String zoneCode,
  required String nameAr,
  required String nameEn,
  Value<bool> isActive,
});
typedef $ZonesUpdateCompanionBuilder = ZonesCompanion Function({
  Value<int> id,
  Value<String> zoneCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<bool> isActive,
});

final class $ZonesReferences
    extends BaseReferences<_$AppDatabase, Zones, Zone> {
  $ZonesReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<Countries, List<Country>> _countriesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.countries,
          aliasName: $_aliasNameGenerator(db.zones.id, db.countries.zoneId));

  $CountriesProcessedTableManager get countriesRefs {
    final manager = $CountriesTableManager($_db, $_db.countries)
        .filter((f) => f.zoneId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_countriesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $ZonesFilterComposer extends Composer<_$AppDatabase, Zones> {
  $ZonesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get zoneCode => $composableBuilder(
      column: $table.zoneCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  Expression<bool> countriesRefs(
      Expression<bool> Function($CountriesFilterComposer f) f) {
    final $CountriesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.countries,
        getReferencedColumn: (t) => t.zoneId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CountriesFilterComposer(
              $db: $db,
              $table: $db.countries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ZonesOrderingComposer extends Composer<_$AppDatabase, Zones> {
  $ZonesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get zoneCode => $composableBuilder(
      column: $table.zoneCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));
}

class $ZonesAnnotationComposer extends Composer<_$AppDatabase, Zones> {
  $ZonesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get zoneCode =>
      $composableBuilder(column: $table.zoneCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> countriesRefs<T extends Object>(
      Expression<T> Function($CountriesAnnotationComposer a) f) {
    final $CountriesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.countries,
        getReferencedColumn: (t) => t.zoneId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CountriesAnnotationComposer(
              $db: $db,
              $table: $db.countries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $ZonesTableManager extends RootTableManager<
    _$AppDatabase,
    Zones,
    Zone,
    $ZonesFilterComposer,
    $ZonesOrderingComposer,
    $ZonesAnnotationComposer,
    $ZonesCreateCompanionBuilder,
    $ZonesUpdateCompanionBuilder,
    (Zone, $ZonesReferences),
    Zone,
    PrefetchHooks Function({bool countriesRefs})> {
  $ZonesTableManager(_$AppDatabase db, Zones table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $ZonesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $ZonesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $ZonesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> zoneCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              ZonesCompanion(
            id: id,
            zoneCode: zoneCode,
            nameAr: nameAr,
            nameEn: nameEn,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String zoneCode,
            required String nameAr,
            required String nameEn,
            Value<bool> isActive = const Value.absent(),
          }) =>
              ZonesCompanion.insert(
            id: id,
            zoneCode: zoneCode,
            nameAr: nameAr,
            nameEn: nameEn,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), $ZonesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({countriesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (countriesRefs) db.countries],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (countriesRefs)
                    await $_getPrefetchedData<Zone, Zones, Country>(
                        currentTable: table,
                        referencedTable:
                            $ZonesReferences._countriesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $ZonesReferences(db, table, p0).countriesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.zoneId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $ZonesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Zones,
    Zone,
    $ZonesFilterComposer,
    $ZonesOrderingComposer,
    $ZonesAnnotationComposer,
    $ZonesCreateCompanionBuilder,
    $ZonesUpdateCompanionBuilder,
    (Zone, $ZonesReferences),
    Zone,
    PrefetchHooks Function({bool countriesRefs})>;
typedef $CountriesCreateCompanionBuilder = CountriesCompanion Function({
  Value<int> id,
  required String countryCode,
  required String nameAr,
  required String nameEn,
  required String nationalityAr,
  required String nationalityEn,
  required int zoneId,
  Value<bool> isActive,
});
typedef $CountriesUpdateCompanionBuilder = CountriesCompanion Function({
  Value<int> id,
  Value<String> countryCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String> nationalityAr,
  Value<String> nationalityEn,
  Value<int> zoneId,
  Value<bool> isActive,
});

final class $CountriesReferences
    extends BaseReferences<_$AppDatabase, Countries, Country> {
  $CountriesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Zones _zoneIdTable(_$AppDatabase db) => db.zones
      .createAlias($_aliasNameGenerator(db.countries.zoneId, db.zones.id));

  $ZonesProcessedTableManager get zoneId {
    final $_column = $_itemColumn<int>('zone_id')!;

    final manager = $ZonesTableManager($_db, $_db.zones)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_zoneIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<Governorates, List<Governorate>>
      _governoratesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.governorates,
          aliasName:
              $_aliasNameGenerator(db.countries.id, db.governorates.countryId));

  $GovernoratesProcessedTableManager get governoratesRefs {
    final manager = $GovernoratesTableManager($_db, $_db.governorates)
        .filter((f) => f.countryId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_governoratesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $CountriesFilterComposer extends Composer<_$AppDatabase, Countries> {
  $CountriesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get countryCode => $composableBuilder(
      column: $table.countryCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nationalityAr => $composableBuilder(
      column: $table.nationalityAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nationalityEn => $composableBuilder(
      column: $table.nationalityEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  $ZonesFilterComposer get zoneId {
    final $ZonesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.zoneId,
        referencedTable: $db.zones,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ZonesFilterComposer(
              $db: $db,
              $table: $db.zones,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> governoratesRefs(
      Expression<bool> Function($GovernoratesFilterComposer f) f) {
    final $GovernoratesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.governorates,
        getReferencedColumn: (t) => t.countryId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $GovernoratesFilterComposer(
              $db: $db,
              $table: $db.governorates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CountriesOrderingComposer extends Composer<_$AppDatabase, Countries> {
  $CountriesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get countryCode => $composableBuilder(
      column: $table.countryCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nationalityAr => $composableBuilder(
      column: $table.nationalityAr,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nationalityEn => $composableBuilder(
      column: $table.nationalityEn,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  $ZonesOrderingComposer get zoneId {
    final $ZonesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.zoneId,
        referencedTable: $db.zones,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ZonesOrderingComposer(
              $db: $db,
              $table: $db.zones,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $CountriesAnnotationComposer extends Composer<_$AppDatabase, Countries> {
  $CountriesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get countryCode => $composableBuilder(
      column: $table.countryCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get nationalityAr => $composableBuilder(
      column: $table.nationalityAr, builder: (column) => column);

  GeneratedColumn<String> get nationalityEn => $composableBuilder(
      column: $table.nationalityEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  $ZonesAnnotationComposer get zoneId {
    final $ZonesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.zoneId,
        referencedTable: $db.zones,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $ZonesAnnotationComposer(
              $db: $db,
              $table: $db.zones,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> governoratesRefs<T extends Object>(
      Expression<T> Function($GovernoratesAnnotationComposer a) f) {
    final $GovernoratesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.governorates,
        getReferencedColumn: (t) => t.countryId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $GovernoratesAnnotationComposer(
              $db: $db,
              $table: $db.governorates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CountriesTableManager extends RootTableManager<
    _$AppDatabase,
    Countries,
    Country,
    $CountriesFilterComposer,
    $CountriesOrderingComposer,
    $CountriesAnnotationComposer,
    $CountriesCreateCompanionBuilder,
    $CountriesUpdateCompanionBuilder,
    (Country, $CountriesReferences),
    Country,
    PrefetchHooks Function({bool zoneId, bool governoratesRefs})> {
  $CountriesTableManager(_$AppDatabase db, Countries table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $CountriesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $CountriesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $CountriesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> countryCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String> nationalityAr = const Value.absent(),
            Value<String> nationalityEn = const Value.absent(),
            Value<int> zoneId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              CountriesCompanion(
            id: id,
            countryCode: countryCode,
            nameAr: nameAr,
            nameEn: nameEn,
            nationalityAr: nationalityAr,
            nationalityEn: nationalityEn,
            zoneId: zoneId,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String countryCode,
            required String nameAr,
            required String nameEn,
            required String nationalityAr,
            required String nationalityEn,
            required int zoneId,
            Value<bool> isActive = const Value.absent(),
          }) =>
              CountriesCompanion.insert(
            id: id,
            countryCode: countryCode,
            nameAr: nameAr,
            nameEn: nameEn,
            nationalityAr: nationalityAr,
            nationalityEn: nationalityEn,
            zoneId: zoneId,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $CountriesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({zoneId = false, governoratesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (governoratesRefs) db.governorates],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (zoneId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.zoneId,
                    referencedTable: $CountriesReferences._zoneIdTable(db),
                    referencedColumn: $CountriesReferences._zoneIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (governoratesRefs)
                    await $_getPrefetchedData<Country, Countries, Governorate>(
                        currentTable: table,
                        referencedTable:
                            $CountriesReferences._governoratesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $CountriesReferences(db, table, p0)
                                .governoratesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.countryId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $CountriesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Countries,
    Country,
    $CountriesFilterComposer,
    $CountriesOrderingComposer,
    $CountriesAnnotationComposer,
    $CountriesCreateCompanionBuilder,
    $CountriesUpdateCompanionBuilder,
    (Country, $CountriesReferences),
    Country,
    PrefetchHooks Function({bool zoneId, bool governoratesRefs})>;
typedef $GovernoratesCreateCompanionBuilder = GovernoratesCompanion Function({
  Value<int> id,
  required String govCode,
  required String nameAr,
  required String nameEn,
  required int countryId,
  Value<bool> isActive,
});
typedef $GovernoratesUpdateCompanionBuilder = GovernoratesCompanion Function({
  Value<int> id,
  Value<String> govCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<int> countryId,
  Value<bool> isActive,
});

final class $GovernoratesReferences
    extends BaseReferences<_$AppDatabase, Governorates, Governorate> {
  $GovernoratesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Countries _countryIdTable(_$AppDatabase db) =>
      db.countries.createAlias(
          $_aliasNameGenerator(db.governorates.countryId, db.countries.id));

  $CountriesProcessedTableManager get countryId {
    final $_column = $_itemColumn<int>('country_id')!;

    final manager = $CountriesTableManager($_db, $_db.countries)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_countryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<Cities, List<City>> _citiesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.cities,
          aliasName: $_aliasNameGenerator(db.governorates.id, db.cities.govId));

  $CitiesProcessedTableManager get citiesRefs {
    final manager = $CitiesTableManager($_db, $_db.cities)
        .filter((f) => f.govId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_citiesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $GovernoratesFilterComposer
    extends Composer<_$AppDatabase, Governorates> {
  $GovernoratesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get govCode => $composableBuilder(
      column: $table.govCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  $CountriesFilterComposer get countryId {
    final $CountriesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.countryId,
        referencedTable: $db.countries,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CountriesFilterComposer(
              $db: $db,
              $table: $db.countries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> citiesRefs(
      Expression<bool> Function($CitiesFilterComposer f) f) {
    final $CitiesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.cities,
        getReferencedColumn: (t) => t.govId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CitiesFilterComposer(
              $db: $db,
              $table: $db.cities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $GovernoratesOrderingComposer
    extends Composer<_$AppDatabase, Governorates> {
  $GovernoratesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get govCode => $composableBuilder(
      column: $table.govCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  $CountriesOrderingComposer get countryId {
    final $CountriesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.countryId,
        referencedTable: $db.countries,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CountriesOrderingComposer(
              $db: $db,
              $table: $db.countries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $GovernoratesAnnotationComposer
    extends Composer<_$AppDatabase, Governorates> {
  $GovernoratesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get govCode =>
      $composableBuilder(column: $table.govCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  $CountriesAnnotationComposer get countryId {
    final $CountriesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.countryId,
        referencedTable: $db.countries,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CountriesAnnotationComposer(
              $db: $db,
              $table: $db.countries,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> citiesRefs<T extends Object>(
      Expression<T> Function($CitiesAnnotationComposer a) f) {
    final $CitiesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.cities,
        getReferencedColumn: (t) => t.govId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CitiesAnnotationComposer(
              $db: $db,
              $table: $db.cities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $GovernoratesTableManager extends RootTableManager<
    _$AppDatabase,
    Governorates,
    Governorate,
    $GovernoratesFilterComposer,
    $GovernoratesOrderingComposer,
    $GovernoratesAnnotationComposer,
    $GovernoratesCreateCompanionBuilder,
    $GovernoratesUpdateCompanionBuilder,
    (Governorate, $GovernoratesReferences),
    Governorate,
    PrefetchHooks Function({bool countryId, bool citiesRefs})> {
  $GovernoratesTableManager(_$AppDatabase db, Governorates table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $GovernoratesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $GovernoratesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $GovernoratesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> govCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<int> countryId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              GovernoratesCompanion(
            id: id,
            govCode: govCode,
            nameAr: nameAr,
            nameEn: nameEn,
            countryId: countryId,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String govCode,
            required String nameAr,
            required String nameEn,
            required int countryId,
            Value<bool> isActive = const Value.absent(),
          }) =>
              GovernoratesCompanion.insert(
            id: id,
            govCode: govCode,
            nameAr: nameAr,
            nameEn: nameEn,
            countryId: countryId,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $GovernoratesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({countryId = false, citiesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (citiesRefs) db.cities],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (countryId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.countryId,
                    referencedTable:
                        $GovernoratesReferences._countryIdTable(db),
                    referencedColumn:
                        $GovernoratesReferences._countryIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (citiesRefs)
                    await $_getPrefetchedData<Governorate, Governorates, City>(
                        currentTable: table,
                        referencedTable:
                            $GovernoratesReferences._citiesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $GovernoratesReferences(db, table, p0).citiesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.govId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $GovernoratesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Governorates,
    Governorate,
    $GovernoratesFilterComposer,
    $GovernoratesOrderingComposer,
    $GovernoratesAnnotationComposer,
    $GovernoratesCreateCompanionBuilder,
    $GovernoratesUpdateCompanionBuilder,
    (Governorate, $GovernoratesReferences),
    Governorate,
    PrefetchHooks Function({bool countryId, bool citiesRefs})>;
typedef $CitiesCreateCompanionBuilder = CitiesCompanion Function({
  Value<int> id,
  required String cityCode,
  required String nameAr,
  required String nameEn,
  required int govId,
  Value<bool> isActive,
});
typedef $CitiesUpdateCompanionBuilder = CitiesCompanion Function({
  Value<int> id,
  Value<String> cityCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<int> govId,
  Value<bool> isActive,
});

final class $CitiesReferences
    extends BaseReferences<_$AppDatabase, Cities, City> {
  $CitiesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Governorates _govIdTable(_$AppDatabase db) => db.governorates
      .createAlias($_aliasNameGenerator(db.cities.govId, db.governorates.id));

  $GovernoratesProcessedTableManager get govId {
    final $_column = $_itemColumn<int>('gov_id')!;

    final manager = $GovernoratesTableManager($_db, $_db.governorates)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_govIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<Regions, List<Region>> _regionsRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.regions,
          aliasName: $_aliasNameGenerator(db.cities.id, db.regions.cityId));

  $RegionsProcessedTableManager get regionsRefs {
    final manager = $RegionsTableManager($_db, $_db.regions)
        .filter((f) => f.cityId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_regionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $CitiesFilterComposer extends Composer<_$AppDatabase, Cities> {
  $CitiesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get cityCode => $composableBuilder(
      column: $table.cityCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  $GovernoratesFilterComposer get govId {
    final $GovernoratesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.govId,
        referencedTable: $db.governorates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $GovernoratesFilterComposer(
              $db: $db,
              $table: $db.governorates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> regionsRefs(
      Expression<bool> Function($RegionsFilterComposer f) f) {
    final $RegionsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.regions,
        getReferencedColumn: (t) => t.cityId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RegionsFilterComposer(
              $db: $db,
              $table: $db.regions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CitiesOrderingComposer extends Composer<_$AppDatabase, Cities> {
  $CitiesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get cityCode => $composableBuilder(
      column: $table.cityCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  $GovernoratesOrderingComposer get govId {
    final $GovernoratesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.govId,
        referencedTable: $db.governorates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $GovernoratesOrderingComposer(
              $db: $db,
              $table: $db.governorates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $CitiesAnnotationComposer extends Composer<_$AppDatabase, Cities> {
  $CitiesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get cityCode =>
      $composableBuilder(column: $table.cityCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  $GovernoratesAnnotationComposer get govId {
    final $GovernoratesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.govId,
        referencedTable: $db.governorates,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $GovernoratesAnnotationComposer(
              $db: $db,
              $table: $db.governorates,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> regionsRefs<T extends Object>(
      Expression<T> Function($RegionsAnnotationComposer a) f) {
    final $RegionsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.regions,
        getReferencedColumn: (t) => t.cityId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RegionsAnnotationComposer(
              $db: $db,
              $table: $db.regions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $CitiesTableManager extends RootTableManager<
    _$AppDatabase,
    Cities,
    City,
    $CitiesFilterComposer,
    $CitiesOrderingComposer,
    $CitiesAnnotationComposer,
    $CitiesCreateCompanionBuilder,
    $CitiesUpdateCompanionBuilder,
    (City, $CitiesReferences),
    City,
    PrefetchHooks Function({bool govId, bool regionsRefs})> {
  $CitiesTableManager(_$AppDatabase db, Cities table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $CitiesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $CitiesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $CitiesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> cityCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<int> govId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              CitiesCompanion(
            id: id,
            cityCode: cityCode,
            nameAr: nameAr,
            nameEn: nameEn,
            govId: govId,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String cityCode,
            required String nameAr,
            required String nameEn,
            required int govId,
            Value<bool> isActive = const Value.absent(),
          }) =>
              CitiesCompanion.insert(
            id: id,
            cityCode: cityCode,
            nameAr: nameAr,
            nameEn: nameEn,
            govId: govId,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), $CitiesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({govId = false, regionsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (regionsRefs) db.regions],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (govId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.govId,
                    referencedTable: $CitiesReferences._govIdTable(db),
                    referencedColumn: $CitiesReferences._govIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (regionsRefs)
                    await $_getPrefetchedData<City, Cities, Region>(
                        currentTable: table,
                        referencedTable:
                            $CitiesReferences._regionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $CitiesReferences(db, table, p0).regionsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.cityId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $CitiesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Cities,
    City,
    $CitiesFilterComposer,
    $CitiesOrderingComposer,
    $CitiesAnnotationComposer,
    $CitiesCreateCompanionBuilder,
    $CitiesUpdateCompanionBuilder,
    (City, $CitiesReferences),
    City,
    PrefetchHooks Function({bool govId, bool regionsRefs})>;
typedef $RegionsCreateCompanionBuilder = RegionsCompanion Function({
  Value<int> id,
  required String regionCode,
  required String nameAr,
  required String nameEn,
  required int cityId,
  Value<bool> isActive,
});
typedef $RegionsUpdateCompanionBuilder = RegionsCompanion Function({
  Value<int> id,
  Value<String> regionCode,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<int> cityId,
  Value<bool> isActive,
});

final class $RegionsReferences
    extends BaseReferences<_$AppDatabase, Regions, Region> {
  $RegionsReferences(super.$_db, super.$_table, super.$_typedResult);

  static Cities _cityIdTable(_$AppDatabase db) => db.cities
      .createAlias($_aliasNameGenerator(db.regions.cityId, db.cities.id));

  $CitiesProcessedTableManager get cityId {
    final $_column = $_itemColumn<int>('city_id')!;

    final manager = $CitiesTableManager($_db, $_db.cities)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_cityIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $RegionsFilterComposer extends Composer<_$AppDatabase, Regions> {
  $RegionsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get regionCode => $composableBuilder(
      column: $table.regionCode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  $CitiesFilterComposer get cityId {
    final $CitiesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.cityId,
        referencedTable: $db.cities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CitiesFilterComposer(
              $db: $db,
              $table: $db.cities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $RegionsOrderingComposer extends Composer<_$AppDatabase, Regions> {
  $RegionsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get regionCode => $composableBuilder(
      column: $table.regionCode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  $CitiesOrderingComposer get cityId {
    final $CitiesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.cityId,
        referencedTable: $db.cities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CitiesOrderingComposer(
              $db: $db,
              $table: $db.cities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $RegionsAnnotationComposer extends Composer<_$AppDatabase, Regions> {
  $RegionsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get regionCode => $composableBuilder(
      column: $table.regionCode, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  $CitiesAnnotationComposer get cityId {
    final $CitiesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.cityId,
        referencedTable: $db.cities,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $CitiesAnnotationComposer(
              $db: $db,
              $table: $db.cities,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $RegionsTableManager extends RootTableManager<
    _$AppDatabase,
    Regions,
    Region,
    $RegionsFilterComposer,
    $RegionsOrderingComposer,
    $RegionsAnnotationComposer,
    $RegionsCreateCompanionBuilder,
    $RegionsUpdateCompanionBuilder,
    (Region, $RegionsReferences),
    Region,
    PrefetchHooks Function({bool cityId})> {
  $RegionsTableManager(_$AppDatabase db, Regions table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $RegionsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $RegionsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $RegionsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> regionCode = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<int> cityId = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              RegionsCompanion(
            id: id,
            regionCode: regionCode,
            nameAr: nameAr,
            nameEn: nameEn,
            cityId: cityId,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String regionCode,
            required String nameAr,
            required String nameEn,
            required int cityId,
            Value<bool> isActive = const Value.absent(),
          }) =>
              RegionsCompanion.insert(
            id: id,
            regionCode: regionCode,
            nameAr: nameAr,
            nameEn: nameEn,
            cityId: cityId,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map(
                  (e) => (e.readTable(table), $RegionsReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({cityId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (cityId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.cityId,
                    referencedTable: $RegionsReferences._cityIdTable(db),
                    referencedColumn: $RegionsReferences._cityIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $RegionsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Regions,
    Region,
    $RegionsFilterComposer,
    $RegionsOrderingComposer,
    $RegionsAnnotationComposer,
    $RegionsCreateCompanionBuilder,
    $RegionsUpdateCompanionBuilder,
    (Region, $RegionsReferences),
    Region,
    PrefetchHooks Function({bool cityId})>;
typedef $RolesCreateCompanionBuilder = RolesCompanion Function({
  Value<int> id,
  required String nameAr,
  required String nameEn,
  Value<String?> description,
  required bool isActive,
});
typedef $RolesUpdateCompanionBuilder = RolesCompanion Function({
  Value<int> id,
  Value<String> nameAr,
  Value<String> nameEn,
  Value<String?> description,
  Value<bool> isActive,
});

final class $RolesReferences
    extends BaseReferences<_$AppDatabase, Roles, Role> {
  $RolesReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<RolePermissions, List<RolePermission>>
      _rolePermissionsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.rolePermissions,
              aliasName:
                  $_aliasNameGenerator(db.roles.id, db.rolePermissions.roleId));

  $RolePermissionsProcessedTableManager get rolePermissionsRefs {
    final manager = $RolePermissionsTableManager($_db, $_db.rolePermissions)
        .filter((f) => f.roleId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_rolePermissionsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<UserRoles, List<UserRole>> _userRolesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.userRoles,
          aliasName: $_aliasNameGenerator(db.roles.id, db.userRoles.roleId));

  $UserRolesProcessedTableManager get userRolesRefs {
    final manager = $UserRolesTableManager($_db, $_db.userRoles)
        .filter((f) => f.roleId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_userRolesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $RolesFilterComposer extends Composer<_$AppDatabase, Roles> {
  $RolesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  Expression<bool> rolePermissionsRefs(
      Expression<bool> Function($RolePermissionsFilterComposer f) f) {
    final $RolePermissionsFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.rolePermissions,
        getReferencedColumn: (t) => t.roleId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolePermissionsFilterComposer(
              $db: $db,
              $table: $db.rolePermissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> userRolesRefs(
      Expression<bool> Function($UserRolesFilterComposer f) f) {
    final $UserRolesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.userRoles,
        getReferencedColumn: (t) => t.roleId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UserRolesFilterComposer(
              $db: $db,
              $table: $db.userRoles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $RolesOrderingComposer extends Composer<_$AppDatabase, Roles> {
  $RolesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameAr => $composableBuilder(
      column: $table.nameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get nameEn => $composableBuilder(
      column: $table.nameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));
}

class $RolesAnnotationComposer extends Composer<_$AppDatabase, Roles> {
  $RolesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get nameAr =>
      $composableBuilder(column: $table.nameAr, builder: (column) => column);

  GeneratedColumn<String> get nameEn =>
      $composableBuilder(column: $table.nameEn, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  Expression<T> rolePermissionsRefs<T extends Object>(
      Expression<T> Function($RolePermissionsAnnotationComposer a) f) {
    final $RolePermissionsAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.rolePermissions,
        getReferencedColumn: (t) => t.roleId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolePermissionsAnnotationComposer(
              $db: $db,
              $table: $db.rolePermissions,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> userRolesRefs<T extends Object>(
      Expression<T> Function($UserRolesAnnotationComposer a) f) {
    final $UserRolesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.userRoles,
        getReferencedColumn: (t) => t.roleId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UserRolesAnnotationComposer(
              $db: $db,
              $table: $db.userRoles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $RolesTableManager extends RootTableManager<
    _$AppDatabase,
    Roles,
    Role,
    $RolesFilterComposer,
    $RolesOrderingComposer,
    $RolesAnnotationComposer,
    $RolesCreateCompanionBuilder,
    $RolesUpdateCompanionBuilder,
    (Role, $RolesReferences),
    Role,
    PrefetchHooks Function({bool rolePermissionsRefs, bool userRolesRefs})> {
  $RolesTableManager(_$AppDatabase db, Roles table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $RolesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $RolesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $RolesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> nameAr = const Value.absent(),
            Value<String> nameEn = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
          }) =>
              RolesCompanion(
            id: id,
            nameAr: nameAr,
            nameEn: nameEn,
            description: description,
            isActive: isActive,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String nameAr,
            required String nameEn,
            Value<String?> description = const Value.absent(),
            required bool isActive,
          }) =>
              RolesCompanion.insert(
            id: id,
            nameAr: nameAr,
            nameEn: nameEn,
            description: description,
            isActive: isActive,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), $RolesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {rolePermissionsRefs = false, userRolesRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (rolePermissionsRefs) db.rolePermissions,
                if (userRolesRefs) db.userRoles
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (rolePermissionsRefs)
                    await $_getPrefetchedData<Role, Roles, RolePermission>(
                        currentTable: table,
                        referencedTable:
                            $RolesReferences._rolePermissionsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $RolesReferences(db, table, p0).rolePermissionsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.roleId == item.id),
                        typedResults: items),
                  if (userRolesRefs)
                    await $_getPrefetchedData<Role, Roles, UserRole>(
                        currentTable: table,
                        referencedTable:
                            $RolesReferences._userRolesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $RolesReferences(db, table, p0).userRolesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.roleId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $RolesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Roles,
    Role,
    $RolesFilterComposer,
    $RolesOrderingComposer,
    $RolesAnnotationComposer,
    $RolesCreateCompanionBuilder,
    $RolesUpdateCompanionBuilder,
    (Role, $RolesReferences),
    Role,
    PrefetchHooks Function({bool rolePermissionsRefs, bool userRolesRefs})>;
typedef $RolePermissionsCreateCompanionBuilder = RolePermissionsCompanion
    Function({
  required int roleId,
  required String permission,
  Value<int> rowid,
});
typedef $RolePermissionsUpdateCompanionBuilder = RolePermissionsCompanion
    Function({
  Value<int> roleId,
  Value<String> permission,
  Value<int> rowid,
});

final class $RolePermissionsReferences
    extends BaseReferences<_$AppDatabase, RolePermissions, RolePermission> {
  $RolePermissionsReferences(super.$_db, super.$_table, super.$_typedResult);

  static Roles _roleIdTable(_$AppDatabase db) => db.roles.createAlias(
      $_aliasNameGenerator(db.rolePermissions.roleId, db.roles.id));

  $RolesProcessedTableManager get roleId {
    final $_column = $_itemColumn<int>('role_id')!;

    final manager = $RolesTableManager($_db, $_db.roles)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_roleIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $RolePermissionsFilterComposer
    extends Composer<_$AppDatabase, RolePermissions> {
  $RolePermissionsFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get permission => $composableBuilder(
      column: $table.permission, builder: (column) => ColumnFilters(column));

  $RolesFilterComposer get roleId {
    final $RolesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.roleId,
        referencedTable: $db.roles,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolesFilterComposer(
              $db: $db,
              $table: $db.roles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $RolePermissionsOrderingComposer
    extends Composer<_$AppDatabase, RolePermissions> {
  $RolePermissionsOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get permission => $composableBuilder(
      column: $table.permission, builder: (column) => ColumnOrderings(column));

  $RolesOrderingComposer get roleId {
    final $RolesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.roleId,
        referencedTable: $db.roles,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolesOrderingComposer(
              $db: $db,
              $table: $db.roles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $RolePermissionsAnnotationComposer
    extends Composer<_$AppDatabase, RolePermissions> {
  $RolePermissionsAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get permission => $composableBuilder(
      column: $table.permission, builder: (column) => column);

  $RolesAnnotationComposer get roleId {
    final $RolesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.roleId,
        referencedTable: $db.roles,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolesAnnotationComposer(
              $db: $db,
              $table: $db.roles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $RolePermissionsTableManager extends RootTableManager<
    _$AppDatabase,
    RolePermissions,
    RolePermission,
    $RolePermissionsFilterComposer,
    $RolePermissionsOrderingComposer,
    $RolePermissionsAnnotationComposer,
    $RolePermissionsCreateCompanionBuilder,
    $RolePermissionsUpdateCompanionBuilder,
    (RolePermission, $RolePermissionsReferences),
    RolePermission,
    PrefetchHooks Function({bool roleId})> {
  $RolePermissionsTableManager(_$AppDatabase db, RolePermissions table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $RolePermissionsFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $RolePermissionsOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $RolePermissionsAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> roleId = const Value.absent(),
            Value<String> permission = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              RolePermissionsCompanion(
            roleId: roleId,
            permission: permission,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int roleId,
            required String permission,
            Value<int> rowid = const Value.absent(),
          }) =>
              RolePermissionsCompanion.insert(
            roleId: roleId,
            permission: permission,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $RolePermissionsReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({roleId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (roleId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.roleId,
                    referencedTable:
                        $RolePermissionsReferences._roleIdTable(db),
                    referencedColumn:
                        $RolePermissionsReferences._roleIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $RolePermissionsProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    RolePermissions,
    RolePermission,
    $RolePermissionsFilterComposer,
    $RolePermissionsOrderingComposer,
    $RolePermissionsAnnotationComposer,
    $RolePermissionsCreateCompanionBuilder,
    $RolePermissionsUpdateCompanionBuilder,
    (RolePermission, $RolePermissionsReferences),
    RolePermission,
    PrefetchHooks Function({bool roleId})>;
typedef $UsersCreateCompanionBuilder = UsersCompanion Function({
  Value<int> userId,
  required String username,
  required String password,
  required String fullNameAr,
  required String fullNameEn,
  Value<bool> isActive,
  Value<int?> branchId,
  Value<bool> isBiometricEnabled,
  Value<bool> isDeviceLinked,
  Value<int?> lastLogin,
  Value<int> failedLoginAttempts,
});
typedef $UsersUpdateCompanionBuilder = UsersCompanion Function({
  Value<int> userId,
  Value<String> username,
  Value<String> password,
  Value<String> fullNameAr,
  Value<String> fullNameEn,
  Value<bool> isActive,
  Value<int?> branchId,
  Value<bool> isBiometricEnabled,
  Value<bool> isDeviceLinked,
  Value<int?> lastLogin,
  Value<int> failedLoginAttempts,
});

final class $UsersReferences
    extends BaseReferences<_$AppDatabase, Users, User> {
  $UsersReferences(super.$_db, super.$_table, super.$_typedResult);

  static Branches _branchIdTable(_$AppDatabase db) => db.branches
      .createAlias($_aliasNameGenerator(db.users.branchId, db.branches.id));

  $BranchesProcessedTableManager? get branchId {
    final $_column = $_itemColumn<int>('branch_id');
    if ($_column == null) return null;
    final manager = $BranchesTableManager($_db, $_db.branches)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_branchIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<UserRoles, List<UserRole>> _userRolesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.userRoles,
          aliasName:
              $_aliasNameGenerator(db.users.userId, db.userRoles.userId));

  $UserRolesProcessedTableManager get userRolesRefs {
    final manager = $UserRolesTableManager($_db, $_db.userRoles).filter(
        (f) => f.userId.userId.sqlEquals($_itemColumn<int>('user_id')!));

    final cache = $_typedResult.readTableOrNull(_userRolesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<AuditLog, List<AuditLogData>> _auditLogRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.auditLog,
          aliasName: $_aliasNameGenerator(db.users.userId, db.auditLog.userId));

  $AuditLogProcessedTableManager get auditLogRefs {
    final manager = $AuditLogTableManager($_db, $_db.auditLog).filter(
        (f) => f.userId.userId.sqlEquals($_itemColumn<int>('user_id')!));

    final cache = $_typedResult.readTableOrNull(_auditLogRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $UsersFilterComposer extends Composer<_$AppDatabase, Users> {
  $UsersFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get userId => $composableBuilder(
      column: $table.userId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get password => $composableBuilder(
      column: $table.password, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fullNameAr => $composableBuilder(
      column: $table.fullNameAr, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fullNameEn => $composableBuilder(
      column: $table.fullNameEn, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isBiometricEnabled => $composableBuilder(
      column: $table.isBiometricEnabled,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeviceLinked => $composableBuilder(
      column: $table.isDeviceLinked,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get lastLogin => $composableBuilder(
      column: $table.lastLogin, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get failedLoginAttempts => $composableBuilder(
      column: $table.failedLoginAttempts,
      builder: (column) => ColumnFilters(column));

  $BranchesFilterComposer get branchId {
    final $BranchesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchId,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesFilterComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> userRolesRefs(
      Expression<bool> Function($UserRolesFilterComposer f) f) {
    final $UserRolesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.userRoles,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UserRolesFilterComposer(
              $db: $db,
              $table: $db.userRoles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> auditLogRefs(
      Expression<bool> Function($AuditLogFilterComposer f) f) {
    final $AuditLogFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.auditLog,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $AuditLogFilterComposer(
              $db: $db,
              $table: $db.auditLog,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $UsersOrderingComposer extends Composer<_$AppDatabase, Users> {
  $UsersOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get userId => $composableBuilder(
      column: $table.userId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get password => $composableBuilder(
      column: $table.password, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fullNameAr => $composableBuilder(
      column: $table.fullNameAr, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fullNameEn => $composableBuilder(
      column: $table.fullNameEn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isActive => $composableBuilder(
      column: $table.isActive, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isBiometricEnabled => $composableBuilder(
      column: $table.isBiometricEnabled,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeviceLinked => $composableBuilder(
      column: $table.isDeviceLinked,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get lastLogin => $composableBuilder(
      column: $table.lastLogin, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get failedLoginAttempts => $composableBuilder(
      column: $table.failedLoginAttempts,
      builder: (column) => ColumnOrderings(column));

  $BranchesOrderingComposer get branchId {
    final $BranchesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchId,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesOrderingComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $UsersAnnotationComposer extends Composer<_$AppDatabase, Users> {
  $UsersAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get userId =>
      $composableBuilder(column: $table.userId, builder: (column) => column);

  GeneratedColumn<String> get username =>
      $composableBuilder(column: $table.username, builder: (column) => column);

  GeneratedColumn<String> get password =>
      $composableBuilder(column: $table.password, builder: (column) => column);

  GeneratedColumn<String> get fullNameAr => $composableBuilder(
      column: $table.fullNameAr, builder: (column) => column);

  GeneratedColumn<String> get fullNameEn => $composableBuilder(
      column: $table.fullNameEn, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<bool> get isBiometricEnabled => $composableBuilder(
      column: $table.isBiometricEnabled, builder: (column) => column);

  GeneratedColumn<bool> get isDeviceLinked => $composableBuilder(
      column: $table.isDeviceLinked, builder: (column) => column);

  GeneratedColumn<int> get lastLogin =>
      $composableBuilder(column: $table.lastLogin, builder: (column) => column);

  GeneratedColumn<int> get failedLoginAttempts => $composableBuilder(
      column: $table.failedLoginAttempts, builder: (column) => column);

  $BranchesAnnotationComposer get branchId {
    final $BranchesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.branchId,
        referencedTable: $db.branches,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $BranchesAnnotationComposer(
              $db: $db,
              $table: $db.branches,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> userRolesRefs<T extends Object>(
      Expression<T> Function($UserRolesAnnotationComposer a) f) {
    final $UserRolesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.userRoles,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UserRolesAnnotationComposer(
              $db: $db,
              $table: $db.userRoles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> auditLogRefs<T extends Object>(
      Expression<T> Function($AuditLogAnnotationComposer a) f) {
    final $AuditLogAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.auditLog,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $AuditLogAnnotationComposer(
              $db: $db,
              $table: $db.auditLog,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $UsersTableManager extends RootTableManager<
    _$AppDatabase,
    Users,
    User,
    $UsersFilterComposer,
    $UsersOrderingComposer,
    $UsersAnnotationComposer,
    $UsersCreateCompanionBuilder,
    $UsersUpdateCompanionBuilder,
    (User, $UsersReferences),
    User,
    PrefetchHooks Function(
        {bool branchId, bool userRolesRefs, bool auditLogRefs})> {
  $UsersTableManager(_$AppDatabase db, Users table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $UsersFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $UsersOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $UsersAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> userId = const Value.absent(),
            Value<String> username = const Value.absent(),
            Value<String> password = const Value.absent(),
            Value<String> fullNameAr = const Value.absent(),
            Value<String> fullNameEn = const Value.absent(),
            Value<bool> isActive = const Value.absent(),
            Value<int?> branchId = const Value.absent(),
            Value<bool> isBiometricEnabled = const Value.absent(),
            Value<bool> isDeviceLinked = const Value.absent(),
            Value<int?> lastLogin = const Value.absent(),
            Value<int> failedLoginAttempts = const Value.absent(),
          }) =>
              UsersCompanion(
            userId: userId,
            username: username,
            password: password,
            fullNameAr: fullNameAr,
            fullNameEn: fullNameEn,
            isActive: isActive,
            branchId: branchId,
            isBiometricEnabled: isBiometricEnabled,
            isDeviceLinked: isDeviceLinked,
            lastLogin: lastLogin,
            failedLoginAttempts: failedLoginAttempts,
          ),
          createCompanionCallback: ({
            Value<int> userId = const Value.absent(),
            required String username,
            required String password,
            required String fullNameAr,
            required String fullNameEn,
            Value<bool> isActive = const Value.absent(),
            Value<int?> branchId = const Value.absent(),
            Value<bool> isBiometricEnabled = const Value.absent(),
            Value<bool> isDeviceLinked = const Value.absent(),
            Value<int?> lastLogin = const Value.absent(),
            Value<int> failedLoginAttempts = const Value.absent(),
          }) =>
              UsersCompanion.insert(
            userId: userId,
            username: username,
            password: password,
            fullNameAr: fullNameAr,
            fullNameEn: fullNameEn,
            isActive: isActive,
            branchId: branchId,
            isBiometricEnabled: isBiometricEnabled,
            isDeviceLinked: isDeviceLinked,
            lastLogin: lastLogin,
            failedLoginAttempts: failedLoginAttempts,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), $UsersReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {branchId = false, userRolesRefs = false, auditLogRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (userRolesRefs) db.userRoles,
                if (auditLogRefs) db.auditLog
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (branchId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.branchId,
                    referencedTable: $UsersReferences._branchIdTable(db),
                    referencedColumn: $UsersReferences._branchIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (userRolesRefs)
                    await $_getPrefetchedData<User, Users, UserRole>(
                        currentTable: table,
                        referencedTable:
                            $UsersReferences._userRolesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $UsersReferences(db, table, p0).userRolesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.userId == item.userId),
                        typedResults: items),
                  if (auditLogRefs)
                    await $_getPrefetchedData<User, Users, AuditLogData>(
                        currentTable: table,
                        referencedTable:
                            $UsersReferences._auditLogRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $UsersReferences(db, table, p0).auditLogRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.userId == item.userId),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $UsersProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    Users,
    User,
    $UsersFilterComposer,
    $UsersOrderingComposer,
    $UsersAnnotationComposer,
    $UsersCreateCompanionBuilder,
    $UsersUpdateCompanionBuilder,
    (User, $UsersReferences),
    User,
    PrefetchHooks Function(
        {bool branchId, bool userRolesRefs, bool auditLogRefs})>;
typedef $UserRolesCreateCompanionBuilder = UserRolesCompanion Function({
  required int userId,
  required int roleId,
  Value<int> rowid,
});
typedef $UserRolesUpdateCompanionBuilder = UserRolesCompanion Function({
  Value<int> userId,
  Value<int> roleId,
  Value<int> rowid,
});

final class $UserRolesReferences
    extends BaseReferences<_$AppDatabase, UserRoles, UserRole> {
  $UserRolesReferences(super.$_db, super.$_table, super.$_typedResult);

  static Users _userIdTable(_$AppDatabase db) => db.users
      .createAlias($_aliasNameGenerator(db.userRoles.userId, db.users.userId));

  $UsersProcessedTableManager get userId {
    final $_column = $_itemColumn<int>('user_id')!;

    final manager = $UsersTableManager($_db, $_db.users)
        .filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static Roles _roleIdTable(_$AppDatabase db) => db.roles
      .createAlias($_aliasNameGenerator(db.userRoles.roleId, db.roles.id));

  $RolesProcessedTableManager get roleId {
    final $_column = $_itemColumn<int>('role_id')!;

    final manager = $RolesTableManager($_db, $_db.roles)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_roleIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $UserRolesFilterComposer extends Composer<_$AppDatabase, UserRoles> {
  $UserRolesFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  $UsersFilterComposer get userId {
    final $UsersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersFilterComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $RolesFilterComposer get roleId {
    final $RolesFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.roleId,
        referencedTable: $db.roles,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolesFilterComposer(
              $db: $db,
              $table: $db.roles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $UserRolesOrderingComposer extends Composer<_$AppDatabase, UserRoles> {
  $UserRolesOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  $UsersOrderingComposer get userId {
    final $UsersOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersOrderingComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $RolesOrderingComposer get roleId {
    final $RolesOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.roleId,
        referencedTable: $db.roles,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolesOrderingComposer(
              $db: $db,
              $table: $db.roles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $UserRolesAnnotationComposer extends Composer<_$AppDatabase, UserRoles> {
  $UserRolesAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  $UsersAnnotationComposer get userId {
    final $UsersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersAnnotationComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $RolesAnnotationComposer get roleId {
    final $RolesAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.roleId,
        referencedTable: $db.roles,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $RolesAnnotationComposer(
              $db: $db,
              $table: $db.roles,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $UserRolesTableManager extends RootTableManager<
    _$AppDatabase,
    UserRoles,
    UserRole,
    $UserRolesFilterComposer,
    $UserRolesOrderingComposer,
    $UserRolesAnnotationComposer,
    $UserRolesCreateCompanionBuilder,
    $UserRolesUpdateCompanionBuilder,
    (UserRole, $UserRolesReferences),
    UserRole,
    PrefetchHooks Function({bool userId, bool roleId})> {
  $UserRolesTableManager(_$AppDatabase db, UserRoles table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $UserRolesFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $UserRolesOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $UserRolesAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> userId = const Value.absent(),
            Value<int> roleId = const Value.absent(),
            Value<int> rowid = const Value.absent(),
          }) =>
              UserRolesCompanion(
            userId: userId,
            roleId: roleId,
            rowid: rowid,
          ),
          createCompanionCallback: ({
            required int userId,
            required int roleId,
            Value<int> rowid = const Value.absent(),
          }) =>
              UserRolesCompanion.insert(
            userId: userId,
            roleId: roleId,
            rowid: rowid,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $UserRolesReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({userId = false, roleId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (userId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.userId,
                    referencedTable: $UserRolesReferences._userIdTable(db),
                    referencedColumn:
                        $UserRolesReferences._userIdTable(db).userId,
                  ) as T;
                }
                if (roleId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.roleId,
                    referencedTable: $UserRolesReferences._roleIdTable(db),
                    referencedColumn: $UserRolesReferences._roleIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $UserRolesProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    UserRoles,
    UserRole,
    $UserRolesFilterComposer,
    $UserRolesOrderingComposer,
    $UserRolesAnnotationComposer,
    $UserRolesCreateCompanionBuilder,
    $UserRolesUpdateCompanionBuilder,
    (UserRole, $UserRolesReferences),
    UserRole,
    PrefetchHooks Function({bool userId, bool roleId})>;
typedef $AuditLogCreateCompanionBuilder = AuditLogCompanion Function({
  Value<int> id,
  required int userId,
  required double timestamp,
  required String eventAction,
  Value<String?> details,
});
typedef $AuditLogUpdateCompanionBuilder = AuditLogCompanion Function({
  Value<int> id,
  Value<int> userId,
  Value<double> timestamp,
  Value<String> eventAction,
  Value<String?> details,
});

final class $AuditLogReferences
    extends BaseReferences<_$AppDatabase, AuditLog, AuditLogData> {
  $AuditLogReferences(super.$_db, super.$_table, super.$_typedResult);

  static Users _userIdTable(_$AppDatabase db) => db.users
      .createAlias($_aliasNameGenerator(db.auditLog.userId, db.users.userId));

  $UsersProcessedTableManager get userId {
    final $_column = $_itemColumn<int>('user_id')!;

    final manager = $UsersTableManager($_db, $_db.users)
        .filter((f) => f.userId.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $AuditLogFilterComposer extends Composer<_$AppDatabase, AuditLog> {
  $AuditLogFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<double> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get eventAction => $composableBuilder(
      column: $table.eventAction, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get details => $composableBuilder(
      column: $table.details, builder: (column) => ColumnFilters(column));

  $UsersFilterComposer get userId {
    final $UsersFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersFilterComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $AuditLogOrderingComposer extends Composer<_$AppDatabase, AuditLog> {
  $AuditLogOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<double> get timestamp => $composableBuilder(
      column: $table.timestamp, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get eventAction => $composableBuilder(
      column: $table.eventAction, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get details => $composableBuilder(
      column: $table.details, builder: (column) => ColumnOrderings(column));

  $UsersOrderingComposer get userId {
    final $UsersOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersOrderingComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $AuditLogAnnotationComposer extends Composer<_$AppDatabase, AuditLog> {
  $AuditLogAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get eventAction => $composableBuilder(
      column: $table.eventAction, builder: (column) => column);

  GeneratedColumn<String> get details =>
      $composableBuilder(column: $table.details, builder: (column) => column);

  $UsersAnnotationComposer get userId {
    final $UsersAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.users,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $UsersAnnotationComposer(
              $db: $db,
              $table: $db.users,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $AuditLogTableManager extends RootTableManager<
    _$AppDatabase,
    AuditLog,
    AuditLogData,
    $AuditLogFilterComposer,
    $AuditLogOrderingComposer,
    $AuditLogAnnotationComposer,
    $AuditLogCreateCompanionBuilder,
    $AuditLogUpdateCompanionBuilder,
    (AuditLogData, $AuditLogReferences),
    AuditLogData,
    PrefetchHooks Function({bool userId})> {
  $AuditLogTableManager(_$AppDatabase db, AuditLog table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $AuditLogFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $AuditLogOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $AuditLogAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<int> userId = const Value.absent(),
            Value<double> timestamp = const Value.absent(),
            Value<String> eventAction = const Value.absent(),
            Value<String?> details = const Value.absent(),
          }) =>
              AuditLogCompanion(
            id: id,
            userId: userId,
            timestamp: timestamp,
            eventAction: eventAction,
            details: details,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required int userId,
            required double timestamp,
            required String eventAction,
            Value<String?> details = const Value.absent(),
          }) =>
              AuditLogCompanion.insert(
            id: id,
            userId: userId,
            timestamp: timestamp,
            eventAction: eventAction,
            details: details,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $AuditLogReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (userId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.userId,
                    referencedTable: $AuditLogReferences._userIdTable(db),
                    referencedColumn:
                        $AuditLogReferences._userIdTable(db).userId,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $AuditLogProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    AuditLog,
    AuditLogData,
    $AuditLogFilterComposer,
    $AuditLogOrderingComposer,
    $AuditLogAnnotationComposer,
    $AuditLogCreateCompanionBuilder,
    $AuditLogUpdateCompanionBuilder,
    (AuditLogData, $AuditLogReferences),
    AuditLogData,
    PrefetchHooks Function({bool userId})>;
typedef $SystemConfigCreateCompanionBuilder = SystemConfigCompanion Function({
  Value<int> id,
  required String language,
  required String defaultCurrencyCode,
  required String dateFormat,
  required String calendarType,
  required String accountNumberType,
  required int accountNumberLength,
  required String costCenterPolicy,
  required String projectPolicy,
  required int passwordMinLength,
  required int autoLockTimeout,
  required bool useVat,
  required bool useTds,
  required bool useEInvoice,
  required bool priceIncludesTax,
  required String backupFrequency,
  required bool cloudBackup,
  required String uiTheme,
  required String fontSize,
});
typedef $SystemConfigUpdateCompanionBuilder = SystemConfigCompanion Function({
  Value<int> id,
  Value<String> language,
  Value<String> defaultCurrencyCode,
  Value<String> dateFormat,
  Value<String> calendarType,
  Value<String> accountNumberType,
  Value<int> accountNumberLength,
  Value<String> costCenterPolicy,
  Value<String> projectPolicy,
  Value<int> passwordMinLength,
  Value<int> autoLockTimeout,
  Value<bool> useVat,
  Value<bool> useTds,
  Value<bool> useEInvoice,
  Value<bool> priceIncludesTax,
  Value<String> backupFrequency,
  Value<bool> cloudBackup,
  Value<String> uiTheme,
  Value<String> fontSize,
});

class $SystemConfigFilterComposer
    extends Composer<_$AppDatabase, SystemConfig> {
  $SystemConfigFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get language => $composableBuilder(
      column: $table.language, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get defaultCurrencyCode => $composableBuilder(
      column: $table.defaultCurrencyCode,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get dateFormat => $composableBuilder(
      column: $table.dateFormat, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get calendarType => $composableBuilder(
      column: $table.calendarType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get accountNumberType => $composableBuilder(
      column: $table.accountNumberType,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get accountNumberLength => $composableBuilder(
      column: $table.accountNumberLength,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get costCenterPolicy => $composableBuilder(
      column: $table.costCenterPolicy,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get projectPolicy => $composableBuilder(
      column: $table.projectPolicy, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get passwordMinLength => $composableBuilder(
      column: $table.passwordMinLength,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get autoLockTimeout => $composableBuilder(
      column: $table.autoLockTimeout,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get useVat => $composableBuilder(
      column: $table.useVat, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get useTds => $composableBuilder(
      column: $table.useTds, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get useEInvoice => $composableBuilder(
      column: $table.useEInvoice, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get priceIncludesTax => $composableBuilder(
      column: $table.priceIncludesTax,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get backupFrequency => $composableBuilder(
      column: $table.backupFrequency,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get cloudBackup => $composableBuilder(
      column: $table.cloudBackup, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uiTheme => $composableBuilder(
      column: $table.uiTheme, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get fontSize => $composableBuilder(
      column: $table.fontSize, builder: (column) => ColumnFilters(column));
}

class $SystemConfigOrderingComposer
    extends Composer<_$AppDatabase, SystemConfig> {
  $SystemConfigOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get language => $composableBuilder(
      column: $table.language, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get defaultCurrencyCode => $composableBuilder(
      column: $table.defaultCurrencyCode,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get dateFormat => $composableBuilder(
      column: $table.dateFormat, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get calendarType => $composableBuilder(
      column: $table.calendarType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get accountNumberType => $composableBuilder(
      column: $table.accountNumberType,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get accountNumberLength => $composableBuilder(
      column: $table.accountNumberLength,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get costCenterPolicy => $composableBuilder(
      column: $table.costCenterPolicy,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get projectPolicy => $composableBuilder(
      column: $table.projectPolicy,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get passwordMinLength => $composableBuilder(
      column: $table.passwordMinLength,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get autoLockTimeout => $composableBuilder(
      column: $table.autoLockTimeout,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get useVat => $composableBuilder(
      column: $table.useVat, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get useTds => $composableBuilder(
      column: $table.useTds, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get useEInvoice => $composableBuilder(
      column: $table.useEInvoice, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get priceIncludesTax => $composableBuilder(
      column: $table.priceIncludesTax,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get backupFrequency => $composableBuilder(
      column: $table.backupFrequency,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get cloudBackup => $composableBuilder(
      column: $table.cloudBackup, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uiTheme => $composableBuilder(
      column: $table.uiTheme, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get fontSize => $composableBuilder(
      column: $table.fontSize, builder: (column) => ColumnOrderings(column));
}

class $SystemConfigAnnotationComposer
    extends Composer<_$AppDatabase, SystemConfig> {
  $SystemConfigAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get language =>
      $composableBuilder(column: $table.language, builder: (column) => column);

  GeneratedColumn<String> get defaultCurrencyCode => $composableBuilder(
      column: $table.defaultCurrencyCode, builder: (column) => column);

  GeneratedColumn<String> get dateFormat => $composableBuilder(
      column: $table.dateFormat, builder: (column) => column);

  GeneratedColumn<String> get calendarType => $composableBuilder(
      column: $table.calendarType, builder: (column) => column);

  GeneratedColumn<String> get accountNumberType => $composableBuilder(
      column: $table.accountNumberType, builder: (column) => column);

  GeneratedColumn<int> get accountNumberLength => $composableBuilder(
      column: $table.accountNumberLength, builder: (column) => column);

  GeneratedColumn<String> get costCenterPolicy => $composableBuilder(
      column: $table.costCenterPolicy, builder: (column) => column);

  GeneratedColumn<String> get projectPolicy => $composableBuilder(
      column: $table.projectPolicy, builder: (column) => column);

  GeneratedColumn<int> get passwordMinLength => $composableBuilder(
      column: $table.passwordMinLength, builder: (column) => column);

  GeneratedColumn<int> get autoLockTimeout => $composableBuilder(
      column: $table.autoLockTimeout, builder: (column) => column);

  GeneratedColumn<bool> get useVat =>
      $composableBuilder(column: $table.useVat, builder: (column) => column);

  GeneratedColumn<bool> get useTds =>
      $composableBuilder(column: $table.useTds, builder: (column) => column);

  GeneratedColumn<bool> get useEInvoice => $composableBuilder(
      column: $table.useEInvoice, builder: (column) => column);

  GeneratedColumn<bool> get priceIncludesTax => $composableBuilder(
      column: $table.priceIncludesTax, builder: (column) => column);

  GeneratedColumn<String> get backupFrequency => $composableBuilder(
      column: $table.backupFrequency, builder: (column) => column);

  GeneratedColumn<bool> get cloudBackup => $composableBuilder(
      column: $table.cloudBackup, builder: (column) => column);

  GeneratedColumn<String> get uiTheme =>
      $composableBuilder(column: $table.uiTheme, builder: (column) => column);

  GeneratedColumn<String> get fontSize =>
      $composableBuilder(column: $table.fontSize, builder: (column) => column);
}

class $SystemConfigTableManager extends RootTableManager<
    _$AppDatabase,
    SystemConfig,
    SystemConfigData,
    $SystemConfigFilterComposer,
    $SystemConfigOrderingComposer,
    $SystemConfigAnnotationComposer,
    $SystemConfigCreateCompanionBuilder,
    $SystemConfigUpdateCompanionBuilder,
    (
      SystemConfigData,
      BaseReferences<_$AppDatabase, SystemConfig, SystemConfigData>
    ),
    SystemConfigData,
    PrefetchHooks Function()> {
  $SystemConfigTableManager(_$AppDatabase db, SystemConfig table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $SystemConfigFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $SystemConfigOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $SystemConfigAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> language = const Value.absent(),
            Value<String> defaultCurrencyCode = const Value.absent(),
            Value<String> dateFormat = const Value.absent(),
            Value<String> calendarType = const Value.absent(),
            Value<String> accountNumberType = const Value.absent(),
            Value<int> accountNumberLength = const Value.absent(),
            Value<String> costCenterPolicy = const Value.absent(),
            Value<String> projectPolicy = const Value.absent(),
            Value<int> passwordMinLength = const Value.absent(),
            Value<int> autoLockTimeout = const Value.absent(),
            Value<bool> useVat = const Value.absent(),
            Value<bool> useTds = const Value.absent(),
            Value<bool> useEInvoice = const Value.absent(),
            Value<bool> priceIncludesTax = const Value.absent(),
            Value<String> backupFrequency = const Value.absent(),
            Value<bool> cloudBackup = const Value.absent(),
            Value<String> uiTheme = const Value.absent(),
            Value<String> fontSize = const Value.absent(),
          }) =>
              SystemConfigCompanion(
            id: id,
            language: language,
            defaultCurrencyCode: defaultCurrencyCode,
            dateFormat: dateFormat,
            calendarType: calendarType,
            accountNumberType: accountNumberType,
            accountNumberLength: accountNumberLength,
            costCenterPolicy: costCenterPolicy,
            projectPolicy: projectPolicy,
            passwordMinLength: passwordMinLength,
            autoLockTimeout: autoLockTimeout,
            useVat: useVat,
            useTds: useTds,
            useEInvoice: useEInvoice,
            priceIncludesTax: priceIncludesTax,
            backupFrequency: backupFrequency,
            cloudBackup: cloudBackup,
            uiTheme: uiTheme,
            fontSize: fontSize,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String language,
            required String defaultCurrencyCode,
            required String dateFormat,
            required String calendarType,
            required String accountNumberType,
            required int accountNumberLength,
            required String costCenterPolicy,
            required String projectPolicy,
            required int passwordMinLength,
            required int autoLockTimeout,
            required bool useVat,
            required bool useTds,
            required bool useEInvoice,
            required bool priceIncludesTax,
            required String backupFrequency,
            required bool cloudBackup,
            required String uiTheme,
            required String fontSize,
          }) =>
              SystemConfigCompanion.insert(
            id: id,
            language: language,
            defaultCurrencyCode: defaultCurrencyCode,
            dateFormat: dateFormat,
            calendarType: calendarType,
            accountNumberType: accountNumberType,
            accountNumberLength: accountNumberLength,
            costCenterPolicy: costCenterPolicy,
            projectPolicy: projectPolicy,
            passwordMinLength: passwordMinLength,
            autoLockTimeout: autoLockTimeout,
            useVat: useVat,
            useTds: useTds,
            useEInvoice: useEInvoice,
            priceIncludesTax: priceIncludesTax,
            backupFrequency: backupFrequency,
            cloudBackup: cloudBackup,
            uiTheme: uiTheme,
            fontSize: fontSize,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ));
}

typedef $SystemConfigProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    SystemConfig,
    SystemConfigData,
    $SystemConfigFilterComposer,
    $SystemConfigOrderingComposer,
    $SystemConfigAnnotationComposer,
    $SystemConfigCreateCompanionBuilder,
    $SystemConfigUpdateCompanionBuilder,
    (
      SystemConfigData,
      BaseReferences<_$AppDatabase, SystemConfig, SystemConfigData>
    ),
    SystemConfigData,
    PrefetchHooks Function()>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $InventoryConfigTableManager get inventoryConfig =>
      $InventoryConfigTableManager(_db, _db.inventoryConfig);
  $CompanyInfoTableManager get companyInfo =>
      $CompanyInfoTableManager(_db, _db.companyInfo);
  $BranchGroupsTableManager get branchGroups =>
      $BranchGroupsTableManager(_db, _db.branchGroups);
  $BranchesTableManager get branches =>
      $BranchesTableManager(_db, _db.branches);
  $WarehousesTableManager get warehouses =>
      $WarehousesTableManager(_db, _db.warehouses);
  $ItemGroupsTableManager get itemGroups =>
      $ItemGroupsTableManager(_db, _db.itemGroups);
  $ItemsTableManager get items => $ItemsTableManager(_db, _db.items);
  $ItemSubUnitsTableManager get itemSubUnits =>
      $ItemSubUnitsTableManager(_db, _db.itemSubUnits);
  $ItemSellingPricesTableManager get itemSellingPrices =>
      $ItemSellingPricesTableManager(_db, _db.itemSellingPrices);
  $ItemPromotionalPricesTableManager get itemPromotionalPrices =>
      $ItemPromotionalPricesTableManager(_db, _db.itemPromotionalPrices);
  $ItemAttachmentsTableManager get itemAttachments =>
      $ItemAttachmentsTableManager(_db, _db.itemAttachments);
  $StockBalancesTableManager get stockBalances =>
      $StockBalancesTableManager(_db, _db.stockBalances);
  $StockTransactionsTableManager get stockTransactions =>
      $StockTransactionsTableManager(_db, _db.stockTransactions);
  $IncomingStockOrdersTableManager get incomingStockOrders =>
      $IncomingStockOrdersTableManager(_db, _db.incomingStockOrders);
  $IncomingStockOrderLinesTableManager get incomingStockOrderLines =>
      $IncomingStockOrderLinesTableManager(_db, _db.incomingStockOrderLines);
  $OutgoingStockOrdersTableManager get outgoingStockOrders =>
      $OutgoingStockOrdersTableManager(_db, _db.outgoingStockOrders);
  $OutgoingStockOrderLinesTableManager get outgoingStockOrderLines =>
      $OutgoingStockOrderLinesTableManager(_db, _db.outgoingStockOrderLines);
  $WarehouseTransfersTableManager get warehouseTransfers =>
      $WarehouseTransfersTableManager(_db, _db.warehouseTransfers);
  $WarehouseTransferLinesTableManager get warehouseTransferLines =>
      $WarehouseTransferLinesTableManager(_db, _db.warehouseTransferLines);
  $StocktakingSessionsTableManager get stocktakingSessions =>
      $StocktakingSessionsTableManager(_db, _db.stocktakingSessions);
  $StocktakingCountsTableManager get stocktakingCounts =>
      $StocktakingCountsTableManager(_db, _db.stocktakingCounts);
  $StockReservationsTableManager get stockReservations =>
      $StockReservationsTableManager(_db, _db.stockReservations);
  $FinancialPeriodsTableManager get financialPeriods =>
      $FinancialPeriodsTableManager(_db, _db.financialPeriods);
  $CurrenciesTableManager get currencies =>
      $CurrenciesTableManager(_db, _db.currencies);
  $CurrencyDenominationsTableManager get currencyDenominations =>
      $CurrencyDenominationsTableManager(_db, _db.currencyDenominations);
  $TaxBracketTableManager get taxBracket =>
      $TaxBracketTableManager(_db, _db.taxBracket);
  $TaxCalcMethodsTableManager get taxCalcMethods =>
      $TaxCalcMethodsTableManager(_db, _db.taxCalcMethods);
  $TaxTypesTableManager get taxTypes =>
      $TaxTypesTableManager(_db, _db.taxTypes);
  $AccountsTableManager get accounts =>
      $AccountsTableManager(_db, _db.accounts);
  $DocumentTypesTableManager get documentTypes =>
      $DocumentTypesTableManager(_db, _db.documentTypes);
  $DescriptionCodingTableManager get descriptionCoding =>
      $DescriptionCodingTableManager(_db, _db.descriptionCoding);
  $ZonesTableManager get zones => $ZonesTableManager(_db, _db.zones);
  $CountriesTableManager get countries =>
      $CountriesTableManager(_db, _db.countries);
  $GovernoratesTableManager get governorates =>
      $GovernoratesTableManager(_db, _db.governorates);
  $CitiesTableManager get cities => $CitiesTableManager(_db, _db.cities);
  $RegionsTableManager get regions => $RegionsTableManager(_db, _db.regions);
  $RolesTableManager get roles => $RolesTableManager(_db, _db.roles);
  $RolePermissionsTableManager get rolePermissions =>
      $RolePermissionsTableManager(_db, _db.rolePermissions);
  $UsersTableManager get users => $UsersTableManager(_db, _db.users);
  $UserRolesTableManager get userRoles =>
      $UserRolesTableManager(_db, _db.userRoles);
  $AuditLogTableManager get auditLog =>
      $AuditLogTableManager(_db, _db.auditLog);
  $SystemConfigTableManager get systemConfig =>
      $SystemConfigTableManager(_db, _db.systemConfig);
}
